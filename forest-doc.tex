%% forest-doc.tex
%% `forest-doc.tex` is a main documentation source of package `forest`.
%%
%% Copyright (c) 2012-2017 Saso Zivanovic
%%                         (Sa\v{s}o \v{Z}ivanovi\'{c})
%% saso.zivanovic@guest.arnes.si
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest versionx of this license is in
%% 
%%   http://www.latex-project.org/lppl.txt
%%   
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%% 
%% This work has the LPPL maintenance status `author-maintained'.
%% 
%% This file is a part of package `forest'. For the list of files
%% constituting the package see main source file of the package,
%% `forest.dtx', or the derived `forest.sty'.
%%
\documentclass{ltxdoc}
\usepackage[a4paper,
  top=2cm,bottom=2.5cm,
  reversemarginpar,marginparwidth=2cm,
  right=1.5cm,
  nohead
]{geometry}

\immediate\write18{makeindex -s forest-doc.ist forest-doc}
\def\indexlettertotoc#1\relax{%
  \phantomsection\addcontentsline{toc}{subsection}{#1}%
  #1%
}
\makeatletter
\c@IndexColumns=2 \makeatother
\IndexPrologue{Color legend: \textcolor{red}{definition}, \textcolor{darkgreen}{example}, \textcolor{blue}{other}. If an entry belongs to a library, the library name is given in parenthesis. All page numbers are hyperlinks, and definitions in text are hyperlinked to this index.}
\makeindex

\makeatletter
\def\bigbadforlist{}
\def\forest@@doc@@hook@bigbadforlist{\aftergroup\forest@@doc@@hook@bigbadforlist@}
\def\forest@@doc@@hook@bigbadforlist@{%
  \forestset{define long step/.append code={%
      \ifforest@nodewalkstephandler@makefor
        \appto\bigbadforlist{[##1]}%
      \fi
    }%
  }%
}
\def\bigbadprocesslist{}
\makeatother
\usepackage[external]{forest}
\useforestlibrary{edges}
\useforestlibrary{linguistics}
% \tikzexternalize
% forest-tikzexternalize either contains \tikzexternalize or not ... make adjusts this
\IfFileExists{forest-doc.tex-externalize.tex}{%
  \input forest-doc.tex-externalize\relax
}{}
\tikzset{
  external/prefix={forest.for.dir/},
  external/system call={
    pdflatex \tikzexternalcheckshellescape -halt-on-error -interaction=nonstopmode -jobname "\image" "\texsource"},
  external/up to date check=simple,
}

\usepackage{forest-doc} 
% \usepackage{patchpgf}
% \newcommand\pgfprofilenewforcommandcs[2]{%
%   \expandafter\pgfprofilenewforcommand\expandafter{\csname #1\endcsname}{#2}}
% \newcommand\pgfprofilenewforpgfkey[1]{%
%   \edef\marshal{%
%     \noexpand\pgfprofilenewforcommandpattern[#1]{\expandonce{\csname pgfk@#1/.@cmd\endcsname}}{####1\noexpand\pgfeov}{####1\noexpand\pgfeov}
%   }\marshal
% }
% \usetikzlibrary{profiler}
% \makeatletter
% \pgfprofilenewforcommand{\forestindex@index}{3}
% \pgfprofilenewforcommand{\pgfmathparse}{1}
% \pgfprofilenewforpgfkey{/forest/split}
% \pgfprofilenewforpgfkey{/forest/nodewalk/reverse}
% \pgfprofilenewforcommand{\forest@Nodewalk}{2}
% \pgfprofilenewforcommand{\pgfkeysalso}{1}
% \makeatother

\usepackage{hyperref}
\hypersetup{unicode=true,colorlinks=true,linkcolor=blue,citecolor=blue,hyperindex=false}
\usepackage{url}
\usepackage[numbers]{natbib}
\usepackage[multiple]{footmisc}
\usepackage{tipa}
\usepackage[inline,shortlabels]{enumitem}
\newlist{compactitem}{itemize}{2}
\setlist[compactitem]{nosep,label=\textbullet}
\newlist{arguments}{enumerate}{1}
\setlist[arguments]{nosep,label=\textbf{\#\arabic*}}
\renewcommand\DescribeMacro[1]{\texttt{\detokenize{#1}}\marginpar{\hfill\small\strut\texttt{\detokenize{#1}}}}
\usepackage{printlen}
\usepackage{tabularx}
\DeleteShortVerb\|
\newcommand\OR{\ensuremath{\,|\,}}%
\usepackage{multicol}

%\usepackage[silent]{trace-pgfkeys} % silent, stack, trace, verbose
%\pgfkeystracelevel{trace}

  %%% begin listing region: index_macro_style
\forestset{
  detokenize/.style={result=\protect\detokenize{##1}},
  tt/.style={result=\protect\texttt{##1}},
  macro/.style={detokenize, +result={\char\escapechar}, tt, print in color, hyper},
}
  %%% end listing region: index_macro_style
\forestset{
  pgfkey/.style={tt,print in color,hyper},
  path/.style={+result={/},pgfkey},
  handler/.style={+result={.},pgfkey},
  option value/.style={
    format={tt,result+={ value}},
    for first={format=pgfkey},
  },
  environment/.style={
    detokenize,
    tt,
    print in color,
    if stage={index}{}{
      if index entry type={definition}{
        temptoksa/.register=result,
        hyper,
        result/.process=ROw2{result}{argument}{%
          \texttt{\string\begin\char`\{##1\char`\}}%
            ##2%
          \texttt{\string\end\char`\{##1\char`\}}%
        }
      }{
        hyper
      }
    }
  },
  empty/.style={result={{}}},
  meta/.style={result=\protect\meta{##1},print in color,hyper},
  index library/.style={
    if index entry type={definition}{
        for first leaf'={
          index format+={
            result+'={\space
              {\protect\scriptsize
                (\protect\texttt{\protect\hyperrefnocolor[sec:library-#1]{#1}})%
              }%
            }
          }
      },
    }{}
  },
  margin/.style={print format={result=\marginpar{\strut##1}}},
  also margin/.style={print format={result=##1\marginpar{\strut##1}}},
}

\let\origmeta\meta
\renewcommand\meta[1]{\origmeta{\rm\ignorespaces#1}}
\renewcommand\rstyle{\color{red}}
\newcommand\hyperrefnocolor[2][]{{\hypersetup{linkcolor=black}\hyperref[#1]{#2}}}
\newcommand\librarysection[1]{%
  \subsection{\protect\texttt{#1}}%
  \label{sec:library-#1}%
  \forestset{every index end/.style={set={index library={#1}}}}%
}
\newcommand\reflibrary[1]{\hyperref[sec:library-#1]{\texttt{#1}}}

\index[not print,not index,set={
  index key=unknown,
  form={\textbf{unknown!!}},
  for first={format={
      result/.expanded=\noexpand\textbf{\forestregister{result}??},
      print in color}}}
  ]>{@unknown}

\indexset
  [print form={},for first={format=pgfkey}]
  >{node key}

\indexset
  [for first={format={+result={/tikz/},pgfkey}}]
  >{tikz key}

\indexset
  [for first={format=pgfkey}]
  >{option,readonly option,bracket key,nodewalk key,register,propagator,style,nodewalk style,stage,dynamic tree,step,loop,conditional,anchor,package option}
 
  %%% begin listing region: index_macro_category
\indexset
  [for first={format=macro}]
  >{macro}
  %%% end listing region: index_macro_category

\indexset
  [for first={format=environment}]
  >{environment}

\indexset
  [format=empty]>{empty}

\indexset
  [index form={type (of options and registers)},for first={format=meta}]
  >{type}

\indexset
  [for first={format=handler}]
  >{handler}

\indexset
  [format={aggregate function},for first={format=handler}]
  >{aggregate}

\indexset
  [form={\texttt{pgfmath} function},for first={format={detokenize,pgfkey}}]
  >{pgfmath}

\indexset
  [for first={format=path}]
  >{path}

\indexset[
    form={},
    index key={},
    for first={
      for first={
        key+/.option=!parent.argument,
        index format={
          result+/.process={Ow1} {!parent.argument} {\protect\meta{##1 option}},
        },
        print format={
          if argument={}{}{
            result+/.option=argument
          },
        },
        format={
          pgfkey
        },
      }
    }
  ]>{prefix}

\indexset[
    form={},
    index key={},
    for first={
      for first={
        +key/.option=!parent.argument,
        index format={
          +result/.process={Ow1} {!parent.argument} {\protect\meta{##1 option}},
        },
        print format={
          if argument={}{}{
            +result/.option=argument
          },
        },
        format={
          pgfkey
        },
      }
    }
  ]>{suffix}
  
\indexset[
    form={},
    index key={},
    for first={
      for first={
        key/.process={OOw2} {key} {!parent,parent.argument} {##1 ##2},
        index format={
          result+/.process={Ow1} {!parent,parent.argument} {\space\protect\meta{##1}},
        },
        print format={
          if argument={}{}{
            result+={\space},
            result+/.option=argument
          }
        },
        format={
          pgfkey
        },
      }
    }
  ]>{word prefix}

\indexset[
    form={},
    index key={},
    for first={
      for first={
        key/.process={OOw2} {key} {!parent,parent.argument} {##2 ##1},
        index format={
          +result/.process={Ow1} {!parent,parent.argument} {\protect\meta{##1}\space},
        },
        print format={
          if argument={}{}{
            +result={\space},
            +result/.option=argument
          }
        },
        format={
          pgfkey
        },
      }
    }
  ]>{word suffix}
  
\indexset[%option values
  index key format={result/.expanded=\forestoption{argument} value},
  format={result/.expanded=\noexpand\texttt{\forestoption{argument}} value},
  for first={format=pgfkey}
  ]>{value of} 

\indexset[
  index key format={result/.expanded=\forestoption{argument} option},
  format={result/.expanded=\noexpand\texttt{\forestoption{argument}} option},
  for first={format=pgfkey}
  ]>{option of}
  
\indexset
  [form={},for first={
    print format={if argument={}{}{
        result+={:\ },
        result+/.option=argument,
      }},
    format=meta,
  }]>{meta}

\indexset[
    for first={+key={{cs }},format={pgfkey}}
  ]>{forest cs}

\indexset[
    for first={+key={{ss }},format={pgfkey}}
  ]>{short step}

\indexset
  [for first={format=pgfkey}]
  >{named nodewalk}

\indexset[
  format={result/.expanded=\noexpand\texttt{process instruction}},
  for first={format=pgfkey}
  ]>{processor}
  
{\makeatletter % an dirty patch: \lst@nolig can sneak in the name...
\gdef\myexampleindex#1{{\def\lst@nolig{}\lstaspectindex{#1}{}}}
}
\lstset{indexstyle={[1]\myexampleindex}}
%%% end lst-related stuff

\EnableCrossrefs         
\setlength\hfuzz{15pt}  % dont make so many
\hbadness=7000          % over and under full box warnings

\usetikzlibrary{intersections}
\tikzset{>=latex}
\forestset{
  background tree/.style={
    for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}}}
}

\title{\FoRest;: a \PGF;/\TikZ;-based package for drawing linguistic trees\\\normalsize\forestversion}
\author{Sa\v so \v Zivanovi\'c\footnote{e-mail:
    \href{mailto:saso.zivanovic@guest.arnes.si}{saso.zivanovic@guest.arnes.si};
    web:
    \href{http://spj.ff.uni-lj.si/zivanovic/}{http://spj.ff.uni-lj.si/zivanovic/}}}

%\usepackage[verbose]{trace-pgfkeys} % silent, stack, trace, verbose
%\pgfkeystracelevel{trace}

\begin{document}

\typeout{)}% hacking auctex's error finding routing

% short verbatim: | (changes spaces into _)
\DeleteShortVerb\|
\def\indexpipe{|}
{\catcode`\_=12 \def\marshal{%
\lstMakeShortInline[basicstyle=\ttfamily,literate={_}{ }1 {__}{_}1]}%
\expandafter}\marshal |

\IfFileExists{forest-doc-test.tex}{%
  \input forest-doc-test\relax
}{}

\newbox\treebox
\newbox\codebox

{\settodayfromforestdate\maketitle}

\begin{abstract}
\FoRest; is a \PGF;/\TikZ;-based package for drawing linguistic (and
other kinds of) trees.  Its main features are 
\begin{enumerate*}[(i)]
\item a packing algorithm which can produce very compact trees;
\item a user-friendly interface consisting of the familiar bracket encoding of trees plus the
  key--value interface to option-setting;
\item many tree-formatting options, with control over option values of individual nodes and
  mechanisms for their manipulation;
\item a powerful mechanism for traversing the tree;
\item the possibility to decorate the tree using the full power of \PGF;/\TikZ;;
\item an externalization mechanism sensitive to code-changes.
\end{enumerate*}
\end{abstract}

\vspace{1cm}

\begin{forestexample}[basicstyle=\ttfamily\scriptsize,layout=tree on top,no label,v sep=1cm,index={content,pgfmath,conditional>if,repeat,append,before drawing tree,y,alias,for step,step>children,edge,before typesetting nodes,tree,s sep,dimen+,option>l,ancestors,typeset node,nodewalk,readonly option>level,sort by,step>min}]
  \pgfmathsetseed{14285}
  \begin{forest}
    random tree/.style n args={3}{% #1 = max levels, #2 = max children, #3 = max content
      content/.pgfmath={random(0,#3)},
      if={#1>0}{repeat={random(0,#2)}{append={[,random tree={#1-1}{#2}{#3}]}}}{}},
    before typesetting nodes={for tree={draw,s sep=2pt,rotate={int(30*rand)},l+={5*rand},
                                        if={isodd(level())}{fill=green}{fill=yellow}}},
    important/.style={draw=red,line width=1.5pt,edge={red,line width=1.5pt}},
    before drawing tree={sort by=y, for nodewalk={min=tree,ancestors}{important,typeset node}}
    [,random tree={9}{3}{100}]
  \end{forest}
 \end{forestexample}%
 \begin{center}\mbox{}\box\treebox\\\box\codebox\end{center}

\newpage
{%
  \parskip 0pt
  \begin{multicols}{2}
    \tableofcontents
  \end{multicols}
}

\newpage

\section{Introduction}

Over several years, I had been a grateful user of various packages
for typesetting linguistic trees.  My main experience was with
|qtree| and |synttree|, but as far as I can tell, all of the tools
on the market had the same problem: sometimes, the trees were just
too wide.  They looked something like the tree on the left,
while I wanted something like the tree on the right.
\begin{center}
  \begin{forest}
    baseline,
    for tree={parent anchor=south,child anchor=north,l=7ex,s sep=10pt},
    for children={fit=rectangle}
    [CP
      [DP
        [D][NP[N][CP[C][TP[T][vP[v][VP[DP][V'[V][DP]]]]]]]]
      [TP
        [T][vP[v][VP[DP][V'[V][DP]]]]]
    ]
  \end{forest}
  \hfill
  \begin{forest}
    baseline,
    for tree={parent anchor=south,child anchor=north,l=7ex,s sep=10pt},
    [CP
      [DP
        [D][NP[N][CP[C][TP[T][vP[v][VP[DP][V'[V][DP]]]]]]]]
      [TP
        [T][vP[v][VP[DP][V'[V][DP]]]]]
    ]
  \end{forest}
\end{center}

Luckily, it was possible to tweak some parameters by hand to get a
narrower tree, but as I quite dislike constant manual adjustments, I
eventually started to develop \foRest;.  It started out as
|xyforest|, but lost the |xy| prefix as I became increasingly fond
of \PGF;/\TikZ;, which offered not only a drawing package but also a
`programming paradigm.'  It is due to the awesome power of the
supplementary facilities of \PGF;/\TikZ; that \foRest; is now, I
believe, the most flexible tree typesetting package for \LaTeX\ you can get. 

The latest stable version of \FoRest; is \href{http://www.ctan.org/pkg/forest}{available at CTAN}.
Development version(s) can be found \href{https://github.com/sasozivanovic/forest}{at GitHub}.
Comments, criticism, suggestions and code are all very welcome!  If you find the package useful, you
can show your appreciation by making a PayPal donation to \url{saso.zivanovic@guest.arnes.si}.


\section{Tutorial}
\label{sec:tutorial}

This short tutorial progresses from basic through useful to obscure \dots fortunately, it is not the
only newcomer's source of information on \foRest;: check out
\href{http://mirrors.ctan.org/info/forest-quickstart/ForestQuickstart.pdf}{Forest Quickstart Guide
  for Linguists}. Another very useful source of information (and help!) about \foRest; and \TeX\ in
general is \href{http://tex.stackexchange.com}{\TeX\ StackExchange}.  Check out the questions tagged
\href{http://tex.stackexchange.com/questions/tagged/forest}{\texttt{forest}}!


\subsection{Basic usage}
\label{tut:basic-usage}

A tree is input by enclosing its specification in a \index{forest}
environment.  The tree is encoded by \emph{the bracket syntax}:
every node is enclosed in square brackets; the children of a
node are given within its brackets, after its content.
{\lstdefinelanguage[my]{TeX}[LaTeX]{TeX}{keywords=forest,
  otherkeywords={[,]},keywordstyle=\pstyle,texcsstyle={}}%
\lstset{language={[my]TeX}}%
\begin{forestexample}
  \begin{forest}
    [VP
      [DP]
      [V'
        [V]
        [DP]
      ]
    ]
  \end{forest}
\end{forestexample}}
Binary trees are nice, but not the only thing this package can draw.
Note that by default, the children are vertically centered with
respect to their parent, i.e.\ the parent is vertically aligned with the midpoint between the
first and the last child.
\begin{forestexample}
  \begin{forest}
    [VP
      [DP[John]]
      [V'
        [V[sent]]
        [DP[Mary]]
        [DP[D[a]][NP[letter]]]
      ]
    ]
  \end{forest}
\end{forestexample}
Spaces around brackets are ignored --- format your code as you
desire!
\begin{forestexample}
  \begin{forest}
    [VP[DP][V'[V][DP]]]
  \end{forest}
  \quad
  \begin{forest}[VP
    [DP ] [ V'[V][ DP]]
    ]\end{forest}
\end{forestexample}
If you need a square bracket as part of a node's content, use
braces.  The same is true for the other characters which have a
special meaning in the \foRest; package, like comma
|,| and equality sign |=|.
\begin{forestexample}
  \begin{forest}
    [V{P,}
      [{[DP]}]
      [V'
        [V]
        [{===DP===}]]]
  \end{forest}
\end{forestexample}
Macros in a node specification will be expanded when the node is
drawn --- you can freely use formatting commands inside nodes!
\begin{forestexample}
  \begin{forest}
    [VP
      [{~\textbf~{DP}}]
      [V'
        [V]
        [DP]]]
  \end{forest}
\end{forestexample}

All the examples given above produced top-down trees with centered children.  The other sections
of this manual explain how various properties of a tree can be changed, making it possible to
typeset radically different-looking trees.  However, you don't have to learn everything about this
package to profit from its power.  Using styles, you can draw predefined types of trees with ease.
For example, a phonologist can use the \index{GP1} style from library \reflibrary{linguistics} to easily
typeset (Government Phonology) phonological representations.  The style is applied simply by
writing its name before the first (opening) bracket of the tree.
\begin{forestexample}[label=ex:gp1-frost,code prefix={\def\usepackage[##1]##2{}}]
  \usepackage[~linguistics~]{forest}
  % ...
  \begin{forest} ~GP1~ [
    [O[x[f]][x[r]]]
    [R[N[x[o]]][x[s]]]
    [O[x[t]]]
    [R[N[x]]]
  ]\end{forest}
\end{forestexample}
Of course, someone needs to develop the style --- you, me, your local \TeX nician \dots\@
Fortunately, designing styles is not very difficult once you get the hang of \foRest;, if you
write one, please contribute!  Some macros relating to various fields are collected in
\emph{libraries} that are distributed alongside the main package.  This is the case for the
\index{GP1} style used above, which is defined in the |linguistics| library.  The simplest way to
load a library is as shown in the example, by loading the package with an optional argument.  For
more information on loading libraries, see \S\ref{ref:package-options}.


\subsection{Options}
\label{tut:options}

A node can be given various options, which control various
properties of the node and the tree.  For example, at the end of
section~\ref{tut:basic-usage}, we have seen that the \index{GP1} style
vertically aligns the parent with the first
child.  This is achieved by setting option \index{calign} (for
\emph{c}hild-\emph{align}ment) to \index{value of=calign>first} (child).

Let's try.  Options are given inside the brackets, following the
content, but separated from it by a comma.  (If multiple options are
given, they are also separated by commas.)  A single option
assignment takes the form \meta{option name}|=|\meta{option value}.  (There are
also options which do not require a value or have a default value:
these are given simply as \meta{option name}.)
\begin{forestexample}[label=ex:numerals-simple,index={calign,value of=align>first}]
  \begin{forest}
    [\LaTeX\ numerals, ~calign=first~
      [arabic[1][2][3][4]]
      [roman[i][ii][iii][iv]]
      [alph[a][b][c][d]]
    ]
  \end{forest}
\end{forestexample}

The experiment has succeeded only partially.  The root node's
children are aligned as desired (so \index{calign}|=|\index{value of=calign>first} applied to the
root node), but the value of the \index{calign} option didn't get
automatically assigned to the root's children! \emph{An option given
at some node applies only to that node.} In \foRest;, the options
are passed to the node's relatives via special keys, called
\emph{propagators}.  What we need above is the \index{for step=\index{tree}}
propagator.  Observe:

\begin{forestexample}[label=ex:numerals-manual]
  \begin{forest}
    [\LaTeX\ numerals,
         ~for tree~={calign=first}
      [arabic[1][2][3][4]]
      [roman[i][ii][iii][iv]]
      [alph[a][b][c][d]]
    ]
  \end{forest}
\end{forestexample}
The value of propagator \index{for step=\index{tree}} is a list of keys that we
want to process.  This keylist is propagated to all the nodes in
the subtree\footnote{It might be more precise to call \index{for step=\index{tree}}
\texttt{for subtree} \dots\@ but this name at least saves some typing.}
rooted in the current node (i.e.\ the node where \index{for step=\index{tree}} was
given), including the node itself.  (Propagator \index{for step=\index{descendants}} is
just like \index{for step=\index{tree}}, only that it excludes the node itself.  There
are many other \index{for step=\meta{step}} propagators; for the complete list, see
sections~\ref{ref:spatial-propagators} and \ref{ref:nodewalks}.)

Some other useful options are \index{option>parent anchor}, \index{option>child anchor} and
\index{tier}.  The \index{option>parent anchor} and \index{option>child anchor} options tell
where the parent's and child's endpoint of the edge between them should be, respectively: usually,
the value is either empty (meaning a smartly determined border point
\citep[see][\S16.11]{tikzpgf2.10}; this is the default) or a compass direction
\citep[see][\S16.5.1]{tikzpgf2.10}.  (Note: the \index{option>parent anchor} determines where the edge
from the child will arrive to this node, not where the node's edge to its parent will start!)

Option \index{tier} is what makes the
skeletal points $\times$ in example (\ref{ex:gp1-frost}) align horizontally although they
occur at different levels in the logical structure of the tree.
Using option \index{tier} is very simple: just set |tier=tier_name| at
all the nodes that you want to align horizontally.  Any tier name
will do, as long as the tier names of different tiers are
different \dots\@ (Yes, you can have multiple tiers!)
\begin{forestexample}[point={tier},index={option>parent anchor,option>child anchor,tier},label=ex:tier-manual]
  \begin{forest} 
    [VP, for tree={~parent anchor~=south, ~child anchor~=north}
      [DP[John,tier=word]]
      [V'
        [V[sent,tier=word]]
        [DP[Mary,tier=word]]
        [DP[D[a,tier=word]][NP[letter,tier=word]]]
      ]
    ]
  \end{forest}
\end{forestexample}
Before discussing the variety of \foRest;'s options, it is worth
mentioning that \foRest;'s node accepts all options \citep[see
\S16]{tikzpgf2.10} that \TikZ;'s node does --- mostly, it just passes
them on to \TikZ;.  For example, you can easily encircle a node like
this:\footnote{If option \texttt{draw} was not given, the shape of the node
would still be circular, but the edge would not be drawn.  For
details, see \cite[\S16]{tikzpgf2.10}.}
\begin{forestexample}
  \begin{forest}
    [VP,~circle~,~draw~
      [DP][V'[V][DP]]
    ]
  \end{forest}
\end{forestexample}

Let's have another look at example (\ref{ex:gp1-frost}).  You will note that the skeletal
positions were input by typing |x|s, while the result looks like
this: $\times$ (input as |\times| in math mode). Obviously, the
content of the node can be changed.  Even more, it can be
manipulated: added to, doubled, boldened, emphasized, etc.  We will
demonstrate this by making example (\ref{ex:numerals-manual}) a bit
fancier: we'll write the input in the arabic numbers and have
\LaTeX\ convert it to the other formats.  We'll start with the
easiest case of roman numerals: to get them, we can use the (plain)
\TeX\ command |\romannumeral|.  To change the content of the node,
we use option \index{content}.  When specifying its new value, we can use
|#1| to insert the current content.\footnote{This mechanism is called
  \emph{wrapping}. By default, \index{content} is the only \index{autowrapped toks} option,
  i.e.\ option where wrapping works implicitely (simply
because I assume that wrapping will be almost exclusively used with this option).  To wrap values
of other options, use handler \index{wrap value}; see~\S\ref{ref:handlers}.}
\begin{forestexample}[point={content,delay},index={for step,step>children,content,delay},label=ex:romannumeral]
  \begin{forest}
    [roman, delay={for children={content=\romannumeral#1}}
      [1][2][3][4]
    ]
  \end{forest}
\end{forestexample}
This example introduces another option: \index{delay}.  Without it, the example wouldn't work: we
would get arabic numerals.  This is so because of the order in which the options are processed.
First, the processing proceeds through the tree in a depth-first, parent-first fashion (first the
parent is processed, and then its children, recursively; but see \index{processing order}).  Next,
the option string of a node is processed linearly, in the order they were given.  Option
\index{content} is specified implicitely and is always the first.  If a propagator is encountered,
the options given as its value are propagated \emph{immediately}.  The net effect is that if the
above example contained simply |roman,for_children={content=...}|, the \index{content} option
given there would be processed \emph{before} the implicit content options given to the children
(i.e.\ numbers |1|, |2|, |3| and |4|).  Thus, there would be nothing for the |\romannumeral| to
change --- it would actually crash; more generally, the content assigned in such a way would get
overridden by the implicit content.  Key \index{delay} is true to its name.  It delays the
processing of the keylist given as its argument until the whole tree was processed.  In other words, it
introduces cyclical option processing.  Whatever is delayed in one cycle, gets processed in the next
one.  The number of cycles is not limited --- you can nest \index{delay}s as deep as you need.

Unlike \index{for step=\meta{step}} keys we have met before, \index{delay} is not a
spatial, but a temporal propagator.  Several other temporal propagators options exist, see
\S\ref{ref:stages}.

We are now ready to learn about simple conditionals.\footnote{See \S\ref{ref:conditionals} for
  further information on conditionals, including the generic \index{if} and \index{where}.} Every
node option has the corresponding \index{if option=\meta{option}} and \index{where
  option=\meta{option}} keys.  \index{if option=\meta{option}}|=|\meta{value}\meta{true
  options}\meta{false options} checks whether the value of \meta{option} equals \meta{value}.  If
so, \meta{true options} are processed, otherwise \meta{false options}.  The \index{where
  option=\meta{option}} keys are the same, but do this for the every node in the subtree; informally
speaking, |where| = |for_tree| + |if|.  To see this in action, consider the rewrite of the
\index{tier} example (\ref{ex:tier-manual}) from above.  We don't set the tiers manually, but rather
put the terminal nodes (option \index{n children} is a read-only option containing the number of
children) on tier \keyname{word}.\footnote{We could omit the braces around \texttt{0} because it is
  a single character. If we were hunting for nodes with 42 children, we'd have to write
  \texttt{where n children=\{42\}...}.}
\begin{forestexample}[index={tier,where option,n children}]
  \begin{forest}
    ~where n children~=0{tier=word}{}
    [VP
      [DP[John]]
      [V'
        [V[sent]]
        [DP[Mary]]
        [DP[D[a]][NP[letter]]]
      ]
    ]
  \end{forest}
\end{forestexample}

\begin{advise}
\item Note that you usually don't want to embed a \index{where option=...} conditional in a \index{for
    step=\index{tree}}, as this will lead to a multiple traversal of many nodes, resulting in a
  slower execution.  If you're inside a \index{for step=\index{tree}}, you probably want to use
  \index{if}.
\end{advise}


Finally, let's talk about styles.
(They are not actually defined in the \foRest; package, but rather
inherited from |pgfkeys|.)




At the first approximation, styles are abbreviations: if you
often want to have non-default parent/child anchors, say south/north as in example
(\ref{ex:tier-manual}), you could save some typing by defining a style.  Styles are defined using
\PGF;'s handler |.style|, like shown below.\footnote{Style \index{sn edges} is actually already
  defined by library \reflibrary{linguistics}. The definition there is a bit more generic.}
\begin{forestexample}[index={tier,option>parent anchor,option>child anchor}]
  \begin{forest}
    ~sn edges~/~.style~={for tree={
            parent anchor=south, child anchor=north}},
    ~sn edges~
    [VP, 
      [DP[John,tier=word]]
      [V'
        [V[sent,tier=word]]
        [DP[Mary,tier=word]]
        [DP[D[a,tier=word]][NP[letter,tier=word]]]]]
  \end{forest}
\end{forestexample}
If you want to use a style in more than one tree, you have to define it outside the \index{forest}
environment.  Use macro \index{forestset} to do this.
\begin{lstlisting}
  ~\forestset~{
    sn edges/.style={for tree={parent anchor=south, child anchor=north}},
    background tree/.style={for tree={
                text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}}}
  }
\end{lstlisting}

You might have noticed that in the last two examples, some keys occurred even before the
first opening bracket, contradicting was said at the beginning of this section.  This is mainly
just syntactic sugar (it can separate the design and the content): such \emph{preamble}
keys behave as if they were given in the root node, the only difference (which often does not
matter) being that they get processed before all other root node options, even the implicit
\index{content}.

If you find yourself writing the same preamble for every tree in your document,
consider modifying \index{default preamble}, which is implicitely included at the beginning
of every preamble.

\begin{forestexample}[index={default preamble}]
  \forestset{
    ~default preamble~={
      font=\Huge,
      for tree={circle,draw}
    }
  }
  \begin{forest}                   [A[B][C]] \end{forest}
  \begin{forest} red               [D[E][F]] \end{forest}
  \begin{forest} for tree={dotted} [G[H][I]] \end{forest}
\end{forestexample}

\subsection{Decorating the tree}
\label{tut:decorating}

The tree can be decorated (think movement arrows) with arbitrary
\TikZ; code.
\begin{forestexample}
  \begin{forest}
    [XP
      [specifier]
      [X$'$
        [X$^0$]
        [complement]
      ]
    ]
    ~\node at (current bounding box.south)
      [below=1ex,draw,cloud,aspect=6,cloud puffs=30]
      {\emph{Figure 1: The X' template}};~
  \end{forest}
\end{forestexample}

However, decorating the tree would make little sense if one could
not refer to the nodes.  The simplest way to do so is to give them a
\TikZ; name using the \index{option>name} option, and then use this name in \TikZ;
code as any other (\TikZ;) node name.
\begin{forestexample}[point=name,index={option>phantom,option>name}]
  \begin{forest}
    [CP
      [DP,name=spec CP]
      [\dots
        [,phantom]
        [VP
          [DP]
          [V'
            [V]
            [DP,name=object]]]]]
    \draw[->,dotted] ~(object)~ to[out=south west,in=south] ~(spec CP)~;
  \end{forest}
\end{forestexample}

It gets better than this, however! In the previous examples, we put
the \TikZ; code after the tree specification, i.e.\ after the closing
bracket of the root node.  In fact, you can put \TikZ; code after
\emph{any} closing bracket, and \foRest; will know what the current
node is. (Putting the code after a node's bracket is actually just a
special way to provide a value for option \index{tikz} of that node.)  To
refer to the current node, simply use an empty node name.  This works both with and without
anchors \citep[see][\S16.11]{tikzpgf2.10}: below, |(.south east)| and |()|. 
\begin{forestexample}[index={option>phantom,option>name}]
  \begin{forest}
    [CP
      [DP,name=spec CP]
      [\dots
        [,phantom]
        [VP
          [DP]
          [V'
            [V]
            [DP,draw] ~{~
              \draw[->,dotted] ~()~ to[out=south west,in=south] (spec CP);
              \draw[<-,red] ~(.south east)~--++(0em,-4ex)--++(-2em,0pt)
                   node[anchor=east,align=center]{This guy\\has moved!};
                 ~}~
          ]]]]
  \end{forest}
\end{forestexample}

Important: \emph{the \TikZ; code should usually be enclosed in braces} to hide
it from the bracket parser.  You don't want all the bracketed code
(e.g.\ |[->,dotted]|) to become tree nodes, right? (Well, they
probably wouldn't anyway, because \TeX\ would spit out a thousand
errors.)

\bigskip

Finally, the most powerful tool in the node reference toolbox:
\emph{relative nodes}.  It is possible to refer to other nodes which stand
in some (most often geometrical) relation to the current node.  To
do this, follow the node's name with a \index>{!} and a \emph{nodewalk}
specification.

A nodewalk is a concise\footnote{Actually, \foRest; distinguishes two kinds of steps in node walks:
  long-form and short-form steps.  This section introduces only short-form steps.  See
  \S\ref{ref:nodewalks}.} way of expressing node relations.  It is simply a string of steps, which
are represented by single characters, where: \index{ss u} stands for the parent node (up); \index{ss
  p} for the previous sibling; \index{ss n} for the next sibling; \index{ss s} for \emph{the}
sibling (useful only in binary trees); \index{ss 1}, \index{ss 2}, \index[not print]{ss 3,ss 4,ss
  5,ss 6,ss 7,ss 8}\dots\ \index{ss 9} for first, second, \dots\ ninth child; \index{ss l}, for the
last child, etc.  For the complete specification, see section~\ref{ref:short-form-steps}.

To see the nodewalk in action, consider the following examples.
In the first example, the agree arrow connects the V node, specified
simply as |()|, since the \TikZ; code follows |[V]|, and the DP node,
which is described as ``a sister of V's parent'': |!us| = up +
sibling. 
\begin{forestexample}[index>={!}]
  \begin{forest}
    [VP
      [DP] 
      [V'
        [V] {\draw[<->] ~()~
             .. controls +(left:1cm) and +(south west:0.4cm) ..
             node[very near start,below,sloped]{\tiny agree}
             ~(!us)~;}
        [DP]
      ]
    ]
  \end{forest}
\end{forestexample}

\begingroup
\footnotesize
\begin{forestexample}[index={option>phantom,tikz,fit to,tree},layout=export,basicstyle=\footnotesize\ttfamily]
  \begin{forest}
    [CP
      [DP$_1$]
      [\dots
        [,phantom]
        [VP,tikz={\node [draw,red,inner sep=0,~fit to~=tree]{};}
          [DP$_2$] 
          [V'
            [V]
            [DP$_3$]
    ]]]]
  \end{forest}
\end{forestexample}%
\endgroup

The second example uses \TikZ;'s fitting library (automatically loaded by \foRest;) to compute the
smallest rectangle containing node VP, its first child (DP$_2$) and its last grandchild (DP$_3$).
The example also illustrates that the \TikZ; code 
can be specified via the ``normal'' option syntax, i.e.\ as a value
to option \index{tikz}.\footnote{\label{fn:fit-to-tree}Actually, there's a simpler way to do this: use \index{fit to}\keyname{=}\index{tree}!\forestexampleimport}
\begin{forestexample}[point=tikz,index={option>phantom,tikz},index>={!}]
  \begin{forest}
    [CP
      [DP$_1$]
      [\dots
        [,phantom]
        [VP,tikz={\node [draw,red,fit=~()(!1)(!ll)~] {};}
          [DP$_2$] 
          [V'
            [V]
            [DP$_3$]
    ]]]]
  \end{forest}
\end{forestexample}


\subsection{Node positioning}
\label{tut:node-positioning}

\FoRest; positions the nodes by a recursive bottom-up algorithm which, for every non-terminal node,
computes the positions of the node's children relative to their parent.  By default, all the
children will be aligned horizontally some distance down from their parent: the ``normal'' tree
grows down.  More generally, however, the direction of growth can change from node to node; this is
controlled by option \index{grow}=\meta{direction}.\footnote{The direction can be specified either in
  degrees (following the standard mathematical convention that $0$ degrees is to the right, and that
  degrees increase counter-clockwise) or by the compass directions: \texttt{east}, \texttt{north east},
  \texttt{north}, etc.}  The system computes and stores the positions of children using a
coordinate system dependent on the parent, called an \emph{ls-coordinate system}: the origin is the
parent's anchor; l-axis is in the direction of growth in the parent; s-axis is orthogonal to the
l-axis (positive side in the counter-clockwise direction from $l$-axis); l stands for \emph{l}evel,
s for \emph{s}ibling.  The example shows the ls-coordinate system for a node with
|grow=45|.\footnote{The axes are drawn using coordinates given in \texttt{forest cs} coordinate
  system; the ``manually'' given polar coordinate equivalent is shown in the comment.}

\begin{forestexample}[point=grow,index={grow}]
  \begin{forest} background tree
    [parent, grow=45
      [child 1][child 2][child 3][child 4][child 5]
    ]
    %\draw[,->](-135:1cm)--(45:3cm) node[below]{$l$};
    \draw[,->](forest cs:l=-1cm,s=0)--(forest cs:l=3cm,s=0) node[below]{$l$};
    %\draw[,->](-45:1cm)--(135:3cm) node[right]{$s$};
    \draw[,->](forest cs:s=-1cm,l=0)--(forest cs:s=3cm,l=0) node[right]{$s$};
  \end{forest}
\end{forestexample}

\begin{forestexample}[basicstyle=\scriptsize\ttfamily,layout=export]
  \newcommand\measurexdistance[5][####1]{\measurexorydistance{#2}{#3}{#4}{#5}{\x}{-|}{(5pt,0)}{#1}}
  \newcommand\measureydistance[5][####1]{\measurexorydistance{#2}{#3}{#4}{#5}{\y}{|-}{(0,5pt)}{#1}}
  \tikzset{dimension/.style={<->,>=latex,thin,every rectangle node/.style={midway,font=\scriptsize}},
    guideline/.style=dotted}
  \newdimen\absmd
  \def\measurexorydistance#1#2#3#4#5#6#7#8{%
    \path #1 #3 #6 coordinate(md1) #1; \draw[guideline] #1 --  (md1);
    \path (md1) #6 coordinate(md2) #2; \draw[guideline] #2 -- (md2);
    \path let \p1=($(md1)-(md2)$), \n1={abs(#51)} in \pgfextra{\xdef\md{#51}\global\absmd=\n1\relax};
    \def\distancelabelwrapper##1{#8}%
    \ifdim\absmd>5mm
      \draw[dimension] (md1)--(md2) node[#4]{\distancelabelwrapper{\uselengthunit{mm}\rndprintlength\absmd}};
    \else
      \ifdim\md>0pt
        \draw[dimension,<-] (md1)--+#7; \draw[dimension,<-] let \p1=($(0,0)-#7$) in (md2)--+(\p1);
      \else
        \draw[dimension,<-] let \p1=($(0,0)-#7$) in (md1)--+(\p1); \draw[dimension,<-] (md2)--+#7;
      \fi
      \draw[dimension,-] (md1)--(md2) node[#4]{\distancelabelwrapper{\uselengthunit{mm}\rndprintlength\absmd}};
    \fi}
\end{forestexample}
\input{\jobname.tmp}


The l-coordinate of children is (almost) completely under your control, i.e.\ you set what is often
called the level distance by yourself.  Simply set option \index{option>l} to change the distance of
a node from its parent.\footnote{If setting \index{option>l} seems to have no effect, read about
  \index{l sep} further down this section.}  More precisely, \index{option>l}, and the related option
\index{option>s}, control the distance between the (node) anchors of a node and its parent.  The
anchor of a node can be changed using option \index{option>anchor}: by default, nodes are anchored
at their base; see \cite[\S16.5.1]{tikzpgf2.10}.)  In the example below, positions of the anchors
are shown by dots: observe that anchors of nodes with the same \index{option>l} are aligned and that
the distances between the anchors of the children and the parent are as specified in the
code.\footnote{Here are the definitons of the macros for measuring distances.  Args: the x or y
  distance between points \#2 and \#3 is measured; \#4 is where the distance line starts (given as
  an absolute coordinate or an offset to \#2); \#5 are node options; the optional arg \#1 is the
  format of label. (Lengths are printed using package \texttt{printlen}.)

\box\codebox}
\begin{forestexample}[layout=tree on top,index={for step,tree,tikz,option>l,option>anchor},index>={!}]
  \begin{forest} background tree,
    for tree={draw,tikz={\fill[](.anchor)circle[radius=1pt];}}
    [parent
      [child 1, ~l~=10mm, ~anchor~=north west]
      [child 2, ~l~=10mm, ~anchor~=south west]
      [child 3, ~l~=12mm, ~anchor~=south]
      [child 4, ~l~=12mm, ~anchor~=base east]
    ]
    \measureydistance[\texttt{l(child)}=#1]{(!2.anchor)}{(.anchor)}{(!1.anchor)+(-5mm,0)}{left}
    \measureydistance[\texttt{l(child)}=#1]{(!3.anchor)}{(.anchor)}{(!4.anchor)+(5mm,0)}{right}
    \measurexdistance[\texttt{s sep(parent)}=#1]{(!1.south east)}{(!2.south west)}{+(0,-5mm)}{below}
    \measurexdistance[\texttt{s sep(parent)}=#1]{(!2.south east)}{(!3.south west)}{+(0,-5mm)}{below}
    \measurexdistance[\texttt{s sep(parent)}=#1]{(!3.south east)}{(!4.south west)}{+(0,-8mm)}{below}
  \end{forest}
\end{forestexample}

Positioning the chilren in the s-dimension is the job and \emph{raison d'etre} of the package.  As a
first approximation: the children are positioned so that the distance between them is at least the
value of option \index{s sep} (s-separation), which defaults to double \PGF;'s |inner_xsep| (and this
is 0.3333em by default).  As you can see from the example above, s-separation is the distance
between the borders of the nodes, not their anchors!

A fuller story is that \index{s sep} does not control the s-distance between two siblings, but rather
the distance between the subtrees rooted in the siblings.  When the green and the yellow child of
the white node are s-positioned in the example below, the horizontal
distance between the green and the yellow subtree is computed.  It can be seen with the naked eye
that the closest nodes of the subtrees are the TP and the DP with a red border.  Thus, the children
of the root CP (top green DP and top yellow TP) are positioned so that the horizontal distance
between the red-bordered TP and DP equals \index{s sep}.
\begin{forestexample}[index={for step,tree,s sep}]
  \begin{forest}
    important/.style={name=#1,draw={red,thick}}
    [CP, ~s sep~=3mm, for tree=draw
      [DP, for tree={fill=green}
        [D][NP[N][CP[C][TP,important=left
        [T][vP[v][VP[DP][V'[V][DP]]]]]]]]
      [TP,for tree={fill=yellow}
        [T][vP[v][VP[DP,important=right][V'[V][DP]]]]]
    ]
    \measurexdistance[\texttt{s sep(root)}=#1]
      {(left.north east)}{(right.north west)}{(.north)+(0,3mm)}{above}
  \end{forest}
\end{forestexample}

Note that \foRest; computes the same distances between nodes
regardless of whether the nodes are filled or not, or whether their
border is drawn or not.  Filling the node or drawing its border does
not change its size.  You can change the size by adjusting \TikZ;'s
|inner_sep| and |outer_sep| \citep[\S16.2.2]{tikzpgf2.10}, as shown
below:
\begin{forestexample}[index={for step,tree,s sep}]
  \begin{forest}
    important/.style={name=#1,draw={red,thick}}
    [CP, s sep=3mm, for tree=draw
      [DP, for tree={fill=green,~inner sep~=0}
        [D][NP,important=left[N][CP[C][TP[T][vP[v]
        [VP[DP][V'[V][DP]]]]]]]]
      [TP,for tree={fill=yellow,~outer sep~=2pt}
        [T,important=right][vP[v][VP[DP][V'[V][DP]]]]]
    ]
    \measurexdistance[\texttt{s sep(root)}=#1]
      {(left.north east)}{(right.north west)}{(.north)+(0,3mm)}{above}
  \end{forest}
\end{forestexample}
(This looks ugly!) Observe that having increased |outer sep| makes the edges stop touching
borders of the nodes. By (\PGF;'s) default, the |outer sep| is exactly half of the border
line width, so that the edges start and finish precisely at the border.

Let's play a bit and change the \index{option>l} of the root of the yellow subtree.  Below, we set the
vertical 
distance of the yellow TP to its parent to 3\,cm: and the yellow submarine sinks diagonally \dots\@
Now, the closest nodes are the higher yellow DP and the green VP.
\begin{forestexample}[index={option>l,s sep,for step,tree}]
  \begin{forest}
    important/.style={name=#1,draw={red,thick}}
    [CP, s sep=3mm, for tree=draw
      [DP, for tree={fill=green}
        [D][NP[N][CP[C][TP
        [T][vP[v][VP,important=left[DP][V'[V][DP]]]]]]]]
      [TP,for tree={fill=yellow}, l=3cm
        [T][vP[v][VP[DP,important=right][V'[V][DP]]]]]
    ]
    \measurexdistance[\texttt{s sep(root)}=#1]
      {(left.north east)}{(right.north west)}{(.north)+(0,3mm)}{above}
  \end{forest}
\end{forestexample}

Note that the yellow and green nodes are not vertically aligned anymore.  The positioning algorithm
has no problem with that.  But you, as a user, might have, so here's a neat trick.  (This only works
in the ``normal'' circumstances, which are easier to see than describe.)
\begin{forestexample}[label=ex:l*,index={dimen*=l,option>phantom,for step,tree}]
  \begin{forest}
    [CP, for tree=draw
      [DP, for tree={fill=green},~l*~=3
        [D][NP]]
      [TP,for tree={fill=yellow}
        [T][VP[DP][V'[V][DP]]]]
    ]
  \end{forest}
\end{forestexample}
We have changed DP's \index{option>l}'s value via ``augmented assignment'' known from
many programming languages: above, we have used |l*=3| to triple
\index{option>l}'s value; we could have also said |l+=5mm| or |l-=5mm| to
increase or decrease its value by 5\,mm, respectively.  This
mechanism works for every numeric and dimensional option in \foRest;.

Let's now play with option \index{s sep}.
\begin{forestexample}[index={s sep,option>l,dimen*=l,for step,tree}]
  \begin{forest}
    [CP, for tree=draw, ~s sep~=0
      [DP, for tree={fill=green},l*=3
        [D][NP]]
      [TP,for tree={fill=yellow}
        [T][VP[DP][V'[V][DP]]]]
    ]
  \end{forest}
\end{forestexample}
Surprised? You shouldn't be. The value of \index{s sep} at a given node controls the s-distance
\emph{between the subtrees rooted in the children of that node}!  It has no influence over the
internal geometry of these subtrees. In the above example, we have set |s_sep=0| only for the root
node, so the green and the yellow subtree are touching, although internally, their nodes are not.
Let's play a bit more.  In the following example, we set the \index{s sep} to: $0$ at the last
branching level (level 3; the root is level 0), to 2\,mm at level 2, to 4\,mm at level 1 and to
6\,mm at level 0.

\begin{forestexample}[label=ex:spread-s,point={level},index={readonly option>level,for step,tree,s sep},index>={!}]
  \begin{forest}
    for tree={~s sep~=(3-level)*2mm}
    [CP, for tree=draw
      [DP, for tree={fill=green},l*=3
        [D][NP]]
      [TP,for tree={fill=yellow}
        [T][VP[DP][V'[V][DP]]]]
    ]
    \measurexdistance{(!11.south east)}{(!12.south west)}{+(0,-5mm)}{below}
    \path(md2)-|coordinate(md)(!221.south east);
    \measurexdistance{(!221.south east)}{(!222.south west)}{(md)}{below}
    \measurexdistance{(!21.north east)}{(!22.north west)}{+(0,2cm)}{above}
    \measurexdistance{(!1.north east)}{(!221.north west)}{+(0,-2.4cm)}{below}
  \end{forest}
\end{forestexample}
As we go up the tree, the nodes ``spread.'' At the lowest level, V and DP are touching.  In the
third level, the \index{s sep} of level 2 applies, so DP and V' are 2\,mm apart.  At the second
level we 
have two pairs of nodes, D and NP, and T and TP: they are 4\,mm apart.  Finally, at level 1, the
\index{s sep} of level 0 applies, so the green and yellow DP are 6\,mm apart.  (Note that D and NP are
at level 2, not 4! Level is a matter of structure, not geometry.)

As you have probably noticed, this example also demostrated that we can compute the value of an
option using an (arbitrarily complex) formula.  This is thanks to \PGF;'s module |pgfmath|.
\FoRest; provides an interface to |pgfmath| by defining |pgfmath| functions for every node option,
and some other information, like the \index{readonly option>level} we have used above, the number of children
\index{n children}, the sequential number of the child \index{readonly option>n}, etc.  For details, see
\S\ref{ref:pgfmath}. 

The final separation parameter is \index{l sep}.  It determines the minimal
separation of a 
node from its descendants.  It the value of \index{option>l} is too small, then \emph{all} the
children (and thus their subtrees)
are pushed 
away from the parent (by increasing their \index{option>l}s), so that the distance between the node's
and each child's subtree
boundary is at least \index{l sep}.  The initial \index{option>l} can be too small for
two reasons: either 
some child is too high, or the parent is too deep.  The first problem is easier to see: we force the
situation using a bottom-aligned multiline node.  (Multiline nodes can be easily created using |\\|
as a line-separator.  However, you must first specify the horizontal alignment using option
\index{align} (see \S\ref{ref:node-appearance}). 
Bottom vertical alignment is achieved by setting \index{base}|=|\index{value of=base>bottom};
the default, unlike in \TikZ;, is \index{base}|=|\index{value of=base>top}). 
\begin{forestexample}[point={align,base},index={align,base}]
  \begin{forest}
    [parent
      [child]
      [child]
      [a very\\tall\\child, align=center, base=bottom]
    ]
  \end{forest}
\end{forestexample}

The defaults for \index{option>l} and \index{l sep} are set so that they ``cooperate.''
What this 
means and why it is necessary is a complex issue explained in \S\ref{tut:defaults}, which you will
hopefully never have to read \dots\@ You might be out of luck, however.  What if you 
needed to decrease the level distance? And nothing happened, like below on the left?  Or, what if
you used lots of parenthesis in your nodes?  And got a strange vertical misalignment, like below
on the right?  Then rest assured that these (at least) are features not bugs and read
\S\ref{tut:defaults}.
\begin{forestexample}[layout=tree on top,v sep=-55ex,code left skip=-3cm,label=ex:misalignments,index={option>phantom,for step,step>children,fit,baseline,edge,descendants,content,pgfmath,ss 1}]
  \begin{forest}
    [,phantom,for children={l sep=1ex,fit=band,
      for 1={edge'=,l=0},baseline}
      [{l+=5mm},for descendants/.pgfmath=content
        [AdjP[AdvP][Adj'[Adj][PP]]]]
      [default
        [AdjP[AdvP][Adj'[Adj][PP]]]]
      [{l-=5mm},for descendants/.pgfmath=content
        [AdjP[AdvP][Adj'[Adj][PP]]]]
    ]
    \path (current bounding box.west)|-coordinate(l1)(!212.base);
    \path (current bounding box.west)|-coordinate(l2)(!2121.base);
    \path (current bounding box.east)|-coordinate(r1)(!212.base);
    \path (current bounding box.east)|-coordinate(r2)(!2121.base);
    \draw[dotted] (l1)--(r1) (l2)--(r2);
  \end{forest}
  \hspace{5cm}
  \begin{forest}
    [x forest, baseline
      [x[x[x[x[x[x[x[x[x[x[x[x[x]]]]]]]]]]]]]
      [(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)[(x)]]]]]]]]]]]]]
    ]
  \end{forest}
\end{forestexample}

\subsubsection{The defaults, or the hairy details of vertical alignment}
\label{tut:defaults}

In this section we discuss the default values of options controlling the l-alignment of the nodes.
The defaults are set with top-down trees in mind, so l-alignment is actually vertical alignment.
There are two desired effects of the defaults.  First, the spacing between the nodes of a tree
should adjust to the current font size.  Second, the nodes of a given level should be vertically
aligned (at the base), if possible.

Let us start with the base alignment: \TikZ;'s default is to anchor the nodes at their center,
while \foRest;, given the usual content of nodes in linguistic representations, rather anchors them
at the base \cite[\S16.5.1]{tikzpgf2.10}.  The difference is particularly clear for a ``phonological''
representation:
\begin{forestexample}[index={for step,tree,option>anchor}]
  \begin{forest} for tree={anchor=center}
    [maybe[m][a][y][b][e]]
  \end{forest}\quad
  \begin{forest}
    [maybe[m][a][y][b][e]]
  \end{forest}
\end{forestexample}
The following example shows that the vertical distance between nodes depends on the current font size.
\begin{forestexample}
  \hbox{\small A small tree
  \begin{forest} baseline
    [VP[DP][V'[V][DP]]]
  \end{forest}
  \normalsize and
  \large
  a large tree
  \begin{forest} baseline
    [VP[DP][V'[V][DP]]]
  \end{forest}}
\end{forestexample}
Furthermore, the distance between nodes also depends on the value of \PGF;'s |inner_sep| (which
also depends on the font size by default: it equals 0.3333\,em).
\[\index{l sep}=\mbox{height}(\mbox{strut})+\mbox{\texttt{inner ysep}}\]
The default value of \index{s sep} depends on |inner_xsep|: more precisely, it equals double
|inner_xsep|). 
\begin{forestexample}[index={baseline,for step,tree}]
  \begin{forest} baseline,for tree=draw
    [VP[DP][V'[V][DP]]]
  \end{forest}    
  \pgfkeys{/pgf/inner sep=0.6666em}
  \begin{forest} baseline,for tree=draw
    [VP[DP][V'[V][DP]]]
  \end{forest}    
\end{forestexample}
Now a hairy detail: the formula for the default \index{option>l}.
\[\index{option>l}=\index{l sep}+2\cdot\mbox{\texttt{outer ysep}}+\mbox{total
height}(\mbox{`dj'})\]

To understand what this is all about we must first explain why it is necessary to set the default
\index{option>l} at all?  Wouldn't it be enough to simply set \index{l sep} (leaving
\index{option>l} at 0)?
The problem is that not all letters have the same height and depth.  A tree where the vertical
position of the nodes would be controlled solely by (a constant) \index{l sep} could
result in a ragged tree (although the height of the child--parent edges would be constant).
\begin{forestexample}[index={baseline,for step,step>children,no edge,option>name,descendants,option>l}]
  \begin{forest}
    [default,baseline,for children={no edge}
      [DP
        [AdjP[Adj]]
        [D'[D][NP,name=np]]]]
    \path (current bounding box.west)|-coordinate(l)(np.base);
    \path (current bounding box.east)|-coordinate(r)(np.base);
    \draw[dotted] (l)--(r);
  \end{forest}
  \begin{forest}
    [{l=0},baseline,for children={no edge}    
      [DP,for descendants={l=0}
        [AdjP[Adj]]
        [D'[D][NP,name=np]]]]
    \path (current bounding box.west)|-coordinate(l)(np.base);
    \path (current bounding box.east)|-coordinate(r)(np.base);
    \draw[dotted] (l)--(r);
  \end{forest}
\end{forestexample}
The vertical misalignment of Adj in the right tree is a consequence of the fact that letter j is the
only letter with non-zero depth in the tree.  Since only \index{l sep} (which is constant
throughout the tree) controls the vertical positioning, Adj, child of Ad\emph{j}P, is pushed lower
than the other nodes on level 2.  If the content of the nodes is variable enough (various heights
and depths), the cumulative effect can be quite strong, see the right tree of example
(\ref{ex:misalignments}).

Setting only a default \index{l sep} thus does not work well enough in general.  The same
is true for the reverse possibility, setting a default \index{option>l} (and leaving \index{l sep} at 0).  In the example below, the depth of the multiline node (anchored at the top
line) is such that the child--parent edges are just too short if the level distance is kept constant.
Sometimes, misalignment is much preferred \dots
\begin{forestexample}[index={align,{value of=align>center},for step,tree,l sep}]
  \mbox{}\begin{forest}
    [default,baseline
      [first child[a][b][c]]
      [{second child\\[-1ex]\scriptsize(a copy)},
       align=center[a][b][c]]
    ]
  \end{forest}\quad
  \begin{forest} for tree={l sep=0}
    [{\texttt{l sep}=0},baseline
      [first child[a][b][c]]
      [{second child\\[-1ex]\scriptsize(a copy)},
                   align=center[a][b][c]]
    ]
  \end{forest}
\end{forestexample}

Thus, the idea is to make \index{option>l} and \index{l sep} work as a team:
\index{option>l} prevents 
misalignments, if possible, while \index{l sep} determines the minimal vertical distance
between levels.  Each of the two options deals with a certain kind of a ``deviant'' node, i.e.\ a
node which is too high or too deep, or a node which is not high or deep enough, so we need to
postulate what a \emph{standard} node is, and synchronize them so that their effect on standard
nodes is the same.

By default, \foRest; sets the standard node to be a node containing letters d and j.  Linguistic
representations consist mainly of letters, and in the \TeX's default Computer Modern font, d is the
highest letter (not character!), and j the deepest, so this decision guarantees that trees
containing only letters will look nice.  If the tree contains many parentheses, like the right
tree of example (\ref{ex:misalignments}), the default will of course fail
and the standard node needs to be modified.  But for many applications, including nodes with
indices, the default works.

The standard node can be changed using macro \index{forestStandardNode};
see \ref{ref:standard-node}.
% TODO: primer? ali raje po spremembi interfaceja

\subsection{Advanced option setting}
\label{tut:advanced-option-setting}

We have already seen that the value of options can be manipulated: in (\ref{ex:romannumeral}), we
have converted numeric content from arabic into roman numerals using the \emph{wrapping} mechanism
|content=\romannumeral#1|; in (\ref{ex:l*}), we have tripled the value of |l| by saying |l*=3|.  In
this section, we will learn more about the mechanisms for setting options and referring to their
values.

One other way to access an option value is using macro \index{forestoption}.  The macro takes a
single argument: an option name.  In the
following example, the node's child sequence number is appended to the existing content. (This is
therefore also an example of wrapping.)
\begin{forestexample}[label=ex:forestoption,index={option>phantom,delay,for step,descendants,content,readonly option>n,forestoption}]
  \begin{forest}
    [,phantom,delay={for descendants={
      content=#1$_{~\forestoption~{n}}$}}
    [c][o][u][n][t]]
  \end{forest}
\end{forestexample}

However, only options of the current node can be accessed using \index{forestoption}.  Possibly the simplest way to
access option values of other nodes is to use \foRest;'s extensions to the \PGF;'s mathematical library
|pgfmath|, documented in \citep[part VI]{tikzpgf2.10}.  To see |pgfmath| in action,
first take a look at the crazy tree on the title page, and observe how the nodes are
rotated: the value given to option \index{rotate} is a full-fledged |pgfmath| expression
yielding an integer
in the range from $-30$ to $30$.  Similiarly, \index{dimen+=l} adds a random float
in the $[-5,5]$ range to the current value of \index{option>l}.

Example (\ref{ex:spread-s}) demonstrated that information about
the node, like the node's level, can be accessed within |pgfmath| expressions.  All
options are accessible in this way, i.e.\ every option has a corresponding |pgfmath| function.
For example, we could rotate the node based on its content:
\begin{forestexample}[index={delay,for step,tree,content}]
  \begin{forest}
    delay={for tree={~rotate=content~}}
    [30[-10[5][0]][-90[180]][90[-60][90]]]
  \end{forest}
\end{forestexample}

All numeric, dimensional and boolean options of \foRest; automatically pass the given value
through |pgfmath|.  If you need pass the value through |pgfmath| 
for a string option, use the \index{pgfmath} handler.  The following example sets the node's
content to its child sequence number (the root has child sequence number 0).
\begin{forestexample}[index={delay,for step,tree,content,readonly option>n,pgfmath}]
  \begin{forest}
    delay={for tree={content/~.pgfmath~=int(n)}}
    [[[][][]][[][]]]
  \end{forest}
\end{forestexample}

As mentioned above, using |pgfmath| it is possible to access options of non-current nodes.  This
is achieved by providing the option function with a \index{relative node name}
(see~\S\ref{ref:relative-node-names}) argument.\footnote{The form without
parentheses \texttt{option\string_name} that we have been using until now to refer to an option of
the 
current node is just a short-hand notation for \texttt{option\string_name()} --- note that in some
contexts, like preceding \texttt{+} or \texttt{-}, the short form does not work! (The same
seems to be true for all pgfmath functions with ``optional'' arguments.)}  In the next example, we
rotate the node based on the content of its parent (\index{short step>u} means `up').
\begin{forestexample}[index={delay,for step,descendants,content,ss u},index>={!}]
  \begin{forest}
    delay={for descendants={rotate=content~("!u")~}}
    [30[-10[5][0]][-90[180]][90[-60][90]]]
  \end{forest}
\end{forestexample}
Note that the argument of the option function is surrounded by double quotation marks: this is
to prevent evaluation of the relative node name as a |pgfmath| function --- which it is not.

For further ways to access option values, see \S\ref{tut:wrapping}. Here, we continue by introducing
\emph{relative node setting}: write \index{relative node name}|.|\meta{option}|=|\meta{value} to set
the value of \meta{option} of the specified relative node. Important: computation of the value is
done in the context of the original node.  The following example defines style \keyname{move} which
not only draws an arrow from the source (the current node) to the target, but also moves the content
of the source to the target (leaving a trace).  Note the difference between |#1| and |##1|: |#1| is
the argument of the style \keyname{move} (a node walk determining the target), while |##1| is the
original option (in this case, \indexex{option>content}) value.
\begin{forestexample}[index={for step,tree,calign,tikz,delay,content},index>={!}]
  \begin{forest}
    for tree={calign=fixed edge angles},
    move/.style={
      tikz={\draw[->] () to[out=south west,in=south] (#1);},
      delay={~#1.content~={##1},content=$t$}},
    [CP[][C'[C][\dots[,phantom][VP[DP][V'[V][DP,move=!r1]]]]]]
  \end{forest}
\end{forestexample}

\begin{forestexample}[index={if option,n children,content,for step,step>children,delay,pgfmath},index>={!},basicstyle=\scriptsize\ttfamily,layout=export]
  \begin{forest}
    calc/.style={if n children={0}{}{content=0,for children={calc,~!u.content~/.pgfmath=int(content("!u")+content())}}},
    delay=calc,
    [[[3][4][5]][[3][9]][8][[[1][2][3]]]]
  \end{forest}
\end{forestexample}

In the following example, the content of the branching nodes is computed by \foRest;: a branching
node is a sum of its children.  The algorithm visits each node (but the root node) and adds its
content to the content of the parent.  Note that as the computation must proceed bottom-up,
\index{for step=\index{descendants children-first}} propagator is used to walk through the
tree.\footnote{It would be possible to emulate \index{for step=\index{descendants children-first}}
  by defining a recursive style, as was done in this manual for versions of the package prior to
  introduction of the bottom-up propagator. The following code produces identical result as the code
  in the main text.

  \box\codebox}

\begin{forestexample}[index={if option,n children,content,for step,step>children,delay,pgfmath},index>={!}]
  \begin{forest}
    delay={
      where n children={0}{}{content=0},
      for descendants children-first={
        ~!u.content~/.pgfmath=int(content("!u")+content())}
    }
    [[[3][4][5]][[3][9]][8][[[1][2][3]]]]
  \end{forest}
\end{forestexample}

Actually, for common computations such as summing things up, \foRest; provides an easier way to do it: aggregate functions (\S\ref{ref:aggregate-functions}). Below, aggregate function \index{sum}, defined as |pgfkeys| handler, walks through the \index{step>children} (second argument) of the current node, summing up their \index{content} (first argument) and stores the result as the \index{content} of the current node (because \index{content} is the handled key).

\begin{forestexample}[index={sum,aggregate postparse,for step,tree children-first,delay,n children,if option,content,step>children}]
  \begin{forest}
    delay={
      aggregate postparse=int,
      for tree children-first={
        if n children={0}{}{
          content/~.sum~={content}{children}
        }
      }
    }
    [[[3][4][5]][[3][9]][8][[[1][2][3]]]]
  \end{forest}
\end{forestexample}

\subsection{Wrapping}
\label{tut:wrapping}

We have already seen examples of inserting option values into other expressions. In example
(\ref{ex:romannumeral}), we have wrapped the value of the option being assigned to (|#1| stood for
the current value of option \index{content}); example (\ref{ex:forestoption}) additionally wrapped
the value of option \index{readonly option>n} (of the current node) using macro \index{forestoption}.  In general,
\foRest; offers two ways to perform computations (from simple option value lookups to
complicated formulas) and insert their results into another expression (of any kind: \TeX\ code,
|pgfkeys| keylist, |pgfmath| expression, etc.).

Historically, the first \foRest;'s mechanism that offered wrapping of computed values were handlers
\index{wrap pgfmath arg} and \index{wrap $n$ pgfmath args} (for $n=2,\dots,8$), which combine the
wrapping mechanism with the |pgfmath| evaluation.  The idea is to compute (most often, just access
option values) arguments using |pgfmath| and then wrap them into the given macro body (marked below)
using \TeX's parameters (|#1| etc.).  Below, this is used to subscript the contents of a node with
its sequential number and the number of parent's children.
\begin{forestexample}[index={option>phantom,delay,for step,descendants,content,readonly option>n,n children,wrap $n$ pgfmath args},index>={!},label=ex:pgfmathwrap]
  \begin{forest} [,phantom,delay={for descendants={
              content/.wrap 3 pgfmath args=
              ~{#1$_{#2/#3}$}~
              {content}{n}{n_children("!u")}}}
    [c][o][u][n][t]]
  \end{forest}
\end{forestexample}
Note the underscore |__| character in |n__children|: in |pgfmath| function names, spaces,
apostrophes and other non-alphanumeric characters from option names are all replaced by
underscores. 

As another example, let's make the numerals example (\ref{ex:numerals-simple}) a bit fancier.
The numeral type is read off the parent's content and used to construct the appropriate control
sequence (|\@arabic|, |\@roman| and |\@alph|).  (The numbers are not specified in content
anymore: we simply read the sequence number \index{readonly option>n}.)
\begin{forestexample}[index={delay,where option,readonly option>level,content,readonly option>n,for step,step>children,option>l,wrap $n$ pgfmath args},index>={!}]
  \begin{forest}
    delay={where level={2}{content/.wrap 2 pgfmath args=
        {\csname @#1\endcsname{#2}}
        {content("!u")}{n}}{}},
    for children={l*=n},
    [\LaTeX\ numerals,
      [arabic[][][][]]
      [roman[][][][]]
      [alph[][][][]]
    ]
  \end{forest}
\end{forestexample}

Invoking |pgfmath| is fairly time consuming and using it to do nothing but retrieve an option value
seems a bit of an overkill.  To remedy the situation, argument processor
(\S\ref{ref:argument-processor}) was introduced in \FoRest; v2.0 and considerably expanded in v2.1.
One way to invoke it is using handler \index{handler>process}.

The argument processor takes a sequence of instructions and an arbitrary number of arguments,
transforms the given arguments according to the instructions, and feeds the resulting list of
arguments into the handled key.

An instruction is given by a single-character code.  The simplest instructions are:
\index{processor>O}, which expects its argument to be an option name (possibly preceded by a
\index{relative node name}|.| to access the option value of a non-current node) and returns the
value of the option; \index{processor>R}, which does the same for registers; and \index{processor>noop}, which
leaves the argument unchanged.

In the following example, we define style |test| taking four arguments and call it by providing
the arguments via \index{handler>process}. The instruction string |ROO__| tells the argument processor that
the first argument is the value of (scratch) register \indexex{temptoksa}, the second the value of
option \indexex{n children} at the current node, the third the value of option \indexex{content} of
the second child of the current node, and the fourth just a plain string.  Macro |test| is thus
actually invoked with argument list |{Hello}{3}{Jane}{Goodbye}|.

\begin{forestexample}[index={handler>process,processor>noop,processor>R,processor>O,delay,content,n
children,temptoksa}]
  \begin{forest}
    test/.style n args={4}{align=center,
      content={#1!\\I have #2 children.\\One of them is #3.\\#4!}}
    [,delay={temptoksa=Hello,
      test/.process={~ROO_~}{temptoksa}{n children}{!2.content}{Goodbye}}
      [John][Jane][Joe]]
  \end{forest}
\end{forestexample}

To wrap using the argument processor, use instruction \index{processor>w}. Unless wrapping a single
argument, this instruction should be followed by a number indicating the number of arguments
consumed.  \index{processor>w} will take the required number of arguments from the list of already
processed arguments and wrap them in the macro body given as the next (yet unprocessed) argument.

The following example has the same result as example (\ref{ex:pgfmathwrap}).  Note that the
order of the wrapper-macro body and the arguments is different for \index{handler>process} and \index{wrap
  $n$ pgfmath args}.  (Experience shows that \index{handler>process}'s order is easier on the eyes.)  The
example also illustrates that (i) the instructions need not be enclosed in braces and (ii) that
repetition of an argument processor instruction can be indicated by appending a number to the
instruction: thus |O3| below means the same as |OOO|.

\begin{forestexample}[index={option>phantom,delay,for step,descendants,content,readonly option>n,n children},index>={!}]
  \begin{forest} [,phantom,delay={for descendants={
              content/.process=~O3 w3~
                {content}{n}{!u.n children}
                {#1$_{#2/#3}$}
              }}
    [c][o][u][n][t]]
  \end{forest}
\end{forestexample}

Note that the order of the wrapper-macro body and the arguments is different for
\index{handler>process} and \index{wrap $n$ pgfmath args}.  Experience shows that
\index{handler>process}'s order is easier on the eyes. The example also illustrates that the
instructions need not be enclosed in braces and that repetition of an argument processor instruction
can be indicated by appending a number to the instruction: |O3| above is equivalent to |OOO|.

% \begin{forestexample}[index={process,processor>w}]
%   \begin{forest}
%     [root,delay={align=center,
%       content/.process={OO ~w2~}
%         {n children}{content}
%         {This node has #1 children.\\It's original content is ``#2''.}
%       }]
%   \end{forest}
% \end{forestexample}

\index{wrap $n$ pgfmath args} always returns a single braced expression and is thus a bit cumbersome
to use when the handled key expects multiple arguments: the trick is to enclose the expected
argument list in extra braces (marked in the code below).  As \index{handler>process} can return multiple
arguments, there is no need for such a workaround. See the following example for comparison of the
two methods.

\begin{forestexample}[index={for step,step>name,handler>process,processor>O,processor>w,wrap $n$ pgfmath args}]
  \begin{forest}
    [,phantom
      [pgfmath[2,delay={for n/.wrap 2 pgfmath args=
          ~{~{#1}{content=#2,draw}~}~
          {content}{content("!u")}
        } [x][x][x][x]]]
      [process[3, delay={for n/.process=
          {O Ow1}{content}
          {!u.content}{content=#1,draw}
        } [x][x][x][x]]]
    ]
  \end{forest}
\end{forestexample}

A single \index{handler>process} invocation can perform multiple wrappings. The numbering of arguments of
each wrapping starts at |#1|. In the example below, \index{for step=\index{nodewalk}} takes two
arguments, a nodewalk and a list of nodekeys. Each is produced by an independent wrapping (wrap bodies
are marked in the code).

\begin{forestexample}[index={handler>process,processor>R,processor>w,for step,nodewalk,+toks,content}]
  \begin{forest}
    declare toks register=prefix,
    declare count register=level to prefix,
    prefix=X-,
    level to prefix=1,
    delay={
      for nodewalk/.process=Rw Rw
      {level to prefix}{~level=#1~}
      {prefix}{~+content=#1~}
    }
    [0[1[2]][3[4][5]][6[7][8][9]]]
  \end{forest}
\end{forestexample}




\subsection{Externalization}
\label{tut:externalization}

\FoRest; can be quite slow, due to the slowness of both \PGF;/\TikZ; and its own computations.
However, using \emph{externalization}, the amount of time spent in \foRest; in everyday life can
be reduced dramatically.  The idea is to typeset the trees only once, saving them in separate
PDFs, and then, on the subsequent compilations of the document, simply include these PDFs instead
of doing the lenghty tree-typesetting all over again.

\FoRest;'s externalization mechanism is built on top of \TikZ;'s |external| library.  It
enhances it by automatically detecting the code and context changes: the tree is recompiled if and
only if either the code in the \index{forest} environment or the context (arbitrary parameters; by
default, the parameters of the standard node) changes.

To use \foRest;'s externalization facilities, say:\footnote{When you switch on
the externalization for a document containing many \keyname{forest} environments, the first
compilation can take quite a while, much more than the compilation without externalization. (For
example, more than ten minutes for the document you are reading!)  Subsequent compilations,
however, will be very fast.}\index[not print]{external}
\begin{lstlisting}[point=external]
  \usepackage[external]{forest}
  ~\tikzexternalize~
\end{lstlisting}

If your \index{forest} environment contains some macro, you will probably want the externalized
tree to be recompiled when the definition of the macro changes.  To achieve this, use
\index{forestset}|{|\index{external/depends on macro}|=|\cmdname{macro}|}|.  The effect is
local to the \TeX\ group.

\TikZ;'s externalization library promises a |\label| inside the externalized graphics to work
out-of-box, while |\ref| inside the externalized graphics should work only if the externalization
is run manually or by |make| \citep[\S32.4.1]{tikzpgf2.10}.  A bit surprisingly perhaps, the
situation is roughly reversed in \foRest;.  |\ref| inside the externalized graphics will work
out-of-box.  |\label| inside the externalized graphics will not work at all.  Sorry.  (The reason
is that \foRest; prepares the node content in advance, before merging it in the whole tree, which
is when \TikZ;'s externalization is used.)

\subsection{Expansion control in the bracket parser}
\label{tut:bracket}

By default, macros in the bracket encoding of a tree are not
expanded until nodes are being drawn --- this way, node
specification can contain formatting instructions, as illustrated in
section~\ref{tut:basic-usage}.  However, sometimes it is useful to
expand macros while parsing the bracket representation, for example to
define tree templates such as the X-bar template, familiar
to generative grammarians:\footnote{Honestly, dynamic node creation might be a better way to do
this; see~\S\ref{ref:dynamic}.}
\begin{forestexample}[index={bracketset,action character}]
  ~\bracketset{action character=@}~
  \def\XP#1#2#3{#1P[#2][#1'[#1][#3]]}
  \begin{forest}
    [~@~\XP T{DP}{~@~\XP V{DP}{DP}}]
  \end{forest}
\end{forestexample}
In the above example, the |\XP| macro is preceded by the \emph{action character} |@|: as
the result, the token following the action character was expanded before the parsing proceeded.

The action character is not hard coded into \foRest;.  Actually, there is no action character by
default.  (There's enough special characters in \foRest; already, anyway, and the situations where
controlling the expansion is preferable to using the |pgfkeys| interface are not numerous.)  It is
defined at the top of the example by processing key \index{action character} in the
|/bracket| path; the definition is local to the \TeX\ group.

Let us continue with the description of the expansion control facilities of the bracket parser.
The expandable token following the
action character is expanded only once.  Thus, if one defined macro
|\VP| in terms of the general |\XP| and tried to use it in the same
fashion as |\XP| above, he would fail.  The correct way is to follow
the action character by a braced expression: the braced expression
is fully expanded before bracket-parsing is resumed.
\begin{forestexample}[index={bracketset,action character}]
  \bracketset{action character=@}
  \def\XP#1#2#3{#1P[#2][#1'[#1][#3]]}
  \def\VP#1#2{\XP V{#1}{#2}}
  \begin{forest}
    [@\XP T{DP}{~@{~\VP{DP}{DP}~}~}]
  \end{forest}
\end{forestexample}

In some applications, the need for macro expansion might be much
more common than the need to embed formatting instructions.
Therefore, the bracket parser provides commands |@+| and |@-|: |@+|
switches to full expansion mode --- all tokens are fully expanded
before parsing them; |@-| switches back to the default mode, where
nothing is automatically expanded.
\begin{forestexample}[index={bracketset,action character}]
  \bracketset{action character=@}
  \def\XP#1#2#3{#1P[#2][#1'[#1][#3]]}
  \def\VP#1#2{\XP V{#1}{#2}}
  \begin{forest} ~@+~
    [\XP T{DP}{\VP{DP}{DP}}]
  \end{forest}
\end{forestexample}

All the action commands discussed above were dealing only with
\TeX's macro expansion.  There is one final action command, |@@|,
which yields control to the user code and expects it to call
|\bracketResume| to resume parsing.  This is useful to e.g.\
implement automatic node enumeration:
\begin{forestexample}[index={bracketset,action character,option>phantom,delay,where option,readonly option>level,content}]
  \bracketset{action character=@}
  \newcount\xcount
  \def\x#1{~@@~\advance\xcount1
    \edef\xtemp{[$\noexpand\times_{\the\xcount}$[#1]]}%
    \expandafter\bracketResume\xtemp
  }
  \begin{forest}
    phantom,
    delay={where level=1{content={\strut #1}}{}}
    ~@+~
    [\x{f}\x{o}\x{r}\x{e}\x{s}\x{t}]
  \end{forest}
\end{forestexample}
This example is fairly complex, so let's discuss how it works.  |@+| switches to the full
expansion mode, so that macro |\x| can be easily run.  The real magic hides in this macro.  In
order to be able to advance the node counter |\xcount|, the macro takes control from \foRest; by
the |@@| command.  Since we're already in control, we can use |\edef| to define the node content.
Finally, the |\xtemp| macro containing the node specification is expanded with the resume command
sticked in front of the expansion.



\section{Reference}
\label{sec:reference}

This section documents all publicly exposed keys and macros defined by the core package.  All other
commands defined by the package (see the implementation typeset in |forest.pdf|) are considered
internal and might change without prior notice or compatibility support.

\subsection{Package loading and options}
\label{ref:package-options}

Load the package by writing |\usepackage{forest}| in the document preamble.

Field-specific definitions and defaults are stored in separate libraries.  Use
|\usepackage[|\meta{library name}|]{forest}| to load library \meta{library name} and its defaults
alongside the main package.  Loading several libraries in this way is allowed: however, if you need
more control over loading the defaults, use the following macros.

\begin{syntax}
\indexitem{macro>useforestlibrary}[|*|][|[|\meta{options}|]|]|{|\meta{library}|,...}|
Loads the given libraries.

The starred version applies their defaults as well, while the starless does not.  Multiple library
names can be given, separated by commas.  Libraries can receive \meta{options}.  This macro can only
be used in the preamble.

\indexitem{macro>forestapplylibrarydefaults}|{|\meta{library name},...|}|
Loads the default settings of \meta{library}.

Multiple library names can be given, separated by commas.  This macro can be used either in the
preamble or in the document body. Its effect is local to the current \TeX\ scope.
\end{syntax}

For example, the |linguistics| library defines c-command related nodewalks, changes the default
parent--child edges to south--north (the main package default is border--border) and sets the
baseline to the root\footnote{For details, see \S\ref{sec:library-linguistics}.} node.  Thus, if you write |\usepackage[linguistics]{forest}| in your preamble,
or use macro \cmdname{forestapplylibrarydefaults} like below, you get the following:

\begin{forestexample}[tree bin=minipage,index={for step,c-commanded}]
  package defaults:
  \begin{forest}
    [VP % cannot use "for c-commanded" below!
      [DP, for sibling={for tree=red}]
      [V'[V][DP]]
    ]
  \end{forest}\\[1ex]
  |linguistics| library defaults:
  ~\forestapplylibrarydefaults{linguistics}~
  \begin{forest}
    [VP
      [DP, ~for c-commanded~={red}]
      [V'[V][DP]]
    ]
  \end{forest}  
\end{forestexample}

\begin{syntax}
\indexitem(false){package option>external}|=|\alternative{true,false}

  Enable/disable externalization, see \S\ref{ref:externalization}.
  
\indexitem(most){package option>compat}|=|\meta{keylist}
Enter compatibility mode with previous versions of the package.

If at all possible, each backwards incompatible change is given a key in the |compat| path, e.g.\
|compat=|\index{1.0-forstep} reverts to the old behaviour of spatial propagators \index{for
  step=\meta{step}}, where a propagator could not fail.

While each compatibility feature can be enabled individually, they are grouped for ease of use.  To
load compatibility features since the last version of form
|x|[|.y|[|.z|]], write |compat=x|[|.y|[|.z|]]|-all| or
|compat=x|[|.y|[|.z|]]|-most|.  The former enables all compatibility features since that release, the
latter only those that are guaranteed to not disrupt any new functionality of the package.

To load all compatibility features since the last major release (|x| in |x.y.z|), write
|compat=|\indexdef{value of=compat>all}; to load most of them, write |compat=|\indexdef{value of=compat>most} or simply |compat|.

To enable multiple compatibility features, either use this option multiple times, or provide it with
a comma-separated list of compatibility features. (Surround the list by braces.)

Specifying this option also defines macro \indexdef{macro>forestcompat} (taking the same arguments
as the package option) which can be used to enable compatibility features locally, within the
document body.  To enable compatibility mode but not enable any specific compatibility feature for
the entire document, write |compat=|\indexdef{value of=compat>none} as a package option.

For a list of compatibility features, see \S\ref{sec:changelog}.

By default, the package warns when a compatibility feature is used.  Disable this behaviour by
|compat=|\indexdef{value of=compat>silent}.

\indexitem(true){package option>tikzcshack}|=|\alternative{true,false}

  Enable/disable the hack into \TikZ;'s implicit coordinate syntax, see
  \S\ref{ref:relative-node-names}.

\indexitem(true){package option>tikzinstallkeys}|=|\alternative{true,false}

  Install certain keys into the \keyname{/tikz} path.  Currently: \index{fit to}.
  
\indexitem{package option>debug}|=|\meta{debug category}[, \meta{debug category}]*

Prints out some debugging info to the log file.  When given no argument, prints out all the
available information, otherwise only the information on the listed (comma-separated) debug categories.  The available categories are listed below.

\begin{syntax}
  \indexitem{value of=debug>nodewalks}
  \indexitem{value of=debug>dynamics}
  \indexitem{value of=debug>process}
\end{syntax}
  
\end{syntax}

\subsection{Invocation}
\label{sec:invocation}

\begin{syntax}
  %%% begin listing region: forest_environment_doc
\indexitem{environment>forest={[\texttt{(}\meta{config}\texttt{)}]\meta{tree}}}
  %%% end listing region: forest_environment_doc
\indexitem{macro>Forest}[*][|(|\meta{config}|)|]\marg{tree}

  The environment and the starless version of the macro introduce a group; the starred macro does
  not, so the created nodes can be used afterwards, like in the example below.  (Note that this will
  leave a lot of temporary macros lying around.  This shouldn't be a problem, however, since all of
  them reside in the |\forest| ``namespace''.)

{\tikzexternaldisable
\begin{forestexample}
    We create a
    ~\Forest*~{
      [DP,name=DP,baseline
        [D]
        [NP]
      ]
    }
    and merge it into a 
    ~\Forest*~{
      [VP,baseline
        [V]
        [,replace by=DP
        ]
      ]
    }
\end{forestexample}}

\meta{config} is a keylist that configures the behaviour of the environment/macro.  The
configuration is the first operation that the environment/macro does; it precedes even the reading
of the tree specification.  Currently, \meta{config} accepts only one key:
  \begin{syntax}
    \indexitem{option of=forest>stages}|=|\meta{keylist}

    By default, after reading the tree specification, \foRest; executes style \index{style>stages}.
    If key |stages| is used in \meta{config}, \meta{keylist} is executed instead.
  \end{syntax}
  
\indexitem{macro>forestset}\marg{keylist}
  
  Execute \meta{keylist} (of node keys) with the default path set to \keyname{/forest}.
  \begin{advise}
  \item This macro is usually used to define \foRest; styles.
  \item Usually, no current node is set when this macro is called.  Thus, executing most node keys
    in this place will fail. However, if you have some nodes lying around, you can use
    propagator \index{for step=\index{option>name}}|=|\meta{node name} to set the node with the given name as
    current.
  \end{advise}
\end{syntax}


\subsection{The bracket representation}
\label{ref:bracket}

A bracket representation of a tree is a token list with the following syntax:
\begin{eqnarray*}
  \meta{tree}&=&\left[\meta{preamble}\right]\meta{node}\\
  \meta{node}&=&\texttt{[}\left[\meta{content}\right]\left[\texttt{,}\meta{keylist}\right]
                 \left[\meta{children}\right]\texttt{]}\meta{afterthought}\\
  \meta{preamble}&=&\meta{keylist}\\
  \meta{keylist}&=&\meta{key--value}\left[,\meta{keylist}\right]\\
  \meta{key--value}&=&\meta{key}\OR\meta{key}\texttt{=}\meta{value}\\
  \meta{children}&=&\meta{node}\left[\meta{children}\right]
\end{eqnarray*}

The \meta{preamble} keylist is stored into keylist register \index{preamble}.  The \meta{keylist} of
a \meta{node} is stored into keylist option \index{given options}.  \meta{content} and
\meta{afterthought} are normally stored by prepending and appending
\index{content}|'=|\meta{content} and \index{afterthought}|=|\meta{afterthought} to \index{given
  options}, respectively; this is customizable via \index{content to} and redefining style
\index{afterthought}.

Normally, the tokens in the bracket representation are not expanded while the input is parsed.
However, it is possible to control expansion.  Expansion control sequences of \foRest;'s bracket
parser are shown below.  Note that by default, there is no \index{action character}.
\begin{center}
  \begin{tabular}{ll}
    \rstyle\meta{action character}\texttt{-}&no-expansion mode (default): nothing is expanded\\
    \rstyle\meta{action character}\texttt{+}&expansion mode: everything is fully expanded\\
    \rstyle\meta{action character}\texttt{}\meta{token}&expand \meta{token}\\
    \rstyle\meta{action character}\texttt{}\meta{\TeX-group}&fully expand \meta{\TeX-group}\\
    \rstyle\meta{action character}\meta{action character}&yield control;\\&upon finishing its job,
    user's code should call \indexdef{macro>bracketResume}
  \end{tabular}
\end{center}

To customize the bracket parser, call
\indexdef{macro>bracketset}\meta{keylist}, where the keys can be the following. 
\begin{syntax}
\indexitem({{[%]
  }}){bracket key>opening bracket}|=|\meta{character}
\indexitem({{{{%[
        ]}}}}){bracket key>closing bracket}|=|\meta{character}
\indexitem(none){bracket key>action character}|=|\meta{character}
\end{syntax}

\begin{advise}
\item Careful when setting the \index{opening bracket} to |(|, %)
  as an initial |(| %)
  is understood as the delimiter of the optional \meta{config} argument of the
  \index{environment>forest} environment or \index{macro>Forest} macro.  The workaround is to either
  provide an empty \meta{config} argument |()|, or put some whitespace (e.g.\ a newline) before the
  tree specification.
\end{advise}

By redefining the following two keys, the bracket parser can be used outside \foRest;.
\begin{syntax}
\indexitem{bracket key>new node}|=|\meta{preamble}\meta{node specification}\meta{csname}.
  Required semantics: create a new node given the preamble (in the case of a new
  root node) and the node specification and store the new node's id into \meta{csname}. 
\indexitem{bracket key>set afterthought}|=|\meta{afterthought}\meta{node id}.
  Required semantics: store the afterthought in the node with given id.
\end{syntax}

\subsection{The workflow}
\label{sec:workflow}

\subsubsection{Stages}
\label{ref:stages}

\FoRest; does its job in several stages.  The default course of events is the following:
\begin{enumerate}
\item\label{step:parsing-bracket} The bracket representation of the tree (\S\ref{ref:bracket}) is
  parsed and stored in a data structure.
\item\label{step:given-options} The keys given in the bracket representation are processed. In
  detail, \index{default preamble} is processed first, then the given \index{preamble} (both in the
  context of the (formal) root node) and finally the keylists given to individual nodes.  The latter
  are processed recursively, in a depth-first, parent-first fashion.
\item\label{step:typeset-nodes} Each node is typeset in its own |tikzpicture| environment, saved
  in a box and its measures are taken.
\item\label{step:pack} The nodes of the tree are \emph{packed}, i.e.\ the relative positions of the nodes are
  computed so that the nodes don't overlap.  That's difficult.  The result: option \index{option>s} is
  set for all nodes.  (Sometimes, the value of \index{option>l} is adjusted as well.)
\item\label{step:compute-xy} Absolute positions, or rather, positions of the nodes relative to the
  root node are computed.  That's easy.  The result: options \index{option>x} and \index{y} are
  set.
\item\label{step:draw-tree} The \TikZ; code that will draw the tree is produced and executed.  (The nodes are
  drawn by using the boxes typeset in step~\ref{step:typeset-nodes}.)
\end{enumerate}

Stage~\ref{step:parsing-bracket} collects user input and is thus ``fixed''.  However, the other
stages, which do the actual work, are under user's control.

First, hooks exist between the individual stages which make it possible (and easy) to change the
properties of the tree between the processing stages.  For a simple example, see
example~(\ref{ex:adjustxy}): the manual adjustment of \index{y} can only be done after the absolute
positions have been computed, so the processing of this option is deferred by \index{before drawing
  tree}.  For a more realistic example, see the definition of style \index{GP1}: before packing,
\texttt{outer xsep} is set to a high (user determined) value to keep the $\times$s uniformly spaced;
before drawing the tree, the \texttt{outer xsep} is set to \texttt{0pt} to make the arrows look
better.

Second, the execution of the processing stages \ref{step:given-options}--\ref{step:draw-tree} is
\emph{completely} under user's control.  To facilitate adjusting the processing flow, the approach
is twofold.  The outer level: \foRest; initiates the processing by executing style \index{style>stages},
which by default executes the processing stages \ref{step:given-options}--\ref{step:draw-tree},
preceding the execution of each but the first stage by processing the keys embedded in temporal
propagators \keyname{before ...} (see \S\ref{ref:temporal-propagators}).  The inner level: each
processing step is the sole resident of a stage-style, which makes it easy to adjust the workings of
a single step.  What follows is the default content of style \keyname{stages}, including the default
content of the individual stage-styles. Both nicely readable and ready to copy-paste versions are given.
\begin{syntax}
  \indexitem{style>stages}
  \begin{syntax}
  \item \index{for step=\index{root'}}|={|
  \item |  |\index{process keylist register}|=|\index{default preamble}|,|
  \item |  |\index{process keylist register}|=|\index{preamble}
  \item |}|
  \item \index{process keylist}|=|\index{given options}
  \item \index{process keylist}|=|\index{before typesetting nodes}
  \indexitem{style>typeset nodes stage}\hfill
    |{|\index{for step=\index{root'}}|=|\index{typeset nodes}|}|
  \item \index{process keylist}|=|\index{before packing}
  \indexitem{style>pack stage}\hfill
    |{|\index{for step=\index{root'}}|=|\index{pack}|}|
  \item \index{process keylist}|=|\index{before computing xy}
  \indexitem{style>compute xy stage}\hfill
    |{|\index{for step=\index{root'}}|=|\index{compute xy}|}|
  \item \index{process keylist}|=|\index{before drawing tree}
  \indexitem{style>draw tree stage}\hfill
    |{|\index{for step=\index{root'}}|=|\index{draw tree}|}|
  \end{syntax}
\end{syntax}
\lstinputregion{forest.dtx}{stages}

Both style \keyname{stages} and the individual stage-styles may be freely modified by the user.
Obviously, as a style must be redefined before it is processed, |stages| should be redefined (using
macro \index{forestset}) outside the \index{forest} environment; alternatively, stages can be given
as the (parenthesized) optional argument of the environment (see~\S\ref{sec:invocation}).  A stage
style can also be redefined in the preamble or in any of the keylists processed prior to entering
that stage.

Here's the list of keys used either in the default processing or useful in an alternative
processing flow.
\begin{syntax}
  \indexitem{stage>typeset nodes}
  \itemnosep
  \indexitem{stage>typeset nodes'}
  
  Typesets each node of the current node's subtree in its own |tikzpicture| environment.  The result
  is saved in a box (which is used later, in the \index{draw tree stage}) and its measures are
  taken.

  In the |typeset_nodes'| variant, the node box's content is not overwritten if the box already
  exists.

  The order in which the nodes are typeset is controlled by nodewalk style \indexdef{nodewalk
    style>typeset nodes processing order} or, if this style is not defined, by \index{processing
    order}. 
  
\indexitem{node key>typeset node}  Typesets the \emph{current} node, saving the result in the node box.

  This key can be useful also in the default \index{style>stages}.  If, for example, the node's content
  is changed and the node retypeset just before drawing the tree, the node will be positioned as if
  it contained the ``old'' content, but have the new content: this is how the constant distance
  between $\times$s is implemented in the \index{GP1} style.

\indexitem{stage>pack} The nodes of the tree are \emph{packed}, i.e.\ the relative positions of
  the nodes are computed so that the nodes don't overlap.  The result: option \index{option>s} is set
  for all nodes; sometimes (in tier alignment and for some values of \index{calign}), the value
  of some nodes' \index{option>l} is adjusted as well.

\indexitem{node key>pack'} ``Non-recursive'' packing: packs the children of the current node only.
  (Experimental, use with care, especially when combining with tier alignment.)

\indexitem{stage>compute xy} Computes the positions of the nodes in the subtree relative to the
  current node.  The results are stored into options \index{option>x} and \index{y}.  The current node's
  \index{option>x} and \index{y} remain unchanged.

\indexitem{stage>draw tree}
\itemnosep
\indexitem{stage>draw tree'}
  Produces and executes the \TikZ; code that draws the (sub)tree rooted in the current node.

  The procedure uses the node boxes typeset by \index{typeset nodes} or friends.  The |'| variant
  includes the node boxes in the picture using \cmdname{copy}, not \cmdname{box}, thereby preserving
  them.

  For details and customization, see \S\ref{sec:draw-tree}.

\indexitem{node key>draw tree box}|=|[\meta{\TeX\ box}]  The picture drawn by the subsequent
  invocations of \index{draw tree} and \index{draw tree'} is put into \meta{\TeX\ box}.  If
  the argument is omitted, the subsequent pictures are typeset normally (the default).

  \indexitem{node key>process keylist}|=|\meta{keylist option}
  For each node in the entire tree, the keylist saved in \meta{keylist option} of the node is
  processed (in the context of that node).

  Note that this key is not sensitive to the current node: it processes the keylists for the whole
  tree.  Actually, it is possible to control which nodes are visited: \index{keylist option
    processing order=\meta{keylist option}} is walked if it is defined, otherwise \index{processing
    order}. In both cases, the processing nodewalk starts at the formal root of the tree (see
  \index{root'} and \index{set root}), which is reevaluated at the beginning of each internal cycle
  (see below). By default, \index{keylist option processing order=\meta{keylist option}} is indeed
  undefined, while the \index{processing order} defauls to \index{tree}, which means that \emph{all
    the nodes in the entire tree} are processed.

  Keylist-processing proceeds in cycles.  In a given cycle, the value of option \meta{keylist option
    name} is processed for every node visited by the processing nodewalk.  During a cycle, keys may
  be \emph{delayed} using key \index{delay}.  Keys delayed in a cycle are processed in the next
  cycle.  The number of cycles in unlimited. 

  Dynamic creation of nodes happens between the cycles. The options given to the dynamically
  created nodes are implicitely delayed and thus processed at the end of the next cycle.

  This key is primarily intended for use within \index{style>stages}. 
  The calls of this key should \emph{not} be nested, and it should not be embedded under
  \index{process keylist'} or \index{process keylist register}.

  When changing the processing nodewalk, note that delayed keys will be executed only for nodes
  visited by the processing nodewalk.  Delayed spatially propagated keys will be remembered,
  though, and executed when the given keylist is processed for the target node.  Using spatial
  propagators without delaying cannot result in a non-processed key.

\indexitem{node key>process keylist'}|=|\meta{keylist option}\meta{nodewalk}

  This key is a variant of \index{process keylist}.  The differences are as follows.

  The processing nodewalk is given explicitely (by \meta{nodewalk}) and starts at the current node
  (in each internal cycle).

  There is no dynamic creation of nodes between the delay cycles. Any dynamic node
  instructions will be remembered and executed after the next cycle of \index{process keylist}, or
  an explicit call to \index{do dynamics}.
  
  It is safe to embed this key within \index{process keylist} and (all) friends.

\indexitem{node key>process keylist''}|=|\meta{keylist option}\meta{nodewalk}

This key is a variant of \index{process keylist} which executes neither dynamic node operations nor
delayed keys (there are thus no internal cycles).  Any delayed keys will not be processed
during the execution of this key. They will be remembered and executed at the end of the next cycle
of \index{process keylist} or \index{process keylist'}.

As for \index{process keylist'}, the processing nodewalk is given explicitely (by \meta{nodewalk})
and starts at the current node.

It is safe to embed this key within \index{process keylist} and (all) friends.
  
\indexitem{node key>process keylist register}|=|\meta{register}

  Process the keylist saved in \meta{register} in the context of the current node.

  Any delayed keys will not be processed during the execution of this key. They will be
  remembered and executed at the end of the next cycle of \index{process keylist} or
  \index{process keylist'}.

  It is safe to embed this key within \index{process keylist} or \index{process keylist'}.

\indexitem{node key>process delayed}|=|\meta{nodewalk} Process delayed keys.

  Keylist \index{delay} cannot be processed using \index{process keylist} or \index{process
    keylist'}. Thus this key.

  Like \index{process keylist} or \index{process keylist'}, this key uses internal cycles.  Thus,
  any embedded \index{delay}s will be processed.

  There is no dynamic creation of nodes between the delay cycles. Any dynamic node instructions will
  be remembered and executed after the next cycle of \index{process keylist} or \index{process
    keylist'}, or an explicit call to \index{do dynamics}.
  
  This key is safe to use within \index{process keylist}, \index{process keylist'} and
  \index{process keylist register}.
  
\indexitem(tree){nodewalk style>processing order}|/.nodewalk style=|\meta{nodewalk}

Redefine this style to change the default order in which \index{process keylist} processes a keylist
option.  For example, to process the nodes in a child-first fashion, write
\begin{lstlisting}
  processing order/.nodewalk style=tree children first
\end{lstlisting}
Note that this is a \emph{nodewalk} style, so it must be defined either using |.style| handler
during a nodewalk or using \index{nodewalk style}.

\indexitem(processing order)[form={processing order}]{word suffix=keylist option>nodewalk style>processing order=\meta{keylist option}}|/.nodewalk style=|\meta{nodewalk}

Redefine this style to change the \index{process keylist} processing order for a specific
\meta{keylist option}.  For example, to process \index{before drawing tree} options in the
child-first fashion, leaving the processing of other |before ...| keylists untouched, write
\begin{lstlisting}
  before drawing tree processing order/.nodewalk style=tree children first
\end{lstlisting}

\indexitem{node key>do dynamics} Experimental. Perform pending dynamic tree operations.

  Do not use this key within \index{process keylist} or \index{process keylist'}.

\end{syntax}

\subsubsection{Temporal propagators}
\label{ref:temporal-propagators}

Temporal propagators delay processing of given keys until some other point in the processing of the
tree.  There are three kinds of temporal propagators.  Most of the propagators have the form
|before_...| and defer the processing of the given keys to a hook just before some stage in the
workflow (\S\ref{ref:stages}).  \index{before packing node} and \index{after packing node} are
special as they fire \emph{during} the packing stage.  The \index{delay} propagator is
``internal'' to the current hook: the keys in the hook are processed cyclically, and \keyname{delay}
delays the processing of the given keys until the next cycle.

Formally, temporal propagators are keylist options (except \index{delay n}, which is a style), so
augmented assignments are possible (\S\ref{sec:option-setting}).

All temporal propagators can be nested without limit.

\begin{advise}
\item A note on typos.
  
  By default, all keys unknown to \foRest; are appended to keylist option \index{node options} The
  value of \index{node options} is fed to \TikZ; when typesetting a node, so any typos are caught by
  \TikZ;. However, as nodes are normally typeset in stage \index{typeset nodes stage}, any typos in
  keys temporally propagated past that stage will not be noticed, simply because noone will use the
  value of \index{node options} where they end up (the exception being nodes which are explicitely
  retypeset by the user using \index{typeset node}).

  To sum up, typos in any keys temporally propagated by \index{before packing}, \index{before
    packing node}, \index{after packing node}, \index{before computing xy} and \index{before drawing
    tree} will be silently ignored.  This is probably not what you want, so double-check everything
  you write there.

  Using \index{unknown to}|=|\index{unknown key error}, it is possible to change the default
  behaviour.  You will catch all typos if you append the command to \index{pack stage}, as shown
  below.  This can be done either in the tree or by \index{forestset}.

\begin{lstlisting}
  typeset nodes stage/.append style={unknown to=unknown key error}
\end{lstlisting}

  Of course, this makes it impossible to write simply
  |before_drawing_tree={inner_sep=5pt,_typeset_node}|.  Any |tikz|'s options must be given
  explicitely via \index{node options}:
  |before_drawing_tree={node_options={inner_sep=5pt},_typeset_node}|.
\end{advise}

\begin{syntax}
\indexitem{propagator>delay}|=|\meta{keylist} Defers the processing of the \meta{keylist} until the next
  cycle.

  Internally, |delay| is a keylist option, so augmented operators of the \index{keylist} type can be
  used.

  To check whether any keys were delayed, use conditional \index{if have delayed}.
\indexitem{propagator>delay n}|=|\meta{integer}\meta{keylist} Defers the processing of the
  \meta{keylist} for $n$ cycles.  $n$ may be $0$, and it may be given as a |pgfmath| expression.
  
\indexitem{propagator>given options}
  
  When \index{style>stages} processing starts, this list holds the keys given by the user in the
  bracket representation.
  
\indexitem{propagator>before typesetting nodes}|=|\meta{keylist} Defers the processing of the
  \meta{keylist} to until just before the nodes are typeset.

\indexitem{propagator>before packing}|=|\meta{keylist}
  
\indexitem{propagator>before packing node}|=|\meta{keylist}

  Defers the processing of the \meta{keylist} given to the node to until just before/after the
  subtree of \emph{this specific node} is packed.  Even before packing node, the (subtrees of the)
  children of the node have already been packed.\footnote{\FoRest; employs two variants of the
    packing algorithm: the faster one is used for (parts of) trees with uniform growth, i.e.\
    subtrees where \index{grow} does not change; the slower, generic variant is used in where this
    is not the case.  Now, the fast method works by dealing with l and s dimension separately, and
    it is able to do this for the entire (sub)tree, without needing to invoke the packing method for
    its constituents.  The consequence is that there is no place where \index{before packing node}
    could be called meaningfully, as the node's constituents are not packed individually, ``just
    before packing the current node'' is the same as ``just before packing the tree'', and for many
    nodes packing is not called anyway in the fast method.  As the rationale behind \index{before
      packing node} is to be able to adjust the options of the subtree based on the information
    gained by packing its constituents, specifying \index{before packing node} automatically
    switches to the generic method.}  \indexitem{propagator>after packing node}|=|\meta{keylist} Defers
  the processing of the \meta{keylist} given to the node to until just after \emph{this specific
    node} is packed.

\begin{forestexample}[index={after packing node,no edge,calign,value of=calign>first,option>l,l sep,content format,content,if option,n children,pgfmath,option>s,max x,min x,for step,step>children,wrap pgfmath arg,typeset node,dimen+=s}]
  \forestset{box/.style={
    draw, no edge, l=0, l sep=1.5ex, 
    calign=first, anchor=base west,
    content format={\strut\forestoption{content}},
    if n children=0{}{
      ~after packing node~={
        minimum width/.pgfmath=
          {s("!l")+max_x("!l")-s("!1")-min_x("!1")},
        for children/.wrap pgfmath arg={s+={##1}}{0},
        typeset node}}}}
  \begin{forest} for tree={box} [/
    [home[saso[Download][TeX]][alja][joe]]
    [usr[bin][share]]]
  \end{forest}    
\end{forestexample}
  
  \begin{advise}
  \item Remember to typeset or pack the node using \index{pack'} if you have changed options
    influencing the typesetting or packing process.
  \end{advise}

\indexitem{propagator>before computing xy}|=|\meta{keylist}  Defers the processing of the
  \meta{keylist} to until just before the absolute positions of the nodes are computed.
\indexitem{propagator>before drawing tree}|=|\meta{keylist}  Defers the processing of the
  \meta{keylist} to until just before the tree is drawn.
\end{syntax}


\subsubsection{Drawing the tree}
\label{sec:draw-tree}

This section provides a detailed description of how \index{draw tree} and friends draw the tree.

First, here's the default course of events.  \index{draw tree} is called from style \index{draw tree
  stage} in the context of the formal root node.  It does not draw the tree directly, but rather
produces \TikZ; code that actually does the drawing.  The tree-drawing instructions are enclosed in
a |tikzpicture| environment and come in three parts: the (non-phantom) nodes are drawn first,
followed by edges between the drawn nodes and finally the custom \TikZ; code (of all, including
phantom nodes).  Each of those is drawn for the entire (sub)tree of the current node, in recursive,
depth-first parent-first first-child-first order.

Most parts of the tree drawing procedure are customizable.  Zooming in from the invocation of
\index{draw tree} to the keys that produce the drawing code, the customization options are as
follows.

There are two ways the invocation of \index{draw tree} can differ from the default.  First,
\index{draw tree} can be called within the context of any node.  As a first approximation, that node
will become the root of the tree that is being drawn; for the whole truth, see \index{draw tree
  method}.  Second, \index{draw tree} can be called not only at \index{draw tree stage}, but any
time after the nodes to be drawn have been typeset (see \index{typeset nodes stage}) and their
absolute coordinates (\index{option>x} and \index{option>y}) computed (see \index{compute xy stage}).


\begin{syntax}
\indexitem(\begin{tikzpicture}){node key>begin draw}|/.code=|\meta{toks: \TeX\ code}  \vspace{-\parskip}
\indexitem(\end{tikzpicture}){node key>end draw}|/.code=|\meta{toks: \TeX\ code}

The code produced by \index{draw tree} is put in the environment specified by \keyname{begin
draw} and \keyname{end draw}.  Thus, it is this environment, normally a |tikzpicture|, that does
the actual drawing.

A common use of these keys might be to enclose the |tikzpicture| environment in a |center|
environment, thereby automatically centering all trees; or, to provide the \TikZ; code to execute
at the beginning and/or end of the picture.

Note that \keyname{begin draw} and \keyname{end draw} are \emph{not} node options: they are
|\pgfkeys|' code-storing keys \citep[\S55.4.3--4]{tikzpgf2.10}.

\end{syntax}

Repeating from (\S\ref{ref:stages}), there are two variants of \index{draw tree}, which differ in
how they use the node boxes created by \index{typeset nodes}: \index{draw tree} includes them using
\cmdname{box}, so they are gone; \index{draw tree'} uses \cmdname{copy}, so they are preserved.
Next, setting \index{draw tree box} will cause the tree to be drawn in the given \TeX\ box.


\begin{syntax}

  \indexitem{style>draw tree method}

  This is the heart of the tree-drawing procedure: it determines which parts of the tree are drawn
  and in what order.  What this style does by default was already described above, but is actually
  best seen from the definition itself:

\lstinputregion{forest.dtx}{draw_tree_method}

This style may be modified by the user, but it is and should be invoked only within \index{draw
  tree}, by the package: \emph{do not execute this style directly!}

The nodewalks occurring in the default definition of this style are, with the exception of
\index{processing order}, not used anywhere else in the package. 

  \indexitem{nodewalk style>draw tree nodes processing order}
  \itemnosep
  \indexitem{nodewalk style>draw tree edges processing order}
  \itemnosep
  \indexitem{nodewalk style>draw tree tikz processing order}

  For each of these nodewalk styles the following holds. If it is defined, it determines which nodes
  / edges / pieces of \index{tikz} code are drawn and in which order.  If any of these styles is not
  defined, its function is taken over by \index{draw tree processing order}.  By default, none of
  them are defined.
  
  \indexitem{nodewalk style>draw tree processing order}

  If this nodewalk is defined, it functions as a fallback for node-, edge- and tikz-code-specific
  nodewalks.  If it is not defined (the default situation), it has its own fallback:
  \index{processing order} (which defaults to \index{tree}).

\indexitem{node key>draw tree node}
\itemnosep
\indexitem{node key>draw tree node'}

Draws the current node at location specified by \index{option>x} and \index{option>y}.  The |'|
variant draws the node even if it's \index{phantom}.

These keys should only be used only within the definition of \index{draw tree method}.

\indexitem{conditional>if node drawn}|=|\meta{nodewalk}\meta{true keylist}\meta{false keylist}

Execute \meta{true keylist} if the node at the end of \meta{nodewalk} was already drawn in the
current invocation of \index{draw tree}; otherwise, execute \meta{false keylist}.


\indexitem{node key>draw tree edge}
\itemnosep
\indexitem{node key>draw tree edge'}

Draws the edge from the current node to its parent, using the information in \index{edge path} and
\index{edge}.

The variant without |'| variant tries to be smart: it draws the edge only if both the current node
and its parent have been drawn in the current invocation of \index{draw tree}.  (This prevents
drawing the edge from the root node and edges from or to phantom nodes.)  The |'| variant is dumb.

These keys should only be used only within the definition of \index{draw tree method}.

\indexitem(draw tree tikz'){style>draw tree tikz}
\itemnosep
\indexitem{node key>draw tree tikz'}

Executes the custom code stored in option \index{tikz} of the current node.

By default, both keys execute the code without performing any checks.  Specifically, \index{tikz}
code of phantom nodes is executed.  To change this behaviour easily, the user can redefine
\index{draw tree tikz}, which is a style; probably, the definition will employ \index{draw tree
  tikz'}.  For example, to execute \index{tikz} code only if the node is not \index{phantom}, write

\begin{lstlisting}
  draw tree tikz/.style={if phantom={draw tree tikz'}{}}
\end{lstlisting}

These keys should only be used only within the definition of \index{draw tree method}.

\end{syntax}



\subsection{Node keys}
\label{ref:node-keys}

\FoRest; is mostly controlled using \PGF;'s key management utility |pgfkeys|
\citep[\S55]{tikzpgf2.10}.  Most of the keys can be given next to the content in the bracket
representation of a tree (\S\ref{ref:bracket}): we call these \emph{node keys}.  Some keys,
notably \emph{nodewalk steps} (\S\ref{ref:nodewalks}), must be used as arguments of specific
commands.

Most node keys perform some operation on the \emph{current node}.  When the keylist given after the
content of a node is processed, the current node is set to that node.  However, the current node can
be temporarily changed, for example by spatial propagators (\S\ref{ref:spatial-propagators}) or,
more genarally, nodewalks (\S\ref{ref:nodewalks}).

The most common function that node keys perform is to set or modify an \emph{option} of the current
node (\S\ref{sec:options-and-registers}), usually to determine the appearance or position of the
node and its edge (\S\ref{sec:formatting-tree}), but there are also several kinds of more exotic
keys like spatial (\S\ref{ref:spatial-propagators}) propagators, which temporarily change the
current node, temporal (\S\ref{ref:temporal-propagators}) propagators, which delay the processing of
the keylist until some other stage in the workflow, keys that dynamically create and move nodes
(\S\ref{ref:dynamic}), keys that control the way \foRest; processes the tree (\S\ref{ref:stages})
etc.  Finally, users can also define their own keys, either by defining |pgfkeys| styles\footnote{%
  Styles are a feature of the \keyname{pgfkeys} package.  They are named keylists, whose usage
  ranges from mere abbreviations through templates to devices implementing recursion.  To define a
  style, use \PGF;'s handler \keyname{.style} \citep[\S55.4.4]{tikzpgf2.10}: \meta{style
    name}\keyname{/.style=}\meta{keylist}.} \citep[\S55.4.4]{tikzpgf2.10} or using \foRest;'s option
declaration mechanism (\S\ref{sec:option-declaring}).

\begin{advise}
\item The style definitions and option declarations given among the other keys in the bracket
  specification are local to the current tree (but note that \foRest;'s keylist processing,
  including temporal and spatial propagation, introduces no groups).  To define globally accessible
  styles and options (well, they are always local to the current \TeX\ group), use
  macro \cmdname{forestset} outside the \index{forest} environment, e.g.\ in the preamble of the
  document.  (Although \index{forestset}\meta{keylist} is currently equivalent to
  \cmdname{pgfkeys}\texttt{\{/forest,}\meta{keylist}\texttt{\}}, don't rely on this as it will
  change in some (near) future version of the package, as there is a plan to introduce namespaces
  \dots)
\end{advise}

By default, unknown keys are assumed to be \TikZ; keys and are forwarded to \index{node options}.
This behaviour can be changed using \index{unknown to}.

The following subsections list the node keys which are not described elsewhere (see above): spatial
propagators (\S\ref{ref:spatial-propagators}) and general-purpose node keys, i.e.\ those which don't
deal with tree formatting (\S\ref{sec:node-keys-various}).


\subsubsection{Spatial propagators}
\label{ref:spatial-propagators}

Spatial propagators pass the given \meta{keylist} to other node(s) in the tree.

Spatial propagation does not change the current node: after visiting the nodes the keys are
propagated to, a spatial propagator (silently, using a so-called fake step) returns to the origin of
the embedded nodewalk.

\FoRest; provides many spatial propagators.  Almost all of them are built from long-form nodewalk
steps using prefix \index{for step}.  This is why the list below is so short: it only documents this
prefix and the exceptions.  For the list of nodewalk steps, see \S\ref{ref:nodewalks}, in particular
\S\ref{ref:single-step-keys} for single-step keys and \S\ref{ref:multi-step-keys} for multi-step
keys.


\begin{syntax}
\indexitem{word prefix=step>propagator>for=\meta{step}}|=|\meta{arg$_1$}|...|\meta{arg$_n$}\meta{keylist: every-step}
\itemnosep
\indexitem[not short]{word prefix=step>propagator>for=\index{nodewalk}}|=|\meta{nodewalk}\meta{keylist: every-step}
\itemnosep
\indexitem[not short]{word prefix=step>propagator>for=\index{nodewalk key>Nodewalk}}|=|\meta{keylist: config}\meta{nodewalk}\meta{keylist: every-step}

  Walks the (single- or multi-step) \meta{step} from the current node and executes the given
  \meta{keylist} at every visited node.  The current node remains unchanged.

  \meta{step} must be a long-form nodewalk step.  If it has any arguments, they
  (\meta{arg$_1$}|...|\meta{arg$_n$}) should be given before every-step \meta{keylist}, with two
  exceptions: embedded nodewalk steps (\index{step>Nodewalk} and \index{nodewalk}) already require
  the \meta{keylist: every-step} argument, so it should be omitted, as it makes no sense to provide
  the every-step keylist twice.

  Examples:
  \begin{itemize}
  \item |for_parent={l_sep+=3mm}|
  \item |for_n=2{circle,draw}|
  \item |for_nodewalk={uu2}{blue}|
  \item |for_tree={s_sep+=1em}|
  \end{itemize}

\long\def\printbigbadforlist#1{%
  {%
    \tikzexternaldisable
    \bracketset{action character=!}%
    \begin{forest}(stages={
        process keylist=given options,
        for root'={
          sort by={>O+t+c{content}},
          %sort=children,
          temptoksa={},
          for sort={children}{
            TeX and memoize/.process=ROw2{temptoksa}{content}{####1\texttt{for\space}\index{step>####2}},
            temptoksa={,\space},
          },
        }
      })
      [!\bigbadforlist[nodewalk][nodewalk'][Nodewalk]]
    \end{forest}%
  }%
}%
\makeatletter
\forest@memoize\printbigbadforlist
\makeatother

{\tolerance=10000
Here's the big list of all spatial propagators built with prefix |for|:
% to update,
% - uncomment \appto\bigbadforlist{[#1]} in define long step in forest.dtx
% - delete line \forest@memo@load {forest@memo@\printbigbadforlist ... in forest-doc.memo
\printbigbadforlist{}.
For details on nodewalk steps, see \S\ref{ref:nodewalks}.

}
  
\indexitem{propagator>for tree'}|=|\meta{keylist 1}\meta{keylist 2} A ``combination'' of
  \index{for step=\index{tree children-first}} and \index{for step=\index{tree}}.

  Passes the keylists to the current node and its the descendants.  At each node, the \meta{keylist
    1} is processed first; then, children are processed recursively; finally, \meta{keylist 2}
  is processed.

  For an example, see the definition of \index{draw brackets} from \reflibrary{linguistics}.
  
\indexitem{propagator>for 1}, \dots\indexdef[not print]{propagator>for 2}\indexdef[not print]{propagator>for 3}\indexdef[not print]{propagator>for 4}\indexdef[not print]{propagator>for 5}\indexdef[not print]{propagator>for 6}\indexdef[not print]{propagator>for 7}\indexdef[not print]{propagator>for 8}, \indexdef{propagator>for 9}|=|\meta{keylist}
  \itemnosep
\indexitem{propagator>for -1}, \dots\indexdef[not print]{propagator>for -2}\indexdef[not print]{propagator>for -3}\indexdef[not print]{propagator>for -4}\indexdef[not print]{propagator>for -5}\indexdef[not print]{propagator>for -6}\indexdef[not print]{propagator>for -7}\indexdef[not print]{propagator>for -8}, \indexdef{propagator>for -9}|=|\meta{keylist}

  Although \index{for step} normally cannot precede short forms of steps, an exception is made
  for \index{ss 1}\index[not print]{ss 2,ss 3,ss 4,ss 5,ss 6,ss 7,ss 8}, \dots, \index{ss 9}. (These keys will work even if the short steps are redefined.)

  |for |$n$ passes the \meta{keylist} to the $n$th child of the current node.  |for -|$n$ starts counting at the last child.
\indexitem{node key>Nodewalk}|=|\meta{keylist: config}\meta{nodewalk}\meta{keylist: every-step}

Configures and executes the \meta{nodewalk}.  This key is a nodekey-space copy of nodewalk step
\index{step>Nodewalk}.

  \begin{advise}
  \item Use this key carefully as it can change the current node!
  \item The envisioned purpose of this key is to change the current node within the every-step
    keylist of (an outer) nodewalk, where only node keys are accepted.  The config defaults
    (independent every-step, shared history) are set to facilitate that purpose. But it can also be
    used as a simple node key, of course.
  \end{advise}
  
\indexitem{node key>node walk}|=|\meta{node walk} \textbf{Deprecated!!!}  Requires
  \index{compat}|=1.0-nodewalk|. Please use \index{for step=\index{nodewalk}} in new code.  From the
  old documentation:

  \begin{quote}
    This is the most general way to use a \meta{node walk}.

    Before starting the \meta{node walk}, key \indexdef{node key>node walk/before walk} is processed.
    Then, the \meta{step}s composing the \meta{node walk} are processed: making a step (normally)
    changes the current node.  After every step, key \indexdef{node key>node walk/every step} is
    processed.  After the walk, key \indexdef{node key>node walk/after walk} is processed.

    \keyname{node walk/before walk}, \keyname{node walk/every step} and \keyname{node walk/after
      walk} are processed with \keyname{/forest} as the default path: thus, \foRest;'s node keys can
    be used normally inside their definitions.

    \begin{advise}
    \item Node walks can be tail-recursive, i.e.\ you can call another node walk from \keyname{node
        walk/after walk} --- embedding another node walk in \keyname{node walk/before walk} or
      \keyname{node walk/every step} will probably fail, because the three node walk styles are not
      saved and restored (a node walk doesn't create a \TeX\ group).
    \item \keyname{every step} and \keyname{after walk} can be redefined even during the walk.
      Obviously, redefining \keyname{before walk} during the walk has no effect (in the current
      walk).
    \end{advise}
  \end{quote}
\end{syntax}


\subsubsection{Various}
\label{sec:node-keys-various}

\begin{syntax}

\indexitem{style>afterthought}|=|\meta{toks}  Provides the afterthought explicitely.

  This key is normally not used by the end-user, but rather called by the bracket parser.  By
  default, this key is a style defined by |afterthought/.style={tikz+={#1}}|: afterthoughts are
  interpreted as (cumulative) \TikZ; code.  If you'd like to use afterthoughts for some other
  purpose, redefine this style --- this will take effect even if you do it in the tree preamble.

\indexitem{node key>also}|=|\meta{keylist} Execute the keys in the given \meta{keylist}.

If we are currently processing node keys, \meta{keylist} should contain node keys.  If we are
in a nodewalk, \meta{keylist} should (or rather, may also) contain nodewalk keys.

For example, to execute, during a nodewalk, a nodewalk keylist stored in register |tempkeylista|,
write |also/.register=|\indexex{tempkeylista}. Note that no embedded nodewalk will be introduced.
  
\indexitem{node key>autoforward}|=|\meta{option}\meta{keylist}, \indexdef{node key>autoforward register}|=|\meta{register}\meta{keylist}
\itemnosep
\indexitem{node key>autoforward'}|=|\meta{option}\meta{keylist}, \indexdef{node key>autoforward register'}|=|\meta{register}\meta{keylist}

Whenever the value of an autoforwarded option or register is given or changed (via an augmented
assignment), \meta{option}|=|\meta{new value} or \meta{register}|=|\meta{new value} is appended to
\meta{keylist}.  This can be used to ``intercept and remember'' \TikZ; options, like \index{option>anchor}
and \index{rotate}.

  The |autoforward'| variant keeps only a single instance of \meta{option} in \meta{keylist}.

  If you ever need to use the non-forwarded version of the key, prefix it with word |autoforwarded|,
  e.g.\ |autoforwarded_rotate|.  Autoforwarding is limited to the current \TeX\ group.

\indexitem{node key>Autoforward}|=|\meta{option}\meta{style definition}, \indexdef{node key>Autoforward register}|=|\meta{register}\meta{style definition}

This is a more generic variant of autoforwarding.  After the value of an option or register
autoforwarded with this key is changed, the style defined by \meta{style definition} is called with
the new option/register value as its argument.

\begin{forestexample}[index={Autoforward,content,node options}]
  \forestset{~Autoforward~={content}{node options={#1}}}
  \begin{forest}
    [red[blue][green]]
  \end{forest}
\end{forestexample}

\indexitem{node key>unautoforward}|=|\meta{option or register} Undoes the autoforwarding of the
option or register made by any of the autoforwarding keys. 

\indexitem{node key>content to}|=|\meta{key} When parsing the bracket representation of the tree,
store the given content using \meta{key}|=|\meta{content}.

\indexitem{node key>copy command key}|=|\meta{pgfkey: source}\meta{pgfkey: destination}
  
  Copies the |pgf| key in a way that |.add code| and |.add style| handlers still work.

\indexitem({{{{{}}}}}){register>default preamble}|=|\meta{keylist}
  \itemnosep
\indexitem{register>preamble}|=|\meta{keylist}

  These registers hold the content of the default preamble and the preamble of the current tree.

  |preamble| is set by the bracket parser. Set |default preamble| outside the \index{forest}
  environment using \index{forestset}.

  As |default preamble| and |preamble| are not styles but keylist registers, the |#| characters do
  not need to be doubled: you can freely copy and paste your keylists between the node options of
  the root node, the preamble and the default preamble. The only difference will be the order of
  execution: first default preamble, then preamble, and finally the root node's options.

\indexitem{node key>save and restore register}|=|\meta{register}\meta{keylist}

Restores the current value of \meta{register} after executing the \meta{keylist}.
  
\indexitem{node key>split}|=|\meta{toks}\meta{separator}\meta{keylist}
  \itemnosep
\indexitem{node key>split option}|=|\meta{option}\meta{separator}\meta{keylist}
  \itemnosep
\indexitem{node key>split register}|=|\meta{register}\meta{separator}\meta{keylist}

Split \meta{toks} or the value of \meta{option} or \meta{register} at occurrences of
\meta{separator} (which must be a single token), and process the keys in \meta{keylist} with the
pieces of the split token list as arguments, in the order given.

\meta{option} can be either a simple \meta{option name} or a \meta{relative node name}\texttt{.}\meta{option name}.

  The difference in the number of split values and given keys is handled gracefully.  If there is
  not enough values, the superfluous keys are not processed; if there are too many values, the last
  key is called repeatedly.

  The keys in \meta{keylist} can be any valid keys, including augmented assignments, non-current
  option assignments, even \index{TeX} or user-defined styles.  Actually, as |split| works by simply
  appending |={|\meta{current value}|}| to the relevant given key, it is possible for the key to be
  a (sub)keylist ending in a simple, non-valued key, like shown below.

  \begin{advise}
  \item Pay attention to |%| characters around the subkeylist. In order for it to actually function
    as a sublist, its braces should be stripped, but this can only happen if no spaces surround it.
  \end{advise}

\begin{forestexample}[point=split option,index={delay,content,split option,process args},label=ex:split option]
  \begin{forest}
    [
      {1,2,3,4}
      [,delay={
        ~split option~=
          {!parent.content}
          {,}
          {
            content',%
            {content+={+},content+}%
          },
          tempcounta'/.process={O+n}{content},
          content+={=},
          content+/.register=tempcounta,
        }
      ]
    ]
  \end{forest}
\end{forestexample}
  
\indexitem{node key>TeX}|=|\meta{toks: \TeX\ code} The given code is executed immediately.

  This can be used for e.g.\ enumerating nodes:
\begin{forestexample}[point=TeX,index={TeX,delay,where option,tier,content,GP1},label=ex:enumerate]
  \newcount\xcount
  \begin{forest} GP1,
    delay={TeX={\xcount=0},
      where tier={x}{TeX={\advance\xcount1},
         content/.expanded={##1$_{\the\xcount}$}}{}}
    [
      [O[x[f]]]
      [R[N[x[o]]]]
      [O[x[r]]]
      [R[N[x[e]]][x[s]]]
      [O[x[t]]]
      [R[N[x]]]
    ]
  \end{forest}
\end{forestexample}

\indexitem{node key>TeX'}|=|\meta{toks: \TeX\ code} This key is a combination of keys \index{TeX}
and \index{TeX''}: the given code is both executed and externalized.

\indexitem{node key>TeX''}|=|\meta{toks: \TeX\ code} The given code is externalized, i.e.\ it will be
executed when the externalized images are loaded.

The image-loading and \keyname{TeX'(')} produced code are intertwined.

\indexitem{node key>typeout}|=|\meta{toks} A \foRest; version of \LaTeX\ macro |\typeout|. Useful
for debugging, trust me on this one.
  
\indexitem(node options){node key>unknown to}|=|\meta{key} Forward unknown keys to \meta{key}.

\begin{advise}
\item Do \emph{not} use handler |.unknown| to deal with unknown keys, as it is used internally by
\foRest;, and is set up to make it possible to set options of non-current nodes (see
\S\ref{sec:option-setting}).
\end{advise}

\indexitem{node key>unknown key error}|=|\meta{keyval} Produces an error.

Write \index{unknown to}|=unknown key error| to produce an error when a key unknown to \foRest; is
used.

\end{syntax}



\subsection{Options and registers}
\label{sec:options-and-registers}

\FoRest; introduces two types of data storage: \emph{node options} (or just \emph{options} for
short) and \emph{registers}.

Options store data related to particular nodes.  Each node has its own set of option values, i.e.\
the value of an option at some node is independent of its value at other nodes: in particular,
setting an option of a node does \emph{not} set this option for the node's descendants.  Register
values are not associated to nodes.

Note that option and register keys share the same ``namespace'' (|pgfkeys| path and |pgfmath|
function names) so it is not possible to have an option and a register of the same name!

\subsubsection{Setting}
\label{sec:option-setting}

The simplest way to set the value of an option or a register is to use the key of the same name.
\begin{syntax}
  \indexitem[index key={@@@opt},form={}]{prefix>assignment>current node=\meta{option}}|=|\meta{value}
  Sets the value of \meta{option} of the current node to \meta{value}.

  Note that option types \index{keylist} and \index{autowrapped toks} redefine this basic key.

  \indexitem[index key={@@@reg},form={}]{prefix>assignment>current node=\meta{register}}|=|\meta{value}
  Sets the value of \meta{register} to \meta{value}.

  Note that register types \index{keylist} and \index{autowrapped toks} redefine this basic key.
\end{syntax}

Options can also be set for the non-current node:
\begin{syntax}
  % \indexitem[index key={@@@.},form={.},+print format={+result={\index(not print){relative node name}\index(not index)[+print format=definition]{relative node name}}},+index format={+result={\meta{relative node name}}}]{prefix>assignment>relative node=\meta{option}}|=|\meta{value}
  \indexitem[index key={@@@.},form={.},+print format={+result={\index{relative node name}}},+index format={+result={\meta{relative node name}}}]{prefix>assignment>relative node=\meta{option}}|=|\meta{value}

  Sets the value of \meta{option} of the node specified by \meta{relative node name} to \meta{value}.

  Notes: \begin{enumerate*}[(i)]
  \item\emph{\meta{value} is evaluated in the context of the current node.}
  \item In general, the resolution of \meta{relative node name} depends on the
    current node; see \S\ref{ref:relative-node-names}.
  \item \meta{option} can also be an ``augmented assignment operator'' (see below) or, indeed, any
    node key.
  \end{enumerate*}  
\end{syntax}

Additional keys for setting and modifying the value of an option or a register exist, depending on
its data type.  Informally, you can think of these keys as \emph{augmented operators} known from
various programming languages.

\begin{syntax}
\indexitem{type>toks} contains \TeX's \meta{balanced text} \citep[275]{texbook}.

  A toks \meta{option} additionally defines the following keys:
  \begin{syntax}
  \indexitem{suffix>augmented assignment=toks>+=\meta{option}}|=|\meta{toks} appends the given \meta{toks} to the
    current value of the option.
    
  \indexitem{prefix>augmented assignment=toks>+=\meta{option}}|=|\meta{toks} prepends the given \meta{toks} to the
    current value of the option.
    
  % \item \index{if in toks option=\meta{toks option}}| =|\meta{toks}\meta{true
  %   keylist}\meta{false keylist} checks if \meta{toks} occurs in the option value; if it does,
  %   \meta{true keylist} are executed, otherwise \meta{false keylist}.
    
  % \item \index{where in toks option=\meta{toks option}}| =|\meta{toks}\meta{true
  %   keylist}\meta{false keylist} is a style equivalent to \index{for step=\index{tree}}|={|\keyname{if in }\meta{option}=\meta{toks}\meta{true keylist}\meta{false keylist}|}|: for every node in
  %   the subtree rooted in the current node, \keyname{if in }\meta{option} is executed in
  %   the context of that node.
  \end{syntax}

\indexitem{type>autowrapped toks} is a subtype of \index{toks} and contains \TeX's \meta{balanced
text} \citep[275]{texbook}. 

  {\rstyle\meta{option}}|=|\meta{toks} of an autowrapped \meta{option} is redefined to
  \meta{option}|/|\index{wrap value}|=|\meta{toks} of a normal \meta{toks} option.
  
  Keyvals \indexdef{suffix>augmented assignment=autowrapped toks>+=\meta{option}}|=|\meta{toks} and
  \indexdef{prefix>augmented assignment=autowrapped toks>+=\meta{option}}|=|\meta{toks} are redefined to
  \index{toks+=\meta{option}}|/|\index{wrap value}|=|\meta{toks} and
  \index{+toks=\meta{option}}|/|\index{wrap value}|=|\meta{toks}, respectively.  The normal toks
  behaviour can be accessed via keys \indexdef{suffix>augmented assignment=autowrapped toks>'=\meta{option}},
  \indexdef{suffix>augmented assignment=autowrapped toks>+'=\meta{option}}, and
  \indexdef[set={print format={result/.expanded=+\forestoption{argument}',pgfkey},index form=+\meta{autowrapped toks option}',index format=pgfkey,index key=+'}]{augmented assignment>+autowrapped toks'=\meta{option}}.

\indexitem{type>keylist} is a subtype of \index{toks} and contains a comma-separated list of
  \meta{key}[|=|\meta{value}] pairs.

  Augmented assignment operators \indexdef{suffix>augmented assignment=keylist>+=\meta{option}} and
  \indexdef{prefix>augmented assignment=keylist>+=\meta{option}} automatically insert a comma
  before/after the appended/prepended material. 
  
  Augmented assignment operator \indexdef{suffix>augmented assignment=keylist>-=\meta{option}}|=|\meta{keylist} deletes the keys
  from keylist \meta{option}.  \meta{keylist} specifies which keys to delete. If a key is given no
  value, all occurrences of that key will be deleted.  If a key is given a value, only occurrences
  with that value will be deleted.  To delete occurrences without value, use special value
  \indexdef{macro>forestnovalue}.  (Note: if you include a key in \meta{keylist} more than once,
  only the last occurrence counts.)

  {\rstyle\meta{option}}|=|\meta{keylist} of a keylist option is redefined to
  \meta{option}\keyname{+}|=|\meta{keylist}.  In other words, keylists behave additively by
  default.  The rationale is that one usually wants to add keys to a keylist.  The usual,
  non-additive behaviour can be accessed by \indexdef{suffix>augmented assignment=keylist>'=\meta{option}}|=|\meta{keylist}.

  Manipulating the keylist option using augmented assignments might have the side-effect of adding
  an empty key to the list.
  
\indexitem{type>dimen} contains a dimension.

  The value given to a dimension option is automatically evaluated by |pgfmath|.  In other words, 
  {\rstyle\meta{option}}|=|\meta{value} is implicitly understood as 
  \meta{option}|/|\index{pgfmath}|=|\meta{value}.

  For a \meta{dimen} option \meta{option}, the following additional keys (``augmented
  assignments'') are defined:
  \begin{syntax}
  \indexitem{suffix>augmented assignment=dimen>+=\meta{option}}|=|\meta{value} is equivalent to \meta{option}|=|\meta{option}|()+|\meta{value}
  \indexitem{suffix>augmented assignment=dimen>-=\meta{option}}|=|\meta{value} is equivalent to \meta{option}|=|\meta{option}|()-|\meta{value}
  \indexitem{suffix>augmented assignment=dimen>*=\meta{option}}|=|\meta{value} is equivalent to \meta{option}|=|\meta{option}|()*|\meta{value}
  \indexitem{suffix>augmented assignment=dimen>:=\meta{option}}|=|\meta{value} is equivalent to \meta{option}|=|\meta{option}|()/|\meta{value}
  \end{syntax}

  The evaluation of \meta{pgfmath} can be quite slow.  There are two tricks to speed things up
  \emph{if} the \meta{pgfmath} expression is simple, i.e.\ just a \TeX\ \meta{dimen}:
  \begin{enumerate}
  \item |pgfmath| evaluation of simple values can be sped up by prepending |+| to the value
    \citep[\S62.1]{tikzpgf2.10};
  \item use the key \indexdef{suffix>augmented assignment=dimen>'=\meta{option}}|=|\meta{value} to invoke a normal \TeX\ assignment.
  \end{enumerate}

  The two above-mentioned speed-up tricks work for the augmented assignments as well.  The keys for
  the second, \TeX-only trick are: \indexdef{suffix>augmented assignment=dimen>'+}, \indexdef{suffix>augmented assignment=dimen>'-}, \indexdef{suffix>augmented assignment=dimen>'*}, \indexdef{suffix>augmented assignment=dimen>':} --- note that for the latter two,
  the value should be an integer.

\indexitem{type>count} contains an integer.

  The additional keys and their behaviour are the same as for the \meta{dimen} options.%
  \indexdef[not print]{suffix>augmented assignment=count>+}%
  \indexdef[not print]{suffix>augmented assignment=count>-}%
  \indexdef[not print]{suffix>augmented assignment=count>*}%
  \indexdef[not print]{suffix>augmented assignment=count>:}%
  \indexdef[not print]{suffix>augmented assignment=count>'}%
  \indexdef[not print]{suffix>augmented assignment=count>'+}%
  \indexdef[not print]{suffix>augmented assignment=count>'-}%
  \indexdef[not print]{suffix>augmented assignment=count>'*}%
  \indexdef[not print]{suffix>augmented assignment=count>':}%

\indexitem{type>boolean} contains $0$ (false) or $1$ (true).

  In the general case, the value given to a \meta{boolean} option is automatically
  parsed by |pgfmath| (just as for \meta{count} and \meta{dimen}): if the computed value is
  non-zero, $1$ is stored; otherwise, $0$ is stored.  Note that |pgfmath| recognizes constants
  |true| and |false|, so it is possible to write \meta{option}|=true| and
  \meta{option}|=false|.

  If key \meta{option} is given no argument, pgfmath evaluation does not apply and a true value is
  set.  To quickly set a false value, use key \indexdef{word prefix=boolean option>>not=\meta{option}} (with no arguments). 
\end{syntax}

\subsubsection{Reading}
\label{sec:option-reading}

Option and register values can be accessed using the four macros listed below, handlers
\index{handler>option} and \index{handler>register} (\S\ref{ref:handlers}) and |pgfmath| functions
(\ref{ref:pgfmath}).

\begin{syntax}
  \indexitem{macro>forestoption}|{|\meta{option}|}|
  \itemnosep
  \indexitem{macro>foresteoption}|{|\meta{option}|}|
  \itemnosep
  \indexitem{macro>forestregister}|{|\meta{register}|}|
  \itemnosep
  \indexitem{macro>foresteregister}|{|\meta{register}|}|

  These macros expand to the value of the given option or register.  Note that
  \index{macro>forestoption} and \index{macro>foresteoption} expand to the value of the given option
  of the \emph{current node}; to access option values of a non-current node, use |pgfmath|
  functions.

  In the context of |\edef|, \cmdname{forestoption} and \cmdname{forestregister} expand precisely to
  the token list of the option value, while \cmdname{foresteoption} and \cmdname{foresteregister}
  fully expand the value.
  
  \begin{advise}
  \item These macros can be useful in \TeX\ code introduced by \index{TeX} or \PGF;'s handler
    |.expanded| \citep[\S55.4.6]{tikzpgf2.10}.
  \end{advise}
\end{syntax}


\subsubsection{Declaring}
\label{sec:option-declaring}

Using the following keys, users can also declare their own options and registers.  The new options
and registers will behave exactly like the predefined ones.

Note that the declaration of an option must provide a default value, while the declaration of a
register must not do that (registers are initialized to the empty string, |0pt| or |0|, as
appropriate for the type).  The default value of an option will be assigned to any newly created
nodes; the existing nodes are not affected.

\begin{syntax}
  \indexitem{node key>declare toks}|=|\meta{option name}\meta{default value}
  Declares a \meta{toks} option.

  \indexitem{node key>declare autowrapped toks}|=|\meta{option name}\meta{default value}
  Declares an \meta{autowrapped toks} option.

  \indexitem{node key>declare keylist}|=|\meta{option name}\meta{default value}
  Declares a \meta{keylist} option.

  \indexitem{node key>declare dimen}|=|\meta{option name}\meta{default value}
  Declares a \meta{dimen} option.  The default value is processed by \index{forestmath}.

  \indexitem{node key>declare count}|=|\meta{option name}\meta{default value}
  Declares a \meta{count} option.   The default value is processed by \index{forestmath}.

  \indexitem{node key>declare boolean}|=|\meta{option name}\meta{default value}
  Declares a \meta{boolean} option.   The default value is processed by \index{forestmath}.
  
  \indexitem{node key>declare toks register}|=|\meta{register name}
  Declares a \meta{toks} register.

  \indexitem{node key>declare autowrapped toks register}|=|\meta{register name}
  Declares an \meta{autowrapped toks} register.
  
  \indexitem{node key>declare keylist register}|=|\meta{register name}
  Declares a \meta{keylist} register.
  
  \indexitem{node key>declare dimen register}|=|\meta{register name}
  Declares a \meta{dimen} register.
  
  \indexitem{node key>declare count register}|=|\meta{register name}
  Declares a \meta{count} register.

  \indexitem{node key>declare boolean register}|=|\meta{register name}
  Declares a \meta{boolean} register.
\end{syntax}

Several scratch registers are predefined:
\begin{syntax}
  \indexitem{register>temptoksa}, \indexdef{register>temptoksb}, \indexdef{register>temptoksc}, \indexdef{register>temptoksd}  Predefined \meta{toks} registers.

  \indexitem{register>tempkeylista}, \indexdef{register>tempkeylistb}, \indexdef{register>tempkeylistc}, \indexdef{register>tempkeylistd}  Predefined \meta{keylist} registers.

  \indexitem{register>tempdima}, \indexdef{register>tempdimb}, \indexdef{register>tempdimc}, \indexdef{register>tempdimd}, \indexdef{register>tempdimx}, \indexdef{register>tempdimy}, \indexdef{register>tempdiml}, \indexdef{register>tempdims}, \indexdef{register>tempdimxa}, \indexdef{register>tempdimya}, \indexdef{register>tempdimla}, \indexdef{register>tempdimsa}, \indexdef{register>tempdimxb}, \indexdef{register>tempdimyb}, \indexdef{register>tempdimlb}, \indexdef{register>tempdimsb}  Predefined \meta{dimen} registers.

  \indexitem{register>tempcounta}, \indexdef{register>tempcountb}, \indexdef{register>tempcountc}, \indexdef{register>tempcountd}  Predefined \meta{count} registers.

  \indexitem{register>tempboola}, \indexdef{register>tempboolb}, \indexdef{register>tempboolc}, \indexdef{register>tempboold}  Predefined \meta{boolean} registers.
\end{syntax}



\subsection{Formatting the tree}
\label{sec:formatting-tree}


\subsubsection{Node appearance}
\label{ref:node-appearance}

The following options apply at stage \index{typeset nodes}. Changing them
afterwards has no effect in the normal course of events. 

\begin{syntax}
\indexitem({{{{{}}}}}){option>align}|=|\index{value of=align>left}\OR\index{value of=align>center}\OR\index{value of=align>right}\OR\meta{toks: tabular header}

  Creates a left/center/right-aligned multiline node, or a tabular node.  In the
  \index{content} option, the lines of the node should separated by |\\| and the columns (if
  any) by |&|, as usual.

  The vertical alignment of the multiline/tabular node can be specified by option \index{base}.

\begin{forestexample}[index={l sep,align,base}]
  \begin{forest} l sep+=2ex
    [special value&actual value\\\hline
      \indexdef{value of=align>left}&||\texttt{@\{\}l@\{\}}\\
      \indexdef{value of=align>center}&||\texttt{@\{\}c@\{\}}\\
      \indexdef{value of=align>right}&||\texttt{@\{\}r@\{\}}\\
      ,~align~=ll,draw
      [top base\\right aligned, ~align~=right,~base~=top]
      [left aligned\\bottom base, ~align~=left,~base~=bottom]
    ]
  \end{forest}
\end{forestexample}

  Internally, setting this option has two effects:
  \begin{enumerate}
  \item The option value (a |tabular| environment header specification) is set.  The special
    values \keyname{left}, \keyname{center} and \keyname{right} invoke styles setting the actual
    header to the value shown in the above example.
    \begin{advise}
    \item If you know that the \keyname{align} was set with a special value, you can easily check
      the value using \index{if in toks option=\index{align}}.
    \end{advise}
  \item Option \index{content format} is set to the following value:
    \begin{lstlisting}
      \noexpand\begin{tabular}[\forestoption{base}]{\forestoption{align}}%
        \forestoption{content}%
      \noexpand\end{tabular}%
    \end{lstlisting}
    As you can see, it is this value that determines that options \keyname{base}, \keyname{align} and
    \keyname{content} specify the vertical alignment, header and content of the table.
  \end{enumerate}

\indexitem(t){option>base}|=|\meta{toks: vertical alignment}

This option controls the vertical alignment of multiline (and in general, \texttt{tabular}) nodes
created with \index{align}.  Its value becomes the optional argument to the \texttt{tabular}
environment.  Thus, sensible values are \indexdef{value of=base>t} (the top line of the table will
be the baseline) and \indexdef{value of=base>b} (the bottom line of the table will be the baseline).
Note that this will only have effect if the node is anchored on a baseline, like in the default
case of \index{option>anchor}|=base|.

For readability, you can use \indexdef{value of=base>top} and \indexdef{value of=base>bottom} instead
of \keyname{t} and \keyname{b}.  (\keyname{top} and \keyname{bottom} are still stored as
\keyname{t} and \keyname{b}.) 

  \indexitem({{{{{}}}}}){option>content}|=|\meta{autowrapped toks} The content of the node.

  Normally, the value of option \keyname{content} is given implicitely by virtue of the special
  (initial) position of content in the bracket representation (see~\S\ref{ref:bracket}).  However,
  the option also be set explicitely, as any other option.

\begin{forestexample}[index={for step,tree,if option,readonly option>n,readonly option>n'},point={content,delay},index={content,delay}]
  \begin{forest}
    delay={for tree={
        if n=1{content=L}
             {if n'=1{content=R}
                      {content=C}}}}
    [[[][][]][[][][]]]
  \end{forest}
\end{forestexample}
  Note that the execution of the \keyname{content} option should usually be delayed: otherwise, the
  implicitely given content (in the example below, the empty string) will override the explicitely
  given content.

\begin{forestexample}[index={for step,tree,if option,readonly option>n,readonly option>n',content},point={content}]
  \begin{forest}
    for tree={
        if n=1{content=L}
             {if n'=1{content=R}
                      {content=C}}}
    [[[][][]][[][][]]]
  \end{forest}
\end{forestexample}

  \indexitem(\forestoption{content}){option>content format}|=|\meta{toks}  

  When typesetting the node under the default conditions (see option \index{node format}), the
  value of this option is passed to the \TikZ; \texttt{node} operation as its \meta{text} argument
  \citep[\S16.2]{tikzpgf2.10}.  The default value of the option simply puts the content in the
  node.

  This is a fairly low level option, but sometimes you might still want to change its value.  If
  you do so, take care of what is expanded when.  Most importantly, if you use a formatting
  command such as |\textbf| in the default setting of \index{node format}, be sure to precede
  it with |\noexpand|. For details, read the documentation of option \index{node format} and
  macros \index{forestoption} and \index{foresteoption}; for an example, see option
  \index{align}.

\indexitem{node key>math content} Changes \index{content format} so that the content of the node
  will be typeset in a math environment.

\indexitem{node key>plain content}  Resets \index{content format} to the default value.

\indexitem{option>node format}|=|\meta{toks}
  \hfill|\noexpand\node(\forestoption{name})|\\
  \mbox{}\hfill|[\forestoption{node options}]{\foresteoption{content format}};|

  The node is typeset by executing the expansion of this option's value in a |tikzpicture|
  environment.

  Important: the value of this option is first expanded using |\edef| and only then executed. Note
  that in its default value, \index{content format} is fully expanded using
  \index{foresteoption}: this is necessary for complex content formats, such as |tabular|
  environments.

  This is a low level option.  Ideally, there should be no need to change its value.  If you do,
  note that the \TikZ; node you create should be named using the value of option \index{option>name};
  otherwise, parent--child edges can't be drawn, see option \index{edge path}. 

\indexitem{node key>node format'}|=|\meta{toks}

Sets \index{node format}, automatically wrapping the given \meta{toks} by
|\noexpand\node(\forestoption{name})| and |;|. Only the node options and content must therefore be
given.
  
\indexitem(anchor=base){option>node options}|=|\meta{keylist}

  When the node is being typeset under the default conditions (see option \index{node format}),
  the content of this option is passed to \TikZ; as options to the 
  \TikZ; |node| operation \citep[\S16]{tikzpgf2.10}.

  This option is rarely manipulated manually: almost all options unknown to \foRest; are
  automatically appended to \keyname{node options}.  Exceptions are (i) \index{label} and
  \index{pin}, which require special attention in order to work; and (ii) \index{option>anchor},
  which is saved in order to retain the information about the selected anchor.

\begin{forestexample}[index={for step,descendants,option>anchor,option>child anchor,option>parent anchor,grow,l sep,tree,propagator>where,delay,content,node options,pgfmath}]
  \begin{forest}
    for descendants={anchor=east,child anchor=east},
    grow=west,anchor=north,parent anchor=north,
    l sep=1cm,
    for tree={~fill=yellow~},where={n()<=3}{~draw=red~}{},
    delay={for tree={content/.pgfmath=~node_options~}}
    [root,rotate=90,
      [,~fill=white~]
      [,~node options'~]
      []
      []
      [,~node options~={~ellipse~}]
    ]
  \end{forest}
\end{forestexample} 

\indexitem(false){option>phantom}|=|\meta{boolean}

  A phantom node and its surrounding edges are taken into account when packing, but not
  drawn. (This option applies in stage \index{draw tree}.)
\begin{forestexample}[point=phantom,index={option>phantom}]
  \begin{forest}
    [VP[DP][V',phantom[V][DP]]]
  \end{forest}
\end{forestexample}

\end{syntax}



\subsubsection{Node position}
\label{ref:ref-node-position}

Most of the following options apply at stage \index{pack}. Changing them afterwards has no effect
in the normal course of events.  (Options \index{option>l}, \index{option>s}, \index{option>x}, \index{y} and
\index{option>anchor} are exceptions; see their documentation for details).

\begin{syntax}

  \indexitem(base){option>anchor}|=|\meta{toks: \foRest; anchor}

  While this option is saved by \foRest;, it is essentially an option of \TikZ;'s |\node| command
  \citep[see][\S16.5.1]{tikzpgf2.10}.  \FoRest; \index{autoforward}s it to keylist option
  \index{node options}, which is passed on to \TikZ;'s |\node| command when the node is typeset.
  (Option |anchor| thus normally applies in stage \index{typeset nodes}.)

  In the \TikZ; code, you can refer to the node's anchor using \FoRest;'s anchor
  \index{anchor>anchor}; this anchor is sometimes also called the node anchor in this
  documentation, to distinguish it clearly from parent and child anchors.

  \meta{toks: \foRest; anchor} can be any \TikZ; anchor.  Additionally, \FoRest; defines several
  tree hierarchy related anchors; for details, see \S\ref{sec:anchors}.

  The effect of setting the node anchor is twofold:
  \begin{itemize}
  \item during packing, the anchors of all siblings are \index{option>l}-aligned;
  \item some \index{calign} methods use node anchors (of the parent and/or certain children) to
    \index{option>s}-align the block of children to the parent.
  \end{itemize}

  \indexitem(center){option>calign}|=|\alternative{child,child edge,midpoint,edge midpoint,fixed
  angles,fixed edge angles}\\\alternative{first,last,center}.
  
  The packing algorithm positions the children so that they don't overlap, effectively computing
  the minimal distances between the node anchors of the children.  This option (\keyname{calign}
  stands for child alignment) specifies how the children are positioned
  with respect to the parent (while respecting the above-mentioned minimal distances).

  The child alignment methods refer to the primary and the secondary child, and to the primary and
  the secondary angle.  These are set using the keys described just after \keyname{calign}.

  \let\outerleftmargin\leftmargin
  \begin{syntax}
  \item\keyname{calign}|=|\indexdef{value of=calign>child} s-aligns the node anchors of the parent and
    the primary child.
  \item\keyname{calign}|=|\indexdef{value of=calign>child edge} s-aligns the parent anchor of the parent 
    and the child anchor of the primary child.
  \item \keyname{calign}|=|\indexdef{value of=calign>first} is an abbreviation for
    |calign=child,calign_child=1|.
  \item \keyname{calign}|=|\indexdef{value of=calign>last} is an abbreviation for
    |calign=child,calign_child=-1|.
  \item\keyname{calign}|=|\indexdef{value of=calign>midpoint} s-aligns the parent's node anchor and the
    midpoint between the primary and the secondary child's node anchor.
  \item\keyname{calign}|=|\indexdef{value of=calign>edge midpoint} s-aligns the parent's parent anchor
    and the midpoint between the primary and the secondary child's child anchor.
  \item \keyname{calign}|=|\indexdef{value of=calign>center} is an abbreviation for\\
    |calign=midpoint,| |calign_primary_child=1,| |calign_secondary_child=-1|. 
\begin{forestexample}
  \begin{forest}
    [center,calign=center[1]
      [first,calign=first[A][B][C]][3][4][5][6]
      [last,calign=last[A][B][C]][8]]
  \end{forest}
\end{forestexample}
  \item\keyname{calign}|=|\indexdef{value of=calign>fixed angles}: The angle between the direction of
  growth at the current node (specified by option \index{grow}) and the line through the node
  anchors of the parent and the primary/secondary child will equal the primary/secondary angle.

  To achieve this, the block of children might be spread or further distanced from the parent.
  \item\keyname{calign}|=|\indexdef{value of=calign>fixed edge angles}: The angle between the direction of
  growth at the current node (specified by option \index{grow}) and the line through the
  parent's parent anchor and the primary/secondary child's child anchor will equal the
  primary/secondary angle.
  
  To achieve this, the block of children might be spread or further distanced from the parent.
\begin{forestexample}[point=calign,index={calign,fixed edge angles,calign primary angle,calign secondary angle,for step,tree,option>l},index>={!}]
  \begin{forest}
    calign=fixed edge angles,
    calign primary angle=-30,calign secondary angle=60,
    for tree={l=2cm}
    [CP[C][TP]]
    \draw[dotted] (!1) -| coordinate(p) () (!2) -| ();
    \path ()--(p) node[pos=0.4,left,inner sep=1pt]{-30};
    \path ()--(p) node[pos=0.1,right,inner sep=1pt]{60};
  \end{forest}
\end{forestexample}
  \end{syntax}
\indexitem{node key>calign child}|=|\meta{count} is an abbreviation for \index{calign primary
  child}|=|\meta{count}.
\indexitem(1){option>calign primary child}|=|\meta{count} Sets the primary child.  
  (See \index{calign}.)

  \meta{count} is the child's sequence number.  Negative numbers start counting at the last child.
\indexitem(-1){option>calign secondary child}|=|\meta{count} Sets the secondary child. 
  (See \index{calign}.)

  \meta{count} is the child's sequence number.  Negative numbers start counting at the last child.
\indexitem{node key>calign angle}|=|\meta{count} is an abbreviation for: \index{calign primary
  angle}|=-|\meta{count}, \index{calign secondary angle}|=|\meta{count}.
\indexitem(-35){option>calign primary angle}|=|\meta{count} Sets the primary angle.
  (See \index{calign}.) 
\indexitem(35){option>calign secondary angle}|=|\meta{count} Sets the secondary angle. 
  (See \index{calign}.)
\indexitem{node key>calign with current} s-aligns the node anchors of the current node and its
  parent.  This key is an abbreviation for:\indexex[not print]{wrap pgfmath arg,calign,child,calign primary child}
\begin{lstlisting}
  for parent/.wrap pgfmath arg={calign=child,calign primary child=##1}{n}.
\end{lstlisting}
\indexitem{node key>calign with current edge} s-aligns the child anchor of the current node and the
  parent anchor of its parent.  This key is an abbreviation for:\indexex[not print]{wrap pgfmath arg,calign,child edge,calign primary child}
\begin{lstlisting}
  for parent/.wrap pgfmath arg={calign=child edge,calign primary child=##1}{n}
\end{lstlisting}

  \indexitem(tight){option>fit}|=|\alternative{tight,rectangle,band}

\begin{forestexample}[layout=export,basicstyle=\footnotesize\ttfamily]
  \makeatletter\tikzset{use path/.code={\tikz@addmode{\pgfsyssoftpath@setcurrentpath#1}
    \appto\tikz@preactions{\let\tikz@actions@path#1}}}\makeatother
  \forestset{show boundary/.style={
    before drawing tree={get min s tree boundary=\minboundary, get max s tree boundary=\maxboundary},
    tikz+={\draw[red,use path=\minboundary]; \draw[red,use path=\maxboundary];}}}
\end{forestexample}
\input{\jobname.tmp}

This option sets the type of the (s-)boundary that will be computed for the subtree rooted in the
node, thereby determining how it will be packed into the subtree rooted in the node's parent.
There are three choices:\footnote{Below is the definition of style \keyname{show boundary}. The
\keyname{use path} trick is adjusted from \TeX\ Stackexchange question
\href{http://tex.stackexchange.com/questions/26382/calling-a-previously-named-path-in-tikz}{Calling
a previously named path in tikz}.

\box\codebox}
  \begin{itemize}
  \item\keyname{fit}|=|\indexdef{value of=fit>tight}: an exact boundary of the node's subtree is computed,
    resulting in a compactly packed tree.  Below, the boundary of subtree L is drawn.
\begin{forestexample}[point={fit,tight},index={fit,{value of=fit>tight},delay,for step,tree,option>name,content,pgfmath}]
  \begin{forest}
    delay={for tree={name/.pgfmath=content}}
    [root
      [L,fit=tight, % default
         show boundary
        [L1][L2][L3]]
      [R]
    ]
  \end{forest}
\end{forestexample}
\makeatletter\tikzset{use path/.code={%
  \tikz@addmode{\pgfsyssoftpath@setcurrentpath#1}%
  \appto\tikz@preactions{\let\tikz@actions@path#1}%
  }}\makeatother
\item\keyname{fit}|=|\indexdef{value of=fit>rectangle}: puts the node's subtree in a rectangle and effectively
  packs this rectangle; the resulting tree will usually be wider.
\begin{forestexample}[point={fit,rectangle},index={fit,{value of=fit>rectangle},delay,for step,tree,option>name,content,pgfmath}]
  \begin{forest}
    delay={for tree={name/.pgfmath=content}}
    [root
      [L,fit=rectangle,
         show boundary
        [L1][L2][L3]]
      [R]
    ]
  \end{forest}
\end{forestexample}
\item\keyname{fit}|=|\indexdef{value of=fit>band}: puts the node's subtree in a rectangle of ``infinite
  depth'': the space under the node and its descendants will be kept clear.
\begin{forestexample}[point={fit,band},index={fit,{value of=fit>band},delay,for step,tree,option>name,content,pgfmath}]
  \begin{forest}
    delay={for tree={name/.pgfmath=content}}
    [root
      [L[L1][L2][L3]]
      [C,fit=band]
      [R[R1][R2][R3]]
    ]
    \draw[thin,red]
      (C.south west)--(C.north west)
      (C.north east)--(C.south east);
    \draw[thin,red,dotted]
      (C.south west)--+(0,-1)
      (C.south east)--+(0,-1);
  \end{forest}
\end{forestexample}
  \end{itemize}

\indexitem(270){option>grow}|=|\meta{count}, \indexdef{node key>grow'}|=|\meta{count},
  \indexdef{node key>grow''}|=|\meta{count}

  The direction of the tree's growth at the node.

  The growth direction is understood as in \TikZ;'s tree library \citep[\S18.5.2]{tikzpgf2.10}
  when using the default growth method: the (node anchor's of the) children of the node are placed
  on a line orthogonal to the current direction of growth. (The final result might be different,
  however, if \index{option>l} is changed after packing or if some child undergoes tier alignment.)

  This option is essentially numeric (|pgfmath| function \keyname{grow} will always return an
  integer), but there are some twists.  The growth direction can be specified either numerically
  or as a compass direction (|east|, |north east|, \dots).  Furthermore, like in \TikZ;, setting
  the growth direction using key \keyname{grow} additionally sets the value of option
  \index{reversed} to |false|, while setting it with \keyname{grow'} sets it to |true|; to
  change the growth direction without influencing \index{reversed}, use key \index{grow''}.

  Between stages \index{pack} and \index{compute xy}, the value of \keyname{grow} should not
  be changed.

\begin{forestexample}[index={delay,where in toks option,content,for step,current,grow,grow',grow'',pgfmath}]
  \begin{forest}
    delay={where in content={~grow~}{
        for current/.pgfmath=content,
        content=\texttt{#1}
      }{}
    }
    [{~grow~=south}
      [{~grow'~=west}[1][2][3]
        [{~grow''~=90}[1][2][3]]]
      [2][3][4]
      [{~grow~=east}[1][2][3]
        [{~grow''~=90}[1][2][3]]]]
  \end{forest}
\end{forestexample}

\indexitem(false){option>ignore}|=|\meta{boolean}

If this option is set, the packing mechanism ignores the node, i.e.\ it pretends that the node has
no boundary. Note: this only applies to the node, not to the tree.

Maybe someone will even find this option useful for some reason \dots

\indexitem(false){option>ignore edge}|=|\meta{boolean}

If this option is set, the packing mechanism ignores the edge from the node to the parent, i.e.\
nodes and other edges can overlap it. (See \S\ref{sec:bugs} for some problematic situations.)

\begin{forestexample}[index={ignore edge,option>l,dimen*=l}]
  \begin{forest}
    [A[B[B][B][B][B]][C
      [\texttt{not ignore edge},l*=2]]]
  \end{forest}
  \begin{forest}
    [A[B[B][B][B][B]][C
      [\texttt{ignore edge},l*=2,~ignore edge~]]]
  \end{forest}
\end{forestexample}

\indexitem{option>l}|=|\meta{dimen} The l-position of the node, in the parent's ls-coordinate system.  (The
origin of a node's ls-coordinate system is at its (node) anchor.  The l-axis points in the
direction of the tree growth at the node, which is given by option \index{grow}. The s-axis is
orthogonal to the l-axis; the positive side is in the counter-clockwise direction from |l| axis.)

The initial value of \keyname{l} is set from the standard node.  By default, it equals:
\[\index{l sep}+2\cdot\mbox{\texttt{outer ysep}}+\mbox{total
height(standard node)}\]

The value of \keyname{l} can be changed at any point, with different effects.  
\begin{itemize}
\item The value of \keyname{l} at the beginning of stage \index{pack} determines the minimal
  l-distance between the anchors of the node and its parent.  Thus, changing \keyname{l} before
  packing will influence this process.  (During packing, \keyname{l} can be increased due to
  parent's \index{l sep}, tier alignment, or \index{calign} methods
  \index{fixed angles} and \index{fixed edge angles}.

\item Changing \keyname{l} after packing but before stage \index{compute xy} will result in a
  manual adjustment of the computed position.  (The augmented assignment operators can be useful here.)

\item Changing \keyname{l} after the absolute positions have been computed has no effect in the
  normal course of events.
\end{itemize}

\indexitem{option>l sep}|=|\meta{dimen} The minimal l-distance between the node and its
descendants.

This option determines the l-distance between the \emph{boundaries} of the node and its descendants,
not node anchors.  The final effect is that there will be a \keyname{l sep} wide band,
in the l-dimension, between the node and all its descendants.

The initial value of \keyname{l sep} is set from the standard node and equals
\[\mbox{height}(\mbox{strut})+\mbox{\texttt{inner ysep}}\]

Note that despite the similar name, the semantics of \keyname{l sep} and \keyname{s sep} are
quite different.

\indexitem(false){option>reversed}|=|\meta{boolean}

If |false|, the children are positioned around the node in the counter-clockwise direction; if
|true|, in the clockwise direction.  See also \index{grow}. 

\indexitem(0){option>rotate}|=|\meta{count}

This option is saved and \index{autoforward}ed to \TikZ;'s |\node| command via \index{node options}.

\indexitem{option>s}|=|\meta{dimen} The s-position of the node, in the parent's ls-coordinate system.
(The origin of a node's ls-coordinate system is at its (node) anchor.  The l-axis points in the
direction of the tree growth at the node, which is given by option \index{grow}.  The s-axis is
orthogonal to the l-axis; the positive side is in the counter-clockwise direction from |l| axis.)

The value of \keyname{s} is computed in stage \index{pack stage} and used in stage \index{compute xy
  stage}, so it only makes sense to (inspect and) change it in \index{before computing xy} and
during packing (\index{before packing node} and \index{after packing node}).  \emph{Any value given
  before packing is overridden, and changing the value after computing xy has no effect.}

For example, consider the manual correction below.  By default, B is closer to A than C because
packing proceeds from the first to the last child --- the position of B would be the same if there
was no C.  Adjusting \keyname{s} at the right moment, it is easy to center B between A and C.
\begin{forestexample}[tree bin=minipage,point=s,index={before computing xy,option>s}]
  \begin{forest}
    [no manual correction of B
      [A[1][2][3][4]]
      [B]
      [C[1][2][3][4]]
    ]
  \end{forest}
  
   \begin{forest}
    [manual correction of B
      [A[1][2][3][4]]
      [B,before computing xy={s/.average={s}{siblings}}]
      [C[1][2][3][4]]
    ]
  \end{forest}
\end{forestexample}

\indexitem{option>s sep}|=|\meta{dimen}

The subtrees rooted in the node's children will be kept at least \keyname{s sep} apart in the
s-dimension.  Note that \keyname{s sep} is about the minimal distance between node
\emph{boundaries}, not node anchors.

The initial value of \keyname{s sep} is set from the standard node and equals
$2\cdot\mbox{\texttt{inner xsep}}$. 

Note that despite the similar name, the semantics of \keyname{s sep} and \keyname{l sep} are
quite different.

\indexitem({{{{{}}}}}){option>tier}|=|\meta{toks}

Setting this option to something non-empty ``puts a node on a tier.''  All the nodes on the same
tier are aligned in the l-dimension.

Tier alignment across changes in growth direction is impossible.  In the case of incompatible
options, \foRest; will yield an error.

Tier alignment also does not work well with \index{calign}|=|\index{fixed angles} and \index{calign}|=|\index{fixed edge angles}, because these child alignment methods may change the
l-position of the children.  When this might happen, \foRest; will yield a warning.

\indexitem{option>x}=\meta{dimen}
\vspace{-\parskip}
\indexitem{option>y}=\meta{dimen}

\keyname{x} and \keyname{y} are the coordinates of the node in the ``normal'' (paper) coordinate
system, relative to the root of the tree that is being drawn.  So, essentially, they are absolute
coordinates.

The values of \keyname{x} and \keyname{y} are computed in stage \index{compute xy}.  It only
makes sense to inspect and change them (for manual adjustments) afterwards (normally, in the
\index{before drawing tree} hook, see \S\ref{ref:stages}.)  \keyname{x} and \keyname{y} of the
(formal) root node are exceptions, as they are not changed in stage \index{compute xy}.
\begin{forestexample}[label=ex:adjustxy,index={y,dimen-,grow',option>l,for step,tree,before drawing tree}]
  \begin{forest}
    for tree={grow'=45,l=1.5cm}
    [A[B][C][D,before drawing tree={~y-~=4mm}[1][2][3][4][5]][E][F]]
  \end{forest}
\end{forestexample}

\end{syntax}

\subsubsection{Edges}
\label{ref:ref-edge}

These options determine the shape and position of the edge from a node to its parent.  They apply
at stage \index{draw tree}.

\begin{syntax}
\indexitem({{{{{}}}}}){option>child anchor}|=|\meta{toks: \foRest; anchor} See \index{option>parent anchor}.

\indexitem(draw){option>edge}|=|\meta{keylist}

  When \index{edge path} has its default value, the value of this option is passed as options to
  the \TikZ; |\path| expression used to draw the edge between the node and its parent.

  Also see key \index{no edge}.

\begin{forestexample}[point=edge,index={edge,no edge,for step,tree,grow',option>l,option>anchor,option>child anchor}]
  \begin{forest} for tree={grow'=0,l=2cm,anchor=west,child anchor=west},
    [root
      [normal]
      [none,~no~ edge]
      [dotted,edge=dotted]
      [dashed,edge=dashed]
      [dashed,edge={dashed,red}]
    ]
  \end{forest}
\end{forestexample}

\indexitem({{{{{}}}}}){option>edge label}|=|\meta{toks: \TikZ; code}

When \index{edge path} has its default value, the value of this option is used at the end of
the edge path specification to typeset a node (or nodes) along the edge.

The packing mechanism is not sensitive to edge labels.

\begin{forestexample}[index={edge label}]
  \begin{forest}
    [VP
      [V,~edge label~={node[midway,left,font=\scriptsize]{head}}]
      [DP,~edge label~={node[midway,right,font=\scriptsize]{complement}}]
    ]
  \end{forest}
\end{forestexample}

\indexitem{option>edge path}|=|\meta{toks: \TikZ; code}
 \hfill |\noexpand\path[|\index{forestoption}|{|\index{edge}|}]|\\
 \mbox{}\hfill |(|\index>{!}|u.|\index{anchor>parent anchor}|)--(.|\index{anchor>child anchor}|)|\index{forestoption}|{|\index{edge label}|};|

This option contains the code that draws the edge from the node to its parent.  By default, it
creates a path consisting of a single line segment between the node's \index{option>child anchor} and
its parent's \index{option>parent anchor}. Options given by \index{edge} are passed to the path; by
default, the path is simply drawn.  Contents of \index{edge label} are used to potentially place
a node (or nodes) along the edge.

When specifying the edge path, the values of options \index{edge} and \index{edge label} can be
used.  Furthermore, two anchors, \index{anchor>parent anchor} and \index{anchor>child anchor}, are defined, 
to facilitate access to options \index{option>parent anchor} and \index{option>child anchor} from the \TikZ; code.

The node positioning algorithm is sensitive to edges, i.e.\ it will avoid a node overlapping an
edge or two edges overlapping. However, the positioning algorithm always behaves as if the
\keyname{edge path} had the default value --- \emph{changing the \keyname{edge path} does not
influence the packing!}  Sorry.  (Parent--child edges can be ignored, however: see option
\index{ignore edge}.)

\indexitem{node key>edge path'}|=|\meta{toks: \TikZ; code}

Sets \index{edge path}, automatically wrapping the given path by
|\noexpand\path[\forestoption{edge}]| and |\forestoption{edge label};|.

\indexitem({{{{{}}}}}){option>parent anchor}|=|\meta{toks: \foRest; anchor} (Information also applies to
option \index{option>child anchor}.)

\FoRest; defines anchors \index{anchor>parent anchor} and
\index{anchor>child anchor} (which work only for \foRest; and not also \TikZ;
nodes, of course) to facilitate reference to the desired endpoints of child--parent edges.
Whenever one of these anchors is invoked, it looks up the value of the \keyname{parent anchor} or
\keyname{child anchor} of the node named in the coordinate specification, and forwards the request
to the (\TikZ;) anchor given as the value.

The intended use of the two anchors is chiefly in \index{edge path} specification, but they can
used in any \TikZ; code.
\begin{forestexample}[index={anchor>parent anchor,anchor>child anchor,for step,tree},index>={!}]
  \begin{forest}
    for tree={~parent anchor~=south,~child anchor~=north}
    [VP[V][DP]]
    \path[fill=red] (.parent anchor) circle[radius=2pt];
    \path[fill=blue] (!1.child anchor) circle[radius=2pt]
                     (!2.child anchor) circle[radius=2pt];
  \end{forest}
\end{forestexample}

The empty value (which is the default) is interpreted as in \TikZ;: as an edge to the appropriate
border point.  See also \S\ref{sec:anchors} for a list of additional anchors defined by \foRest;.

\indexitem{node key>no edge} Clears the edge options (\index{edge}|'={}|) and sets \index{ignore
edge}.

\end{syntax}

\subsubsection{Information about node}
\label{ref:node-info}
\label{ref:readonly-options}

The values of these options provide various information about the tree and its nodes.

\begin{syntax}
\indexitem{node key>alias}|=|\meta{toks} 
\itemnosep
\indexitem{node key>alias'}|=|\meta{toks} Sets the alias for the node's name.

  Unlike \index{option>name}, \keyname{alias} is \emph{not} an option: you cannot e.g.\ query it's
  value via a |pgfmath| expression.

  If the given alias clashes with an existing node name, |alias| will yield an error, while |alias'|
  will silently rename the node with this name to its default value (|node@|\meta{id}).

  Aliases can be used as the \meta{forest node name} part of a relative node name and as the
  argument to the \index{step>name} step of a node walk.  The latter includes the usage
  as the argument of the \index{for step=\index{step>name}} propagator.

  Technically speaking, \foRest; alias is \emph{not} a \TikZ; alias!  However, you can still use
  it as a ``node name'' in \TikZ; coordinates, since \foRest; hacks \TikZ;'s implicit node
  coordinate system to accept relative node names; see \S\ref{ref:forest-cs}.
  
\indexitem{readonly option>id}|=|\meta{count} The internal id of the node.

\indexitem{readonly option>level}|=|\meta{count}  The hierarchical level of the node.  The root is on level $0$. 

\indexitem{readonly option>max x}|=|\meta{dimen} \vspace{-\parskip}
\indexitem{readonly option>max y}|=|\meta{dimen} \vspace{-\parskip}
\indexitem{readonly option>min x}|=|\meta{dimen} \vspace{-\parskip}
\indexitem{readonly option>min y}|=|\meta{dimen}
  Measures of the node, in the shape's coordinate system
  \citep[see][\S16.2,\S48,\S75]{tikzpgf2.10} shifted so that the node anchor is at the origin.

  In |pgfmath| expressions, these options are accessible as |max__x|, |max__y|, |min__x| and |min__y|.

\indexitem{readonly option>n}|=|\meta{count}  The child's sequence number in the list of its parent's
  children. 

  The enumeration starts with 1.  For a geometric root, \keyname{n} equals $0$. 

\indexitem{readonly option>n'}|=|\meta{count}  Like \index{readonly option>n}, but starts counting at the last child.

  In |pgfmath| expressions, this option is accessible as |n__|.

\indexitem{option>name}|=|\meta{toks} \hfill \texttt{node@}\meta{id}
\itemnosep
\indexitem{node key>name'}|=|\meta{toks} Sets the name of the node.

The expansion of \meta{toks} becomes the \meta{forest node name} of the node.  The \TikZ; node
created from the \foRest; node will get the name specified by this option.

Node names must be unique.  If a node with the given name already exists, |name| will yield an
error, while |name'| will silently rename the node with this name to its default (|node@|\meta{id})
value.  Use an empty argument to reset the node's name to its default value.

  
\indexitem{readonly option>n children}|=|\meta{count} The number of children of the node.
  
  In |pgfmath| expressions, this option is accessible as |n__children|.
\end{syntax}

  
\subsubsection{Various}

\begin{syntax}
\indexitem{node key>baseline} The node's anchor becomes the baseline of the whole tree
  \citep[cf.][\S69.3.1]{tikzpgf2.10}.

  In plain language, when the tree is inserted in your (normal \TeX) text, it will be vertically
  aligned to the anchor of the current node.

  Behind the scenes, this style sets the alias of the current node to \keyname{forest@baseline@node}.
  {\tikzexternaldisable
\begin{forestexample}[index={baseline,use as bounding box'}]
  Baseline at the
  \begin{forest}
    [parent,~baseline~,use as bounding box'
      [child]]
  \end{forest}
  and baseline at the
  \begin{forest}
    [parent
      [child,~baseline~,use as bounding box']]
  \end{forest}.
\end{forestexample}}

\indexitem>{tikz key>fit to}|=|\meta{nodewalk} Fits the \TikZ; node to the nodes in the given
  \meta{nodewalk}.

This key should be used like \keyname{/tikz/fit} of the \TikZ;'s fitting library
\citep[see][\S34]{tikzpgf2.10}: as an option to \emph{\TikZ;'s} |node| operation, the obvious
restriction being that \keyname{fit to} must be used in the context of some \foRest; node.
For an example, see footnote~\ref{fn:fit-to-tree}.

This key works by calling \keyname{/tikz/fit} and providing it with the the coordinates of the
subtree's boundary.

The \meta{nodewalk} inherits its history from the outer nodewalk (if there is one).  Its every-step
keylist is empty.

\indexitem{node key>get min s tree boundary}|=|\meta{cs} \vspace{-\parskip}
\indexitem{node key>get max s tree boundary}|=|\meta{cs}

Puts the boundary computed during the packing process into the given \meta{cs}.  The boundary is
in the form of \PGF; path.  The |min| and |max| versions give the two sides of the node.  For an
example, see how the boundaries in the discussion of \index{fit} were drawn.

\indexitem{option>label}|=|\meta{toks: \TikZ; node}  The current node is labelled by a \TikZ; node.

  The label is specified as a \TikZ; option \texttt{label} \citep[\S16.10]{tikzpgf2.10}.
  Technically, the value of this option is passed to \TikZ;'s as a late option
  \citep[\S16.14]{tikzpgf2.10}.  (This is so because \foRest; must first typeset the nodes
  separately to measure them (stage \index{typeset nodes}); the preconstructed nodes are inserted
  in the big picture later, at stage \index{draw tree}.)  Another option with the same
  technicality is \index{pin}. 
  
\indexitem{option>pin}|=|\meta{toks: \TikZ; node}  The current node gets a pin, see
  \citep[\S16.10]{tikzpgf2.10}. 
¸
  The technical details are the same as for \index{label}.


\indexitem{node key>use as bounding box} The current node's box is used as a bounding box for the
  whole tree.

  \indexitem{node key>use as bounding box'} Like \index{use as bounding box}, but subtracts the
  (current) inner and outer sep from the node's box.  For an example, see \index{baseline}.
  
  \indexitem({{{{{}}}}}){option>tikz}|=|\meta{toks: \TikZ; code}  ``Decorations.''

  The code given as the value of this option will be included in the |tikzpicture| environment used
  to draw the tree.  By default, the code is included after all nodes of the tree have been drawn,
  so it can refer to any node of the tree (furthermore, relative node names can be used to refer to
  nodes of the tree, see \S\ref{ref:relative-node-names}) and the code given to various nodes is
  appended in a depth-first, parent-first fashion.  See \S\ref{sec:draw-tree} for details and
  customization.

  By default, bracket parser's afterthoughts feed the value of this option.  See
  \index{afterthought}. 
  
\end{syntax}  



\subsection{Nodewalks}
\label{ref:nodewalks}

A \emph{nodewalk} is a sequence of \emph{steps} describing a path through the tree.  Most steps
are defined relative to the current node, for example \index{step>parent} steps to the parent of the
current node, and \index{step>n}|=2| steps to the second child of the current node, where ``to make a
step'' means to change the current node.  Thus, nodewalk |parent,_parent,_n=2| describes the path
which first steps to the parent of the \emph{origin} node, then to its grandparent and finally to
the second child of the origin's grandparent.

The origin of the nodewalk depends on how the nodewalk is invoked.  When used after the \index>{!}
in a relative node name (\S\ref{ref:relative-node-names}), the origin is the node with the name
given before \index>{!}; when invoked by a spatial propagator such as \index{for
  step=\index{nodewalk}} (\S\ref{ref:spatial-propagators}), the origin is the current node; when
invoked within another (outer) nodewalk, the origin is the current node of the outer nodewalk.

Formally, a \meta{nodewalk} is a list of |pgfkeys| key--value pairs.  Steps in a nodewalk are thus
separated by commas.  However, \foRest; also recognizes \emph{short-form} steps, whose names consist
of a single character and which do not need to be separated by a comma.  For example, nodewalk
|parent,_parent,_n=2| can be concisely written as |uu2|.  Long and short forms can be mixed freely,
like this: |next,_uu2,_previous|.

Besides nodewalk keys, a \meta{nodewalk} can also contain node keys (or
even \TikZ; keys).\footnote{The precise algorithm for keyname resulotion in nodewalks is as follows.
\begin{itemize}
\item First, \foRest; searches for the given \meta{keyname} in the \index{path>forest/nodewalk}
  path.  If found (a long-form step or a nodewalk style), it is executed.
\item Next, it is checked whether \meta{keyname} is a sequence of short-form steps; is so, they are
  executed.
\item Otherwise, \meta{key} is executed in the \keyname{/forest} path.  This includes both
  \foRest;'s and \TikZ;'s keys.  The latter are usually forwarded to \TikZ; via \index{node
    options}.
\end{itemize}
There are some clashes between node key and nodewalk step names. For example, \keyname{l} is both a
\meta{dimen} option and a short form of the step to the last child. According to the rules above,
the nodewalk step will take precedence in case of a clash. Use nodewalk key \index{options} to
execute a clashing node key.} These keys do their usual function, but within the context of the
current node of the nodewalk: |parent, s=2em,| |parent, text=red| sets the parent's |s| to 2em and
the grandparent's text color to red.  It is worth noting that node keys include \index{TeX}, which
makes it possible to execute any \TeX\ code while nodewalking.

Some steps target a single node, like above-mentioned \index{step>parent} and \index{step>n}.
Others, called multi-steps, describe mini-walks themselves: for example \index{step>children} visits
each child of the node in turn, and \index{tree} visits each of the node's descendants (including
the node itself).  The path of many steps is determined by the geometric relations of the tree, or
the value of some option.  However, there are also keys for embedding nodewalks (\index{nodewalk
  key>nodewalk}, \index{branch}, etc.), saving and loading nodewalks, sorting them, or even
re-walking the history of steps made (like in a web browser).\footnote{Note that nesting operation
  (\S\ref{ref:nodewalk-operations}) and history (\S\ref{ref:nodewalk-history}) steps, or embedding
  nodewalks under these steps doesn't work, for most combinations, as many of them internally
  manipulate nodewalk history.} Finally, if all this is not enough, you can define your own steps,
see \S\ref{ref:defining-steps}.

Each nodewalk has an associated \emph{every-step keylist}: a keylist of node keys\footnote{When
  executing the \index{register>every step} keylist, \foRest; switches into the
  \index{path>forest} path, which makes it impossible to directly include a nodewalk into the
  every-step keylist.  The reason is performance.  Every time a \index{path>forest/nodewalk} key
  is not found, the short-form nodewalk recognition algorithm is executed, and this algorithm is
  slow.  As \index{register>every step} is used a lot (it is for example used every invocation of
  every spatial propagator) and the keys in \index{register>every step} are usually node options
  from \index{path>forest} path, \foRest; would spend way too much time checking if a given node
  option is actually a short-form nodewalk.

  If you need to execute nodewalk keys within the every-step keylist, use node key \index{node
    key>Nodewalk}.} which get executed after each step of the nodewalk.  The every-step keylist of
the current nodewalk is contained in register \index{register>every step} and can be changed at any
point during the nodewalk.  Its value at the start of the nodewalk depends on how the nodewalk was
invoked.  In most cases (e.g.\ \index{step>nodewalk} or prefix \index{for step}-based spatial
propagators), it is given explicitely as an argument to the key that executes the nodewalk.
However, see \index{step>Nodewalk} option \index{option of=Nodewalk>every step} for information on
how the every-step keylist of an embedded nodewalk can interact with the every-step keylist of its
parent nodewalk.

Each nodewalk step can be either \emph{real} or \emph{fake}.  Fake steps only change the current
node.  Real steps also trigger execution of the every-step keylist and update of history.  Fake
steps are sometimes useful as a ``computational tool''.  They can be introduced explicitely using
\index{nodewalk key>fake}; some other keys (like several history nodewalk keys,
\S\ref{ref:nodewalk-history}) introduce fake steps implicitely.

In some cases, the nodewalk might step ``out of the tree''.  (Imagine using \index{step>parent} at the
root of the tree, or \index{readonly option>n}|=42| at a node with less that 42 children.)  Our official term will
be that the nodewalk stepped on an \emph{invalid node}; what happens formally is that the current
node is changed to the node with \index{readonly option>id}|=0|.  Normally, such an event raises an
error.  However, the full story is told by \index{nodewalk key>on invalid}.

Nodewalks can be hard to follow, especially when designing styles. \FoRest; does its best to
help. First, it logs the nodewalk stack in case of error.  Second, if package option
\index{debug}|=|\index{option of=debug>nodewalks} is given, it logs every step made.


\subsubsection{Invoking (embedded) nodewalks}
\label{ref:embedded-walks}

There are many ways to invoke a nodewalk. For example, several keys, like \index{fit to}, and
aggregate functions (\S\ref{ref:aggregate-functions}) expect a \meta{nodewalk} argument.  This
section lists keys which can be used to explicitely invoke a nodewalk.

The keys in this section can be used not only as node keys (in fact, not all of them can be used
so), but also as nodewalk keys. The latter fact means that they can be used to introduce embedded
nodewalks, which (can) have its own every-step keylist, history and on-invalid mode; for details on
how these properties of outer and embedded nodewalk can interact, see \index{step>Nodewalk}. There
is no limit to the depth of nodewalks embedding (nodewalk within nodewalk within nodewalk \dots).

An embedded nodewalk functions as a single, fake step of the outer nodewalk.  Specifically, this
means that, while stepping through the embedded nodewalk, the every-step keylist of the outer
nodewalk is not executed.  Furthermore, by default, modifying the every-step keylist of the inner
walk (by manipulating register \index{register>every step}) does not influence the outer nodewalk
(but see option \index{option of=Nodewalk>every step}).

An embedded nodewalk does not count as a (real, every-step keyslist invoking) step of the outer
nodewalk.  After it is finished, there are two options with respect to the new current node of the
outer nodewalk,\footnote{Even the outermost explicitly invoked nodewalks actually have the outer
  nodewalk. It is ``static'' in the sense that no real step is ever made in it, but it has all the
  nodewalk properties --- the current node, \index{register>every step} keylist register, \index{option
    of=Nodewalk>history} and \index{option of=Nodewalk>on invalid} mode (error) --- which can
  interact with the embedded nodewalk.} depending on whether the embedded nodewalk was invoked using
a variant of the key with or without the \index{for step} prefix (all keys in this section have the
\index{for step} variant).
\begin{itemize}
\item For keys \emph{without} the \index{for step} prefix, the current node of the outer nodewalk
  changes, \emph{via a fake step}, to the final node visited by the embedded nodewalk.  This holds
  even if the final node was reached as a fake step and even if it is invalid
  (\index{option>id}|=0|).  The fake step in the outer nodewalk cannot be made real, not even by
  \index{nodewalk key>real}: if you want to execute the every-step keylist of the outer nodewalk at
  the finishing node of the embedded nodewalk, follow the latter by step \index{current}.
\item For keys \emph{with} the \index{for step} prefix, the current node of the outer nodewalk
  remains unchanged. For this reason, the \index{for step}-prefixed keys are available as node keys
  (we call them spatial propagators, \S\ref{ref:spatial-propagators}), while the steps without this
  prefix are generally not, with the sole exception of \index{step>Nodewalk}, which I advise to use
  carefully.
\end{itemize}

All steps described in this section can be prefixed by \index{for step}.  All of them, with or
without this prefix, are available as nodewalk keys. The list of keys from this section which are
available as node keys: \index{step>Nodewalk}, \index{for step=\index{step>Nodewalk}}, \index{for
  step=\index{nodewalk}}; you will most often want to use the latter.


\begin{syntax}
\indexitem{step>Nodewalk}|=|\meta{keylist: config}\meta{nodewalk}\meta{keylist: every-step}

  Walks an \meta{nodewalk} starting at the current node.

  This is the most generic form of embedding a nodewalk. Unlike other keys described in this
  subsection, it can also be used as a node key even without the \index{for step} prefix, but take
  care as it will, in general, change the current node.

  The \meta{config} argument serves to specify the interaction between the outer and embedded
  nodewalk.  It can contain the following keys:

  \let\outerleftmargin\leftmargin
  \begin{syntax}
    \indexitem(independent){option of=Nodewalk>every step}|={|\alternative{independent,inherited,shared}|}|
    \indexitem(shared){option of=Nodewalk>history}|={|\alternative{independent,inherited,shared}|}|

    The following table shows what happens to the every-step keylist and history depending on the
    value of \keyname{every step} and \keyname{history}, respectively.  State B is \meta{every-step}
    for every step and empty for history.
      
      \begin{tabular}{l|ccc}
        &\keyname{independent}&\keyname{inherited}&\keyname{shared}\\\hline
        state of the outer nodewalk&A&A&A\\
        initial state of the inner nodewalk&B&A&A\\
        \dots\\
        final state of the inner nodewalk&C&C&C\\
        state of the outer nodewalk&A&A&C
      \end{tabular}      
  \end{syntax}

  As shown in the table above, argument \meta{every-step} is used to initialize the
  embedded nodewalk's every-step keylist when it is independent of the outer nodewalk.  In other
  cases, this argument is ignored (use |{}|).

  \begin{syntax}
    \indexitem(inherited){option of=Nodewalk>on invalid}|={|\alternative{error,fake,error in real,last valid,inherited}|}|

    Like \index{nodewalk key>on invalid}, but local to this nodewalk.  The additional alternative
    \indexdef{value of=on invalid>inherited} (which is the default) means to retain the current
    value, regardless of how it was set (by an outer nodewalk, explicit \index{nodewalk key>on
      invalid}, or the package default, \index{value of=on invalid>error}).
  \end{syntax}
  
  \begin{advise}
  \item Use \index{node key>Nodewalk} if you need to execute nodewalk keys within the every-step
    keylist.
  \end{advise}
  
\begin{forestexample}[index={register>every step}]
  \begin{forest}
    for 2=calign with current, for children={for descendants={circle,draw}}
    [every step,
      [independent,for nodewalk={
          1,Nodewalk={~every step=independent~}{1,every step=fill,1}{},1
        }{draw=red},
        [[[[]]]]]
      [inherited,for nodewalk={
          1,Nodewalk={~every step=inherited~}{1,every step=fill,1}{},1
        }{draw=red},
        [[[[]]]]]
      [shared,for nodewalk={
          1,Nodewalk={~every step=shared~}{1,every step=fill,1}{},1
        }{draw=red},
        [[[[]]]]]]
  \end{forest}
\end{forestexample}


\begin{forestexample}[index={history,walk back}]
  \begin{forest}
    mark/.style={tempcounta+=1,content+/.register=tempcounta,content+={,}},
    [history:\\effect on the,align=center
      [inner nodewalk
        % uncommenting this would result in an error:
        % [independent, delay={for nodewalk={
        %     tempcounta=0,111,
        %     Nodewalk={history=independent}{walk back=2}{mark,fill=yellow}
        %   }{mark,draw=red}},
        %   [[[]]]]
        [inherited\\or\\shared, align=center,delay={for nodewalk={
              tempcounta=0,111,
              Nodewalk={~history=inherited~}{walk back=2}{mark,fill=yellow}
            }{mark,draw=red}},
          [[[]]]]]
      [outer nodewalk
        [inherited,delay={for nodewalk={
            tempcounta=0,111,
            Nodewalk={~history=inherited~}{11}{mark,fill=yellow},
            walk back=2
          }{mark,draw=red}},
          [[[[[]]]]]]
        [shared,delay={for nodewalk={
            tempcounta=0,111,
            Nodewalk={~history=shared~}{11}{mark,fill=yellow},
            walk back=2
          }{mark,draw=red}},
          [[[[[]]]]]]]]
  \end{forest}
\end{forestexample}
  
\indexitem{step>nodewalk}|=|\meta{nodewalk}\meta{keylist: every-step}

  This key is a shorthand for

  \begin{center}
    \index{step>Nodewalk}|={|\index{option of=Nodewalk>every step}|=independent,|\index{option
        of=Nodewalk>history}|=independent,|\index{option of=Nodewalk>on
        invalid}|=inherited}|\meta{nodewalk}\meta{keylist: every-step}
  \end{center}

  \begin{advise}
  \item \index{for step=\index{nodewalk}} is the most common way to explicitely invoke a nodewalk from a
    node keylist (the keylist immediately following the content of the node).
  \end{advise}
  
\indexitem{step>nodewalk'}|=|\meta{nodewalk}

  This key is a shorthand for

  \begin{center}
    \index{step>Nodewalk}|={|\index{option of=Nodewalk>every step}|=inherited,|\index{option
        of=Nodewalk>history}|=independent,|\index{option of=Nodewalk>on
        invalid}|=inherited}|\meta{nodewalk}|{}|
  \end{center}
  
  \begin{advise}
  \item Using this key, it is easy to ``\emph{temporarily} change'' the \index{register>every step}
    keylist of a nodewalk.
  \item Using \index{for step=\index{nodewalk'}} is probably the easiest way to make a ``trip''
    within a nodewalk, i.e.\ walk some steps but return to their origin afterwards.
  \item This key (with or without the \index{for step} prefix) is not available as a node key --- it
    would make little sense there, as it has no every-step keylist argument.
  \end{advise}
  
\end{syntax}


\subsubsection{Single-step keys}
\label{ref:single-step-keys}

Single-step nodewalk keys visit a single node.  The behaviour in the situation when the target node
does not exist is determined by \index{nodewalk key>on invalid}.

For each single-step key, spatial propagator \index{for step=\meta{step}} is also defined.
\index{for step=\meta{step}}|=|\meta{keylist} is equivalent to
\index{for step=\index{nodewalk}}|={|\meta{step}|}{|\meta{keylist}|}|.  If the step takes an argument, then its
\index{for step=\meta{step}} propagator takes two and the argument of the step precedes the
\meta{keylist}.  See also \S\ref{ref:spatial-propagators}.

Linear order below means the order of nodes in the bracket representation, i.e.\ depth-first
parent-first first-child-first.

\begin{syntax}
\indexitem{step>current} an ``empty'' step: the current node remains the same\footnote{While it
  might at first sight seem stupid to have an empty step, this is not the case.  For example,
  using propagator \index{for step=\index{current}} derived from this step, one can process a \meta{keylist} constructed using \index[not index,print format+={result+={\index[not print]{wrap pgfmath arg}\index[not print]{wrap $n$ pgfmath args}}}]{handler>wrap ($n$) pgfmath arg(s)} or \index{wrap value}.}
\indexitem{step>first} the first child
\indexitem{step>first leaf}, \indexdef{step>first leaf'} the first leaf (terminal node) of the
  current node's descendants (|first leaf|) or subtree (|first leaf'|), in the linear order
\indexitem{step>id}|=|\meta{id} the node with the given id; this step does not depend on the current node
\indexitem{step>last} the last child
\indexitem{step>last dynamic node} the last non-integrated (created/removed/replaced) node; see \S\ref{ref:dynamic}
\indexitem{step>last leaf}, \indexdef{step>last leaf'} the last leaf (terminal node) of the
  current node's descendants (|last leaf|) or subtree (|last leaf'|), in the linear order
\indexitem{step>n}|=|$n$ the $n$th child; counting starts at $1$\footnote{Note that \keyname{n}
  \emph{without} an argument is a short form of \keyname{next}.}
\indexitem{step>n'}|=|$n$ the $n$th child, starting the count from the last child
\indexitem{step>name}|=|\meta{name} the node with the given name or alias; this step does not depend on the current node
\indexitem{step>next} the next sibling 
\indexitem{step>next leaf} the next node (in the linear order) which is a leaf (the current node need not be a leaf) 
\indexitem{step>next node} the next node of the entire tree, in the linear order 
\indexitem{step>next on tier}|=|\meta{tier} the next node (in the linear order) on the given tier; if no tier is given, assume the tier of the current node  
\indexitem{step>origin} the starting node of the nodewalk; note that the starting point does not automatically count as a step: if you want to step on it, use this key (or \index{current}, at the beginning of the nodewalk)
\indexitem{step>parent} the parent 
\indexitem{step>previous} the previous sibling 
\indexitem{step>previous leaf} the previous node (in the linear order) which is a leaf (the current node need not be a leaf) 
\indexitem{step>previous node} the previous node of the entire tree, in the linear order 
\indexitem{step>previous on tier}|=|\meta{tier} the previous node (in the linear order) on the given tier; if no tier is given, assume the tier of the current node
\indexitem{step>root} the root node, i.e.\ the ancestor of the current node without the parent; note that this key \emph{does} depend on the current node
\indexitem{step>root'} the formal root node (see \index{set root} in \S\ref{ref:dynamic}); this key does not depend on the current node
\indexitem{step>sibling} the sibling

(don't use if the parent doesn't have exactly two children \dots)
\indexitem{step>to tier}|=|\meta{tier} the first ancestor of the current node (or the node itself) on the given \meta{tier}
\end{syntax}


\subsubsection{Multi-step keys}
\label{ref:multi-step-keys}

Multi-step keys visit several nodes, in general. If a multi-step key visits no nodes, the current
node remains unchanged.

For each multi-step key, spatial propagator \index{for step=\meta{step}} is also defined, see
\S\ref{ref:spatial-propagators}.

Many of the keys below have a |reversed| variant.  Those keys reverse the order of \emph{children}.
Note that in general, this differs from operation key \index{reverse}, which reverses the order of
the entire embedded nodewalk.

Linear order below means the order of nodes in the bracket representation, i.e.\ depth-first
parent-first first-child-first.

\begin{syntax}
  \indexitem{step>children}, \indexdef{step>children reversed}

  Visit all the children of the current
  node.

\indexitem{step>tree}, \indexdef{step>tree reversed}
  \itemnosep
\indexitem{step>tree children-first}, \indexdef{step>tree children-first reversed}
  \itemnosep
\indexitem{step>tree breadth-first}, \indexdef{step>tree breadth-first reversed}
  
  Visit the current node and all its descendants.

  The above keys differ in the order the nodes are visited.  The basic key, \keyname{tree},
  traverses the nodes in the depth-first, parent-first first-child-first order, i.e.\ the order in
  which they are given in the bracket representation: so it visits the parent before its children and
  it visits the children from the first to the last.

  |reversed| variants reverse the order of \emph{children}, visiting them from the last to the first
  (from the viewpoint of the bracket representation).

  |children-first| variants visit the children before the parent.

  |breadth-first| variants behave like |level| steps below: they first visit level |0| nodes, then
  level |1| nodes etc.

  \begin{forestexample}[index={}]
    \forestset{
      enumerate/.style={
        tempcounta=1,
        for #1={
          content/.pgfmath=tempcounta,
          tempcounta+=1
        }
      }
    }
    \newcommand\enumtree[1]{%
      \begin{forest}
        [#1,l sep=0,for n=1{
          l=0,no edge,delay={enumerate=#1}}
          [[[[][]][[][]]][[[][]]]]
        ]
      \end{forest}
    }
    \renewcommand\arraystretch{2}
    \begin{tabular}{cc}
      \enumtree{tree}&
      \enumtree{tree reversed}\\
      \enumtree{tree children-first}&
      \enumtree{tree children-first reversed}\\
      \enumtree{tree breadth-first}&
      \enumtree{tree breadth-first reversed}
    \end{tabular}    
  \end{forestexample}
  
\indexitem{step>descendants}, \indexdef{step>descendants reversed}
  \itemnosep
\indexitem{step>descendants children-first}, \indexdef{step>descendants children-first reversed}
  \itemnosep
\indexitem{step>descendants breadth-first}, \indexdef{step>descendants breadth-first reversed}
  
  Visit all the descendants of the current node.

  Like the |tree| keys, but the current node is not visited.

\indexitem[print form+=\spaces{9}]{step>relative level<},
  \indexdef[print form+=\spaces{9}]{step>relative level},
  \indexdef[set={form=relative level\protect\greaterthan}]{step>relative levelGT}\texttt{\spaces{9}}|=|\meta{count}
  \itemnosep
\indexitem{step>relative level reversed<},
  \indexdef{step>relative level reversed},
  \indexdef[set={form=relative level reversed\protect\greaterthan}]{step>relative level reversedGT}|=|\meta{count}
  \itemnosep
\indexitem[print form+=\spaces{9},+print form=\spaces{9}]{step>level<},
  \indexdef[print form+=\spaces{9},+print form=\spaces{9}]{step>level},
  \indexdef[set={form=level\protect\greaterthan},+print form=\spaces{9}]{step>levelGT}\texttt{\spaces{9}}|=|\meta{count}
  \itemnosep
\indexitem[+print form=\spaces{9}]{step>level reversed<},
  \indexdef[+print form=\spaces{9}]{step>level reversed},
  \indexdef[set={form=level reversed\protect\greaterthan},+print form=\spaces{9}]{step>level reversedGT}|=|\meta{count}

  Visits the nodes in the subtree of the current node whose level (depth) is less than \emph{or
    equal to}, equal to, or greater than \emph{or equal to} the given level.

  The |relative| variants consider the level as relative to the current node: relative level of the
  current node is $0$; relative level of its children is $1$, of its grandchildren $2$, etc.  The
  absolute variants consider the depth with respect to the (geometric) root, i.e.\ as returned by
  node option \index{readonly option>level}.

  The nodes are traversed in the breadth-first order.  The |reversed| variants reverse the order of
  the children within each level, but the levels are still traversed from the highest to the
  deepest.

\indexitem{step>leaves}

  Visits all the leaves in the current node's subtree.
  
\indexitem[index key={level-}]{step>-level}|=|\meta{count}
\itemnosep
\indexitem[index key={level-'}]{step>-level'}|=|\meta{count}

Visits all the nodes \meta{count} levels above the leaves in the current node's subtree.
  
\indexitem[+print form=\spaces{12},print form+=\spaces{9}]{step>preceding siblings}\quad\quad
  \indexdef[+print form=\spaces{12}]{step>following siblings}%
  \itemnosep
\indexitem[print form+=\spaces{9}]{step>current and preceding siblings}\quad\quad
  \indexdef{step>current and following siblings}%
  \itemnosep
\indexitem[+print form=\spaces{12}]{step>preceding siblings reversed}\quad\quad
  \indexdef[+print form=\spaces{12}]{step>following siblings reversed}%
  \itemnosep
\indexitem{step>current and preceding siblings reversed}\quad\quad
  \indexdef{step>current and following siblings reversed}%
  \itemnosep
\indexitem[+print form=\spaces{22},print form+=\spaces{9}]{step>siblings}%
  \itemnosep
\indexitem[print form={current and \spaces{9} siblings\spaces{9}}]{step>current and siblings}%
  \itemnosep
\indexitem[+print form=\spaces{22},print form+=\spaces{9}]{step>siblings reversed}%
  \itemnosep
\indexitem[print form={current and \spaces{9} siblings reversed}]{step>current and siblings reversed}%

Visit preceding, following or all siblings; visit the current node as well or not; visit in normal
or reversed order.

\indexitem{step>ancestors}
  \itemnosep
\indexitem{step>current and ancestors}
  
Visit the ancestors of the current node, starting from the parent/current node, ending at the root node.

\indexitem[+print form=\spaces{12}]{step>preceding nodes}\quad\quad
  \indexdef[+print form=\spaces{12}]{step>following nodes}%
  \itemnosep
\indexitem{step>current and preceding nodes}\quad\quad
  \indexdef{step>current and following nodes}%

Visit all preceding or following nodes of the entire tree, in the linear order; visit the current node as well or not.
  
\end{syntax}


\subsubsection{Operations}
\label{ref:nodewalk-operations}

Generally speaking, nodewalk operations take an \emph{input nodewalk} and transform it into
an \emph{output nodewalk}, while possibly also having side effects.

The most important categorization of operations is in terms of the input nodewalk:
\begin{itemize}
\item ``Normal'' keys execute the input nodewalk ``invisibly'', i.e.\ with a every-step keylist that
  is initially empty. However, even such an ``invisible'' nodewalk might not always be completely
  without effect.  For example, the effects of any node keys contained in the input nodewalk or
  modifications of its (initially empty) every-step keylist will be felt.
\item Most of the operation keys have the |walk_and_...| variant, where input given nodewalk is meant to
  be ``visible'': it is walked directly in the context of the invoking nodewalk (specifically, with
  its every-step keylist in effect).
\item Some operation keys have the |..._in_nodewalk| variant, which operates on the portion of the
  current nodewalk that was already walked.
\item \index{load} has no input nodewalk.
\end{itemize}
All operation keys except |..._in_nodewalk| variants can be prefixed by \index{for step} to create a
spatial propagator (\S\ref{ref:spatial-propagators}).

The output nodewalk is always walked in the context of the invoking nodewalk.  However, note that,
as mentioned above, in the case of |walk_and_...| variants, that context can be changed during the
execution of the input nodewalk.

Trivia: \index{save} is the only operation with no output nodewalk and also the only operation with
a ``side effect'' (of saving the nodewalk, obviously).

For some operations (\index{filter} and \index{branch}), the every-step keylist contains instructions
on how collect the relevant information.  While you can safely append and prepend to
\index{register>every step} keylist of their input nodewalk, you should not completely rewrite
it. If you want the operations to actually work, of course.
  
\begin{syntax}
\indexitem{step>group}|=|\meta{nodewalk}

  Treat \meta{nodewalk} as a single step of the (outer) nodewalk, i.e.\ the outer every-step keylist
  is executed only at the end of the embedded nodewalk.  The embedded \meta{nodewalk} inherits
  history from the outer nodewalk.  Using this key is equivalent to writing
  \begin{center}
    \index{step>Nodewalk}|={|\index{option of=Nodewalk>every step}|=independent,|\index{option
        of=Nodewalk>history}|=inherited}|\meta{nodewalk}|{}, current|
  \end{center}

  
  \indexitem{step>reverse}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and reverse}|=|\meta{nodewalk}

  Visits the nodes of the given \meta{nodewalk} in the reversed order. 

  
  \indexitem{step>unique}|=|\meta{nodewalk}

  Walks the \meta{nodewalk}, but visits each node at most once. 

  
\indexitem{step>filter}|=|\meta{nodewalk}\index{forestmath=condition}

Visit the nodes of the given \meta{nodewalk} for which the given \meta{condition} is true.

  \begin{advise}
  \item You can safely append and prepend to \index{register>every step} keylist during the input
    \meta{nodewalk}, but you should not completely rewrite it.
  \end{advise}


\indexitem{step>branch}|={|\meta{nodewalk$_1$}|,...,|\meta{nodewalk$_n$}|}|
  \itemnosep
\indexitem{step>branch'}|={|\meta{nodewalk$_1$}|,...,|\meta{nodewalk$_n$}|}|

Visit the nodes in a ``cartesian product'' of any number of nodewalks, where a cartesian product is
defined as a nodewalk where at every step of \meta{nodewalk$_i$} ($1\leq i<n$),
\meta{nodewalk$_{i+1}$} is executed.

The |branch| variant visits only the nodes visited by the innermost nodewalk, \meta{nodewalk$_n$}.
The |branch'| variant visits the nodes visited by all the nodewalks of the product,
\meta{nodewalk$_1$} \dots\ \meta{nodewalk$_n$}.

For an example of each, see \index{c-commanded} and \index{c-commanders} from the
\reflibrary{linguistics} library.

  \begin{advise}
  \item You can safely append and prepend to \index{register>every step} keylists during the input
    \meta{nodewalk}s, but you should not completely rewrite them.
  \end{advise}


  \indexitem{step>save}|=|\meta{toks: name}\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and save}|=|\meta{toks: name}\meta{nodewalk}

  Saves the given \meta{nodewalk} under the given name.

  \indexitem{step>save append}|=|\meta{toks: name}\meta{nodewalk}
  \itemnosep
  \indexitem{step>save prepend}|=|\meta{toks: name}\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and save append}|=|\meta{toks: name}\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and save prepend}|=|\meta{toks: name}\meta{nodewalk}

  Appends/prepends the given \meta{nodewalk} to nodewalk \meta{name}.
  
  \indexitem{step>load}|=|\meta{toks: name} Walks the nodewalk saved under the given name.  

  Note that it is node \index{readonly option>id}s that are saved: loading a named nodewalk with in a context of
  a different current node, or even with a tree whose geometry has changed (see \S\ref{ref:dynamic})
  will still visit exactly the nodes that were visited when the nodewalk was saved.

  
  \indexitem{step>sort}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>sort'}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and sort}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and sort'}|=|\meta{nodewalk}

    Walks the nodes of the nodewalk in the order specified by the last invokation of \index{sort
      by}.  The \keyname{sort} variants sort in the ascending order, the \keyname{sort'} variants in
    the descending order.  The \keyname{walk and sort} variants first visit the nodes in the order
    specified by the given \meta{nodewalk}.

  \indexitem{node key>sort by}|={|\index{forestmath}|,|\dots|,|\index{forestmath}|}|

    Sets the sorting order used by all keys comparing nodes: \index{step>sort}, \index{step>min}
    and \index{step>max} key families in the nodewalk namespace, and the \index{dynamic
      tree>sort} key family in the option namespace (dynamic tree).
    
  For each node being ordered, an ``$n$-dimensional coordinate'' is computed by evaluating the given
  list of |pgfmath| expressions in the context of that node.\footnote{Don't worry, lazy evaluation
    is used.}  Nodes are then ordered by the usual sort order for multi-dimensional arrays: the
  first item is the most important, the second item is the second most important, etc.

  Simply put, if you want to sort first by the number of children and then by content, say
  |sort_by={|\index[+print format=pgfmath]{n children}|,_|\index{content}|}|.

  In the simplest case, the given \index{forestmath} expressions are simply node options.  However, as
  any |pgfmath| expression is allowed in the sort key, you can easily sort by the product of the
  content of the current node and the content of its first child:
  |sort_by={|\index{content}|()*|\index{content}|("|\index>{!}|1")|.  

    To sort alphabetically, one must use the argument processor (\S\ref{ref:argument-processor}) to
    specify the sort order. In particular, the key must be marked as text using \index{processor>t}.
    The first example below shows a simple alphabetical sort by content; the second sorts the
    filenames by suffix first (in the ascending order) and then by the basename (in the descending
    order, see \index{processor>-}).

\begin{forestexample}
  \begin{forest}
    [,phantom,grow'=0,for children={anchor=west,child anchor=west},s sep=0,
      delay={~sort by=>O+t{content},sort~}
      [example.tex][example.pdf][example.log][example.aux]
      [thesis.tex][thesis.pdf][thesis.log][thesis.aux][thesis.toc]
    ]
  \end{forest}
\end{forestexample}

\begin{forestexample}
  \begin{forest}
    declare toks={basename}{},
    declare toks={extension}{},
    [,phantom,grow'=0,for children={anchor=east},s sep=0,
      delay={
        for children={split option={content}{.}{basename,extension}},
        ~sort by={>O+t{extension},>O+t-{basename}}~,
        ~sort~,
      }
      [example.tex][example.pdf][example.log][example.aux]
      [thesis.tex][thesis.pdf][thesis.log][thesis.aux][thesis.toc]
    ]
  \end{forest}
\end{forestexample}
    
\indexitem{step>min}|=|\meta{nodewalk}, \indexdef{step>max}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and min}|=|\meta{nodewalk}, \indexdef{step>walk and max}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>mins}|=|\meta{nodewalk}, \indexdef{step>maxs}|=|\meta{nodewalk}
  \itemnosep
  \indexitem{step>walk and mins}|=|\meta{nodewalk}, \indexdef{step>walk and maxs}|=|\meta{nodewalk}


  Visit the node(s) in the given \meta{nodewalk} with a minimum/maximum value with
  respect to the sort order previously specified by \index{sort by}.  

  Variants \keyname{mins}/\keyname{maxs} visit all the nodes that with the minimum/maximum value of
  the sorting key; variants \keyname{min}/\keyname{max} visit only the first such node (first in the order specified by the given nodewalk).

  \indexitem{step>min in nodewalk}, \indexdef{step>max in nodewalk}
  \itemnosep
  \indexitem{step>mins in nodewalk}, \indexdef{step>maxs in nodewalk}
  \itemnosep
  \indexitem{step>min in nodewalk'}, \indexdef{step>max in nodewalk'}

  These keys search for the minimum/maximum among the nodes that were already visited in the current
  nodewalk.

  Keys \keyname{mins in nodewalk} and \keyname{maxs in nodewalk} visits all nodes that reach the minimum/maximum, while keys \keyname{min in nodewalk} and \keyname{max in nodewalk} variants visit only the first such node.

  Keys \keyname{min in nodewalk'} and \keyname{max in nodewalk'} visit the first minimal/maximal
  node by moving back in the history, see \index{back}.

  
\end{syntax}

\subsubsection{History}
\label{ref:nodewalk-history}

\FoRest; keeps track of nodes visited in a nodewalk and makes it possible to revisit them, in a
fashion similar to clicking the back and forward button in a web browser.

These keys cannot be prefixed by \index{for step}.

\begin{syntax}
  \indexitem{step>back}|=|\meta{count: n}
  \itemnosep
  \indexitem{step>jump back}|=|\meta{count: n}
  \itemnosep
  \indexitem{step>walk back}|=|\meta{count: n}

    Move $n$ steps back in the history. In the \keyname{back} variant, all steps are fake; in
    the \keyname{jump back} variant, the final step is real; and in the \keyname{walk back} variant,
    all steps are real.

    Note that as the origin is not a part of the history, these keys will \emph{not} step there
    (unless \index{current} was the first step of your nodewalk).  (Use \index{origin} to move
    to the origin of the nodewalk.)

  \indexitem{step>forward}|=|\meta{count: n}
  \itemnosep
  \indexitem{step>jump forward}|=|\meta{count: n}
  \itemnosep
  \indexitem{step>walk forward}|=|\meta{count: n}
    
    Move $n$ steps forward in the history. In the \keyname{forward} variant, all steps are fake; in
    the \keyname{jump forward} variant, the final step is real; and in the \keyname{walk forward} variant,
    all steps are real.

\indexitem{node key>save history}|=|\meta{toks: back name}\meta{toks: forward name}

Saves the backwards and forwards history under the given names. (Load them using \index{load}.)  The
backwards history is saved in the reverse order of how it was walked, i.e.\ outward from the
perspective of the current position in the nodewalk.
\end{syntax}


\subsubsection{Miscellaneous}
\label{ref:nodewalk-miscellaneous}

The following nodewalk keys are not steps. Rather, they influence the behaviour of nodewalk steps in
various ways.  The keys in this section having \meta{nodewalk} arguments do not start a new nodewalk
in the sense of \S\ref{ref:embedded-walks}; the given nodewalk steps rather become a part of the
current nodewalk.

\begin{syntax}
\indexitem{register>every step}|=|\meta{keylist} Contains the every-step keylist of the current
  nodewalk.
  
\indexitem{nodewalk key>fake}|=|\meta{nodewalk}
  \itemnosep
\indexitem{nodewalk key>real}|=|\meta{nodewalk}

  The \meta{nodewalk} embedded under |fake| consists of ``fake'' steps: while
  the current node is changed, every-step keylist is not executed and the history is not updated.
  
  Note that these keys do not introduce an embedded nodewalk.  The given \meta{nodewalk} will not
  have its own history and every-step keylist.

  |real| undoes the effect of |fake|, but cannot make real the implicitely fake steps, such as the
  return to the origin in spatial propagators like \index{for step=\index{nodewalk}}.
  |fake| and |real| can be nested without limit.

\indexitem{step>last valid}
  \itemnosep
\indexitem{step>last valid'}

  If the current node is valid, these keys do nothing.  If the current node of the nodewalk is
  invalid (i.e.\ its \index{readonly option>id} is $0$), they step to the last valid visited node.  If
  there was no such node, they step to the origin of the nodewalk.

  The variant \emph{without} |'| makes a fake step. More precisely, it behaves as if both
  \index{nodewalk key>fake} and \index{nodewalk key>on invalid}|=fake| are in effect.

\indexitem{nodewalk key>on invalid}|={|\alternative{error,fake,step}|}|\meta{nodewalk}

  This key determines what should happen if a nodewalk step landed on the invalid node, i.e.\ the node
  with \index{readonly option>id}|=0|.
  
  There is a moment within the step when the current node is changed but the step itself is not yet
  really done, is ``still fake'', i.e.\ the history is not yet updated and the every-step keylist is
  not yet executed.  If the new current node is invalid, this key determines what should happen next.

  \let\outerleftmargin\leftmargin
  \begin{syntax}
  \item |on invalid={|\indexdef{value of=on invalid>error}|}|\meta{nodewalk} produces an error;
  \item |on invalid={|\indexdef{value of=on invalid>fake}|}|\meta{nodewalk} does nothing: history is
    not updated and the every-step keylist is not executed, thus making the step essentialy fake;
  \item |on invalid={|\indexdef{value of=on invalid>error if real}|}|\meta{nodewalk} produces an
    error unless \index{nodewalk key>fake} is in effect.
  \item |on invalid={|\indexdef{value of=on invalid>last valid}|}|\meta{nodewalk} returns to the
    last valid node, by making a fake step, like \index{step>last valid}.
  \end{syntax}

  Loops with the implicit |id=0| condition (\S\ref{ref:loops}) automatically switch to
  |on_invalid=fake| mode.

  See also \index{step>Nodewalk} option \index{option of=Nodewalk>on invalid}.
  
\indexitem{nodewalk key>options}=\meta{keylist: node keys}

  Execute the given node options in the context of the current node.

  There is not much need to use this key, as any keys that are not (long) steps or sequences of
  short steps are automatically used as \foRest; node options any way, but there are still usage
  cases, for example whenever the names of node options and (long) steps are the same, or in a style
  that wants to ensure there is no overlap.

\indexitem{nodewalk key>strip fake steps}|=|\meta{nodewalk}

  If \meta{nodewalk} ends with fake steps, return to the last node current before those steps were made.  For details, see \index{define long step}.

\end{syntax}


\subsubsection{Short-form steps}
\label{ref:short-form-steps}

All short forms of steps are one token long.  When using them, there is no need to separate them by
commas.  Here's the list of predefined short steps and their corresponding long-form steps.

\begin{syntax}
\indexitem{short step>1}, \indexdef{short step>2}, \indexdef{short step>3}, \indexdef{short step>4}, \indexdef{short step>5}, \indexdef{short step>6}, \indexdef{short step>7}, \indexdef{short step>8}, \indexdef{short step>9} the first, \dots, ninth child --- \index{readonly option>n}|=1|,\dots,|,9|
\indexitem{short step>l} the last child --- \index{step>last}
\indexitem{short step>u} the parent (up) --- \index{step>parent}
\indexitem{short step>p} the previous sibling --- \index{previous}
\indexitem{short step>n} the next sibling --- \index{next}
\indexitem{short step>s} the sibling --- \index{sibling}
\indexitem{short step>P} the previous leaf --- \index{previous leaf}
\indexitem{short step>N} the next leaf --- \index{next leaf}
\indexitem{short step>F} the first leaf --- \index{first leaf}
\indexitem{short step>L} the last leaf --- \index{last leaf}
\indexitem[set={index key={<GT},form=\protect\greaterthan}]{short step>GT}
  the next node on the current tier --- \index{next on tier}
\indexitem{short step><} the previous node on the current tier --- \index{previous on tier}
\indexitem{short step>c} the current node --- \index{current}
\indexitem{short step>o} the origin --- \index{origin}
\indexitem{short step>r} the root node --- \index{root}
\indexitem{short step>R} the formal root node --- \index{root'}
\indexitem{short step>b} back one fake step in history --- \index{back}|=1|
\indexitem{short step>f} forward one fake step in history --- \index{forward}|=1|
\indexitem{short step>v} last valid node in the current nodewalk, fake version --- \index{step>last valid}
\indexitem{short step>*}\meta{count: n}\meta{keylist} repeat keylist $n$ times --- \index{repeat}|=|\meta{count: n}\meta{keylist}
\item {\rstyle $\{$}\meta{keylist}{\rstyle $\}$} put keylist in a group --- \index{group}|=|\meta{keylist}
\end{syntax}

\subsubsection{Defining steps}
\label{ref:defining-steps}

You can define your own steps, both long and short, or even redefine predefined steps.  Note,
though, that it is not advisable to redefine long steps, as their definitions are interdependent;
redefining short steps is always ok, however, as they are never used in the code of the package.

\begin{syntax}
\indexitem{node key>define long step}|=|\meta{name}\meta{options}\meta{nodewalk}

  Define a long-form step named \meta{name} as equivalent to \meta{nodewalk}.  \meta{options} control the exact behaviour or the defined step.
  
  \let\outerleftmargin\leftmargin
  \begin{syntax}
  \item\indexdef{option of=define long step>n args}|=|\meta{number}\hfill |0|
  \item\indexdef{option of=define long step>make for}|=|\meta{boolean}\hfill |true|
    
    Should we make a \index{for step} prefix for the step? 
  \item\indexdef{option of=define long step>strip fake steps}|=|\meta{boolean}\hfill |true|
    
    Imagine that \meta{nodewalk} ends with fake steps.  Now, fake steps are usually just a computational tool, so we normally wouldn't want the current node after the walk to be one of them. As far as the outer world is concerned, we want the node to end at the last real step. However, simply appending \index{step>last valid} to our style will not work.  Imagine that the nodewalk results in no steps.  In this case, we'd want to remain at the origin of our empty nodewalk.  However, imagine further that the (outer) step just before the empty nodewalk was fake.  Then \index{step>last valid} will not step to the correct node: instead of staying at the origin, it will go to the node that the last real step prior to our nodewalk stepped to.  In case there was no such real step, we'd even step to the invalid node (normally getting an error).

    Defining the step using |strip fake steps| ensures the correct behaviour described
    above.  Set |strip fake steps=false| only when the fake steps at the end of the nodewalk are
    important to you.

    \begin{advise}
      \item See also nodewalk key \index{nodewalk key>strip fake steps}.
    \end{advise}

  \end{syntax}

\begin{forestexample}[index={define long step,option of=define long step>n args,conditional>if,step>n,while,readonly option>n,next}]
  \forestset{
    ~define long step~={children from to}{n args=2}{
      if={#1>#2}{}{n=#1,while={n()<#2}{next}}
    }
  }
  \begin{forest}
    for children from to={2}{5}{draw}
    [root[1][2][3][4][5][6]]
  \end{forest}
\end{forestexample}

  
\indexitem{node key>define short step}|=|\meta{token: short step}\meta{n args}\meta{nodewalk}

Define short step taking $n$ arguments as the given \meta{nodewalk}.  Refer to the arguments in the usual way, via |#1|, \dots.

To (re)define braces, |{}|, write |define short step={group}{1}{...}|.

\indexitem{handler>nodewalk style}|=|\meta{nodewalk}

\meta{nodewalk key}|/.nodewalk style=|\meta{nodewalk} is a shorthand for\\
|for_nodewalk={|\meta{nodewalk key}|/.style=|\meta{nodewalk}|}{}|.

\end{syntax}


\subsection{Conditionals}
\label{ref:conditionals}

All conditionals take arguments \meta{true keylist} and \meta{false keylist}.  The interpretation of
the keys in these keylists depends on the environment the conditional appears in.  If it is a part
of a nodewalk specification, the keys are taken to be nodewalk keys (\S\ref{ref:nodewalks}),
otherwise node keys (\S\ref{ref:node-keys}).

All the conditionals can be nested safely.

\begin{syntax}
\indexitem{conditional>if}|=|\index{forestmath=condition}\meta{true keylist}\meta{false keylist}

  If \index{forestmath=condition} evaluates to |true| (non-zero), \meta{true keylist} is processed (in
  the context of the current node); otherwise, \meta{false keylist} is processed.

  For a detailed description of |pgfmath| expressions, see \cite[part VI]{tikzpgf2.10}.  (In short:
  write the usual mathematical expressions.)

  In the following example, \index{conditional>if} is used to orient the arrows from the smaller
  number to the greater, and to color the odd and even numbers differently. (Style |random_tree| is
  defined in the front page example.)

\forestset{random tree/.style n args={3}{% #1=max levels, #2=max children, #3=max content
      content/.pgfmath={random(0,#3)},
      if={#1>0}{repeat={random(0,#2)}{append={[,random tree={#1-1}{#2}{#3}]}}}{}}}
\begin{forestexample}[index={before typesetting nodes,for step,descendants,conditional>if,content,edge,edge label,tree},index>={!},point=if]
  \pgfmathsetseed{314159}
  \begin{forest}
    before typesetting nodes={
      for descendants={
        if={content()>content("!u")}{edge=->}{
          if={content()<content("!u")}{edge=<-}{}},
        edge label/.wrap pgfmath arg=
          {node[midway,above,sloped,font=\scriptsize]{+#1}}
          {int(abs(content()-content("!u")))}
      },
      for tree={circle,if={mod(content(),2)==0}
                          {fill=yellow}{fill=green}}
    }
    [,random tree={3}{3}{100}]
  \end{forest}
\end{forestexample}



  
\indexitem{word prefix=option>conditional>if=\meta{option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}

This simple conditional is defined for every \meta{option} (except boolean options, see below): if
\meta{value} equals the value of the option at the current node, \meta{true keylist} is executed;
otherwise, \meta{false keylist}.

\indexitem{word prefix=boolean option>conditional>if=\meta{boolean option}}|=|\meta{true keylist}\meta{false keylist}

  Execute \meta{true keylist} if \meta{boolean option} is true; otherwise, execute \meta{false
    keylist}.

\indexitem{word prefix=toks option>conditional>if in=\meta{toks option}}|=|\meta{toks}\meta{true keylist}\meta{false
  keylist}

  Checks if \meta{toks} occurs in the option value; if it does, \meta{true keylist} are executed,
  otherwise \meta{false keylist}.

  This conditional is defined only for \meta{toks} options, see \S\ref{sec:option-setting}.


  
\indexitem[set={
  index format={result=if \protect\meta{dimen option}\protect\greaterthan,pgfkey},
  print format={result/.option=argument,+result={if\ },result+={>}, pgfkey},
}]{conditional>if dimen GT=\protect\meta{dimen option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=if \protect\meta{dimen option}<,pgfkey},
  print format={result/.option=argument,+result={if\ },result+={<}, pgfkey},
}]{conditional>if dimen LT=\protect\meta{dimen option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=if \protect\meta{count option}\protect\greaterthan,pgfkey},
  print format={result/.option=argument,+result={if\ },result+={>}, pgfkey},
}]{conditional>if count GT=\protect\meta{count option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=if \protect\meta{count option}<,pgfkey},
  print format={result/.option=argument,+result={if\ },result+={<}, pgfkey},
}]{conditional>if count LT=\protect\meta{count option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=if \protect\meta{dimen register}\protect\greaterthan,pgfkey},
  print format={result/.option=argument,+result={if\ },result+={>}, pgfkey},
}]{conditional>if dimen register GT=\protect\meta{dimen register}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=if \protect\meta{dimen register}<,pgfkey},
  print format={result/.option=argument,+result={if\ },result+={<}, pgfkey},
}]{conditional>if dimen register LT=\protect\meta{dimen register}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=if \protect\meta{count register}\protect\greaterthan,pgfkey},
  print format={result/.option=argument,+result={if\ },result+={>}, pgfkey},
}]{conditional>if count register GT=\protect\meta{count register}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=if \protect\meta{count register}<,pgfkey},
  print format={result/.option=argument,+result={if\ },result+={<}, pgfkey},
}]{conditional>if count register LT=\protect\meta{count register}}|=|\meta{value}\meta{true keylist}\meta{false keylist}

If the current value of the dimen/count option/register is greater/less than or equal to
\meta{value}, execute \meta{true keylist}; else, execute \meta{false keylist}.


\indexitem{conditional>if nodewalk valid}|=|\meta{keylist: test nodewalk}\meta{true keylist}\meta{false keylist}

  If the test nodewalk finished on a valid node, \meta{true keylist} is processed (in the context of
  the current node); otherwise, \meta{false keylist} is processed.

\indexitem{conditional>if nodewalk empty}|=|\meta{keylist: test nodewalk}\meta{true keylist}\meta{false keylist}

  If the test nodewalk contains no (real) steps, \meta{true keylist} is processed (in the context of
  the current node); otherwise, \meta{false keylist} is processed.

\indexitem{conditional>if current nodewalk empty}|=|\meta{true keylist}\meta{false keylist}

  If the current nodewalk contains no (real) steps, \meta{true keylist} is processed (in the context of
  the current node); otherwise, \meta{false keylist} is processed.

  \indexitem{conditional>if in saved nodewalk}|=|\meta{nodewalk}\meta{toks: nodewalk name}\meta{true keylist}\meta{false keylist}

If the node at the end of \meta{nodewalk} occurs in the saved nodewalk, \meta{true keylist} is
processed (in the context of the current node); otherwise, \meta{false keylist} is processed.

\indexitem{propagator>if have delayed}|=|\meta{true keylist}\meta{false keylist}  If any options were
  delayed in the current cycle (more precisely, up to the point of the execution of this key),
  process \meta{true keylist}, otherwise process \meta{false keylist}.  (\index{delay n} will
  trigger ``true'' for the intermediate cycles.)

  This key assumes that the processing order of the innermost invocation of \index{process
    keylist} or \index{process keylist'} is given by \index{processing order}.  If this is not
  the case, explicitely supply the processing order using \index{if have delayed'}.

\indexitem{propagator>if have delayed'}|=|\meta{nodewalk}\meta{true keylist}\meta{false keylist}
  Like \index{if have delayed}, but assume the processing order given by \meta{nodewalk}.

\end{syntax}



The following keys are shortcuts: they execute their corresponding |if ...| conditional for every
node in the subtree of the current node (including the node itself).  In other words:

\begin{center}
  |where ...|\meta{arg$_1$}\dots\meta{arg$_n$}|/.style={for tree={if ...=|\meta{arg$_1$}\dots\meta{arg$_n$}|}}|
\end{center}

\begin{advise}
\item Except in special circumstances, you probably don't want to embed keys from the \index{where
    option} family within a \index{for step=\index{tree}}, as this results in two nested loops. It
  is more usual to use an \index{conditional>if} family key there.  For an example where using
  \index{where option} actually does the wrong thing, see question
  \href{http://tex.stackexchange.com/questions/167978/smaller-roofs-for-forest}{Smaller roofs for
    forest} on \TeX\ Stackexchange.
\end{advise}

\begin{syntax}
\indexitem{conditional>where}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{word prefix=option>conditional>where=\meta{option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{word prefix=boolean option>conditional>where=\meta{boolean option}}|=|\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{word prefix=toks option>conditional>where in=\meta{toks option}}|=|\meta{toks}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=where \protect\meta{dimen option}\protect\greaterthan,pgfkey},
  print format={result/.option=argument,+result={where\ },result+={>}, pgfkey},
}]{conditional>where dimen GT=\protect\meta{dimen option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=where \protect\meta{dimen option}<,pgfkey},
  print format={result/.option=argument,+result={where\ },result+={<}, pgfkey},
}]{conditional>where dimen LT=\protect\meta{dimen option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=where \protect\meta{count option}\protect\greaterthan,pgfkey},
  print format={result/.option=argument,+result={where\ },result+={>}, pgfkey},
}]{conditional>where count GT=\protect\meta{count option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=where \protect\meta{count option}<,pgfkey},
  print format={result/.option=argument,+result={where\ },result+={<}, pgfkey},
}]{conditional>where count LT=\protect\meta{count option}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=where \protect\meta{dimen register}\protect\greaterthan,pgfkey},
  print format={result/.option=argument,+result={where\ },result+={>}, pgfkey},
}]{conditional>where dimen register GT=\protect\meta{dimen register}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=where \protect\meta{dimen register}<,pgfkey},
  print format={result/.option=argument,+result={where\ },result+={<}, pgfkey},
}]{conditional>where dimen register LT=\protect\meta{dimen register}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=where \protect\meta{count register}\protect\greaterthan,pgfkey},
  print format={result/.option=argument,+result={where\ },result+={>}, pgfkey},
}]{conditional>where count register GT=\protect\meta{count register}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem[set={
  index format={result=where \protect\meta{count register}<,pgfkey},
  print format={result/.option=argument,+result={where\ },result+={<}, pgfkey},
}]{conditional>where count register LT=\protect\meta{count register}}|=|\meta{value}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{conditional>where nodewalk valid}|=|\meta{toks: nodewalk name}\meta{true keylist}\meta{false keylist}
\itemnosep  
\indexitem{conditional>where nodewalk empty}|=|\meta{toks: nodewalk name}\meta{true keylist}\meta{false keylist}
\itemnosep
\indexitem{conditional>where in saved nodewalk}|=|\meta{nodewalk}\meta{toks: nodewalk name}\meta{true keylist}\meta{false keylist}
\end{syntax}


\subsection{Loops}
\label{ref:loops}

All loops take a \meta{keylist} argument.  The interpretation of the keys in these keylists depends
on the environment the loop appears in.  If it is a part of a nodewalk specification,
the keys are taken to be nodewalk keys (\S\ref{ref:nodewalks}), otherwise node keys
(\S\ref{ref:node-keys}).

All loops can be nested safely.


\begin{syntax}
  
\indexitem{loop>repeat}|=|\meta{number}\meta{keylist}

  The \meta{keylist} is processed \meta{number} times.

  The \meta{number} expression is evaluated using |pgfmath|.  

\indexitem{loop>while}|=|\index{forestmath=condition}\meta{keylist}
  \itemnosep
\indexitem{loop>do while}|=|\index{forestmath=condition}\meta{keylist}
  \itemnosep
\indexitem{loop>until}|=|\index{forestmath=condition}\meta{keylist}
  \itemnosep
\indexitem{loop>do until}|=|\index{forestmath=condition}\meta{keylist}

  \keyname{while} loops cycle while the condition is true, \keyname{until} loops terminate when the
  condition becomes true.

  The \keyname{do} variants check the condition after processing the \meta{keylist}; thus, the
  keylist is executed at least once.  The variants without the \keyname{do} prefix check the
  condition before processing the \meta{keylist}, which might therefore not be processed at all.

  When \index{forestmath=condition} is an empty string, condition \index{valid} is implicitely used,
  and \meta{keylist} is implicitely embedded in \index{nodewalk key>on invalid}|=fake|.  Thus, the |while|
  loops will cycle until they ``walk out of the tree'', and |until| loops will cycle until they
  ``walk into the tree.''

  \begin{advise}
  \item If a loop ``walks out of the tree'', you can get it back in using \index{step>last valid} or
    \index{nodewalk key>strip fake steps}.
  \end{advise}

  
\begin{forestexample}[index={root',content,step>n,delay,for step,nodewalk,do until}]
  \pgfmathsetseed{1234}
  \begin{forest}
    try/.style={root',content+={#1,\ },n=#1},
    delay={
      for nodewalk={~do until~={}{try/.pgfmath={random(1,20)}},draw}{},
    },
    [tried:\ [1][2][3][4][5]]
  \end{forest}
\end{forestexample}

\indexitem{loop>while nodewalk valid}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>do while nodewalk valid}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>until nodewalk valid}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>do until nodewalk valid}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>while nodewalk empty}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>do while nodewalk empty}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>until nodewalk empty}|=|\meta{nodewalk}\meta{keylist}
  \itemnosep
\indexitem{loop>do until nodewalk empty}|=|\meta{nodewalk}\meta{keylist}

  \meta{nodewalk} is embedded within \index{nodewalk key>on invalid}|=fake|.


\indexitem(0){node key>break}|=|$n$  Break out of the loop.

  The loop is only exited after all the keys in the current cycle have been processed.

  The optional argument $n$ ($n\geq0$) specifies which level of embedding to break from; the default
  is to break out of the innermost loop.

\indexitem(0){pgfmath>forestloopcount}([$n$])

  How many times has the loop repeated until now?

  The optional argument $n$ ($n\geq0$) specifies the level of embedding to provide information for;
  the default is to count the repetitions of the current, most deeply embedded loop.
  
\end{syntax}


\subsection{Dynamic tree}
\label{ref:dynamic}

The following keys can be used to change the geometry of the tree by creating new nodes and
integrating them into the tree, moving and copying nodes around the tree, and removing nodes from
the tree.

The \meta{node} that will be (re)integrated into the tree can be specified in the following ways:
\begin{syntax}
\item \meta{empty}: uses the last non-integrated (i.e.\ created/removed/replaced) node.
  \begin{advise}
    \item This node can also be referred to using nodewalk step \index{last dynamic node}.
    \item The list of all such nodes is automatically saved in named nodewalk \indexdef{named
        nodewalk>dynamic nodes}, to be \index{load}ed when needed.
  \end{advise}
\item \meta{node}: a new node is created using the given bracket representation (the node may
  contain children, i.e.\ a tree may be specified), and used as the argument to the key.

  The bracket representation must be enclosed in brackets, which will usually be enclosed in
  braces to prevent them being parsed while parsing the ``host tree.''
  \begin{advise}
  \item Unlike the bracket representation in a \index{environment>forest} environment, the bracket
    representation of a dynamically created node \emph{must} start with |[|. Specifically, it cannot
    begin with a preamble or the action character.
  \end{advise}
\item \index{relative node name}: the node \meta{relative node name} resolves to will be used.
\end{syntax}

A dynamic tree operation is made in two steps:
\begin{itemize}
\item If the argument is given by a \meta{node} argument, the new node is created immediately,
  i.e.\ while the dynamic tree key is being processed.  Any options of the new node are
  implicitely \index{delay}ed. 
\item The requested changes in the tree structure are actually made between the cycles of keylist
  processing.
\end{itemize}

\begin{advise}
\item Such a two-stage approach is employed because changing the tree structure during the dynamic
  tree key processing would lead to an unmanageable order of keylist processing.
\item A consequence of this approach is that nested dynamic tree keys take several cycles to
  complete.  Therefore, be careful when using \index{delay} and dynamic tree keys simultaneously: in
  such a case, it is often safer to use \index{before typesetting nodes} instead of \index{delay},
  see example (\ref{ex:append}), and it is also possible to define additional stages, see
  \S\ref{sec:workflow}.
\item Examples: title page (in style |random tree|) and (\ref{ex:niceemptynodes}) (in style
  |xlist|).
\end{advise}

Here is the list of dynamic tree keys:

\begin{syntax}
\indexitem{dynamic tree>append}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The specified node becomes the new final child of the current node.  If the specified node had a
  parent, it is first removed from its old position.
  
\begin{forestexample}[label=ex:append,point=append,index={append,delay,for step,tree,readonly option>n,content,readonly option>n',repeat}]
  \begin{forest}
    before typesetting nodes={for tree={
      if n=1{content=L}
           {if n'=1{content=R}
                    {content=C}}}}
    [,repeat=2{append={[
      ,repeat=3{append={[]}}
    ]}}]
  \end{forest}
\end{forestexample}

\indexitem{dynamic tree>create}|=[|\meta{node}|]|

Create a new node. The new node becomes the last node.

\indexitem{dynamic tree>create'}|=[|\meta{node}|]|

Create a new node and process its given options immediately.  The new node becomes the last node.

\indexitem{dynamic tree>insert after}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The specified node becomes the new following sibling of the current node.  If the specified node had a
  parent, it is first removed from its old position.
  
\indexitem{dynamic tree>insert before}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The specified node becomes the new previous sibling of the current node.  If the specified node had a
  parent, it is first removed from its old position.
  
\indexitem{dynamic tree>prepend}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The specified node becomes the new first child of the current node.  If the specified node had a
  parent, it is first removed from its old position.
  
\indexitem{dynamic tree>remove}

The current node is removed from the tree and becomes the last node.

The node itself is not deleted: it is just not integrated in the tree anymore.  Removing the root
node has no effect.

\indexitem{dynamic tree>replace by}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

  The current node is replaced by the specified node.  The current node becomes the last node.

  If the specified node is a new node containing a dynamic tree key, it can refer to the replaced
  node by the \meta{empty} specification.  This works even if multiple replacements are made.
  
  If \keyname{replace by} is used on the root node, the ``replacement'' becomes the root node
  (\index{set root} is used). 

\end{syntax}

If given an existing node, most of the above keys \emph{move} this node
(and its subtree, of course).  Below are the versions of these operations which rather \emph{copy}
the node: either the whole subtree (|'|) or just the node itself (|''|).
\begin{syntax}
\indexitem{dynamic tree>append'}, \indexdef{dynamic tree>insert after'}, \indexdef{dynamic tree>insert before'}, \indexdef{dynamic tree>prepend'},
  \indexdef{dynamic tree>replace by'}

  Same as versions without |'| (also the same arguments), but it is the copy of the specified node
  and its subtree that is integrated in the new place.
\indexitem{dynamic tree>append''}, \indexdef{dynamic tree>insert after''}, \indexdef{dynamic tree>insert before''}, \indexdef{dynamic tree>prepend''},
  \indexdef{dynamic tree>replace by''}

  Same as versions without |''| (also the same arguments), but it is the copy of the specified node
  (without its subtree) that is integrated in the new place.

\begin{advise}
\item You might want to \index{delay} the processing of the copying operations, giving the
  original nodes the chance to process their keys first!
\end{advise}

\indexitem{dynamic tree>copy name template}|=|\meta{empty}\OR\meta{macro definition} \hfill\meta{empty}

Defines a template for constructing the \index{option>name} of the copy from the name of the
original.  \meta{macro definition} should be either empty (then, the \index{option>name} is
constructed from the \index{readonly option>id}, as usual), or an expandable macro taking one argument (the
name of the original).

\begin{forestexample}
  \begin{forest}
    copy name template={copy of #1}
    [CP,delay={prepend'=subject}
      [VP[DP,name=subject[D][NP]][V'[V][DP]]]]
    \draw[->,dotted] (subject)--(copy of subject);
  \end{forest}
\end{forestexample}

\indexitem{dynamic tree>set root}|=|\meta{empty}\OR|[|\meta{node}|]|\OR\meta{relative node name}

The specified node becomes the new \emph{formal} root of the tree.

Note: If the specified node has a parent, it is \emph{not} removed from it.  The node becomes the
root only in the sense that the default implementation of stage-processing will consider it a
root, and thus typeset/pack/draw the (sub)tree rooted in this root.  The processing of keys such
as \index{for step=\index{step>parent}} and \index{for step=\index{root}} is not affected: \index{for step=\index{root}} finds the
real, geometric root of the current node.  To access the formal root, use nodewalk step
\index{root'}, or the corresponding propagator \index{for step=\index{root'}}.

\indexitem{dynamic tree>sort}, \indexdef{dynamic tree>sort'} Sort the children of the current node,
  using the currently active sort key specified in \index{sort by} (see
  \S\ref{ref:nodewalk-operations}).  |sort| sorts in ascending and |sort'| in descending order.

\end{syntax}


\subsection{Handlers}
\label{ref:handlers}

Handlers are a powerful mechanism of |pgfkeys|, documented in \citep[\S82.3.5]{tikzpgf3.0.0}.
Handlers defined by \foRest; perform a computation and invoke the handled key with its result. The
simple handlers are documented in this section: for \index{handler>process}, see
\S\ref{ref:argument-processor}; for aggregate function handlers, see
\S\ref{ref:aggregate-functions}.

\begin{syntax}
\indexitem{handler>option}|=|\meta{option}

The result is the value of \meta{option} at the current node.

\indexitem{handler>register}|=|\meta{register}

The result is the value of \meta{register}.

\indexitem{handler>pgfmath}|=|\meta{pgfmath expression}

The result is the evaluation of \meta{pgfmath expression} in the context of the current node.

\begin{advise}
\item 
  If you only need to access an option or register value, using \index{handler>option} or
  \index{handler>register} is much faster than using \keyname{.pgfmath}.
\end{advise}

\indexitem{handler>wrap value}|=|\meta{macro definition}

The result is the (single) expansion of the given
  \meta{macro definition}.  The defined macro takes one parameter.  The current value of the
  handled option will be passed as that parameter.
  
\indexitem{handler>wrap $n$ pgfmath args}|=|\meta{macro definition}\meta{arg $1$}\dots\meta{arg $n$}

  The result is the (single) expansion of the given \meta{macro definition}.  The defined macro
  takes $n$ parameters, where $n\in\{2,\dots,8\}$.  Expressions \meta{arg $1$} to \meta{arg $n$}
  are evaluated using |pgfmath| and passed as arguments to the defined macro.
  
\indexitem{handler>wrap pgfmath arg}|=|\meta{macro definition}\meta{arg}

  Like  \index{wrap $n$ pgfmath args} would work for $n=1$.


\end{syntax}

\subsection{Argument processor}
\label{ref:argument-processor}

For a gentle(r) introduction to the argument processor, see \S\ref{tut:wrapping}.

The argument processor takes a sequence of instructions and an arbitrary number of arguments and
transforms the given arguments according to the instructions. This is the generic form of a process
expression:

\begin{syntax}
  \item \indexdef{meta>process} = \meta{instructions}\meta{arg $1$}\dots\meta{arg $n$}
\end{syntax}

There are three ways to invoke the argument processor: via handler \index{handler>process}, as one
of the two alternatives of a \index{forestmath} expression and recursively, by its instruction
\index{processor>P}.

\begin{syntax}
  
\indexitem{handler>process}|=|\index{meta>process}

The result of the computation is passed on to the handled key as a sequence of arguments.  When the
argument processor is invoked this way, any number of items can be returned.\footnote{For backward
  compatibility, \index{handler>process} is also available as \indexdef{handler>process args}.}

\item \indexdef{meta>forestmath} = \meta{pgfmath}\OR|>|\index{meta>process}

  In words, a \index{forestmath} expression is either a \meta{pgfmath} expression or an argument
  processor expression (\index{meta>process}) prefixed by |>|.
  
  In other words, \FoRest; accepts an argument processor expression anywhere it accepts a
  \meta{pgfmath} expression.\footnote{The only exceptions to the above rule are handler
    \index{pgfmath} and argument processor instruction \index{processor>P}.}  To indicate that we're
  providing an argument processor expression, we prefix it with |>|.

  When the argument processor is invoked this way, it should return a single item.
  
\end{syntax}


\begin{table}
  \centering
  \tikzexternaldisable
  \bracketset{action character=!}%
  \begin{forest}
    phantom,
    for tree={
      grow'=0, no edge, inner sep=0, outer sep=0,
    },
    delay={
      sort by={>O+t+c{content}},
      sort,
    },
    before typesetting nodes={
      for children={
        content={\index{processor>#1}},
        for children={
          content+={\phantom{(%)
            }}}}},
    define long step={from to}{n args=2}{
      tempcounta=#2,
      n=#1,
      while/.process=Rw{tempcounta}{n()<##1}{next}
    },
    draw tree stage/.style={
      for root'={
        if n children=0{% so that we don't get an error on the first run
        }{
          draw tree processing order/.nodewalk style={branch={{from to={1}{round(n_children()/3)}},tree}}, draw tree, TeX={~~},
          draw tree processing order/.nodewalk style={branch={{from to={1+round(n_children()/3)}{2*round(n_children()/3)}},tree}}, draw tree, TeX={~~},
          draw tree processing order/.nodewalk style={branch={{from to={1+2*round(n_children()/3)}{n_children()}},tree}}, draw tree,
        }
      }
    }
    [!\bigbadprocesslist]
  \end{forest}%
  \caption{Argument processor instructions}
  \label{tab:allargprocins}
\end{table}


The syntax of argument processor is a cross between |expl3|'s function argument specification and a
Turing machine, spiced with a bit of reversed Polish notation. ;-)

Think of \meta{instructions} as a program and \meta{arg $1$}\dots\meta{arg $n$} as the data that
this program operates on.

If you're familiar with Turing machines: like a Turing machine, the argument processor has a notion
of a head; unlike a Turing machine, the argument processor head is positioned not over some
argument, but between two arguments.  If you're not familiar with Turing machines: imagine the
arguments as items on a tape and the argument processor as a head that is always located between
some two items.  As the head is between two arguments, we can talk about the arguments on the left
and the arguments on the right.

In general, an instruction will take some items from the left and some from the right (deleting them
from the tape), perform some computation and insert the result on the tape, some result items to the
left and some to the right.  However, most instructions simply take an item from the right, do
something with it, and put the (single-item) result to the left; in effect, the head is moved one
item to the right.  At the beggining, all the arguments are always on the right, so the general idea
is that the program will walk through the given arguments, processing them in order.

Descriptions of individual instructions, given below, contain (at the right edge of the page) the
argument specification, which tells us about the number of input and output items and the movement
of the head.  The input and output are separated by an arrow ($\longrightarrow$), and the green eye
(\textcolor{darkgreen}{\eye}) signifies the position of the head with respect to the (input or
output) items.

For example, instruction \index{processor>O}, which converts an option name into the option value,
exemplifies the most common scenario: it takes one argument from the right and puts the result to
the left (in other words, the head moves one item to the right).  Wrapping instrucion
\index{processor>w} is more complicated. Given instruction \index{processor>w}$n$, the argument
processor takes one argument from the right (the wrapping macro body) and $n$ items from the left
(which become the arguments of the wrapping macro), and puts the resulting item to the left.
Comparisons and boolean operations are the instructions resembling the reverse Polish notation: they
take the arguments from the left and put the result to the left, as well.  Finally, it is worth
mentioning instructions \index{processor>noop} and \index{processor>+}, which simply move the head
to the right and left, respectively; given that the usual movement of the head is to the right,
\index{processor>+} can be thought of as a process-the-argument-again instruction.


Before we finally list the available instructions, some notes:
\begin{itemize}
\item \meta{Instructions} may be given in braces or not.  If not, everything until the first opening
  brace is considered to be an instruction.
\item An argument item (\meta{arg$_k$}) is a standard \TeX\ macro argument: either a token or a
  braced token list.  (The obvious exception: \meta{arg$_1$} needs to be braced if it follows
  braceless instructions.)
\item Spaces in \meta{instructions} and between arguments are ignored. Format your \index{handler>process}
  as you wish!
\item Instructions followed by [$n$] below take an optional numeric modifier.
  \begin{itemize}
  \item The modifier should be given within the instruction string itself, immediately following the
    instruction.  In particular, no spaces are allowed there.  (Sorry for the little white lie
    above.)  The number should not be enclosed in braces, even if it is more than one digit long.
  \item This modifier is always optional: its default value varies from instruction to instruction.
    (Providing $0$ means to use the default.)
  \item Unless noted otherwise, the optional numerical argument $n$ instruct the argument processor
    to repeat the previous instruction $n$ times (by default, 1). For example,
    \index{processor>O}|3| is equivalent to
    \index{processor>O}\index{processor>O}\index{processor>O}.
  \end{itemize}
\end{itemize}

\makeatletter
\NewDocumentEnvironment{indexitemprocessinstruction}{
  D(){} % default
  O{} % \index []
  m % instruction char
  o % form of instruction char, if different from #3
  D(){} % instruction modifiers
  m % first line
  >{\ReverseBoolean} s % typeset processor signature?
  >{\SplitArgument {3} {&} } m % processor signature
}{%
  \write\@auxout{\unexpanded{\gappto\bigbadprocesslist{[{#3}[{#6}]]}}}%
  \IfValueTF{#4}{%
    \indexitem(#1)[set={form={#4},index form={#4{\protect\ \protect\rm\protect\scriptsize (#6)}},#2}]{processor>#3}#5 #6%
  }{%
    \indexitem(#1)[set={index form={#3{\protect\ \protect\rm\protect\scriptsize (#6)}},#2}]{processor>#3}#5 #6%
  }%
  \IfBooleanT{#7}{\hfill\processorsignature#8}%

}{}
\makeatother

\newcommand\processorsignature[4]{%
  #1 \textcolor{darkgreen}{\eye} #2
  $\longrightarrow$
  #3 \textcolor{darkgreen}{\eye} #4%
}


\begin{syntax}
  
\begin{indexitemprocessinstruction}[index key=_]{noop}[\_]([$n$]){no-op}
  {&\meta{arg}&\meta{arg}&}
  
  The argument is not processed, but simply skipped over.  In other words, this instruction only
  moves the head one item to the right. (This is like |expl3|'s argument specifier |n|.)

  $n$ means repetition.
  
  When the end of the instructions is reached, any remaining arguments on the right are processed
  using this no-op instruction.
  
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{o}([$n$]){expand \protect\emph{o}nce}
    {&\meta{arg}&\meta{result}&}

    \meta{arg} is expanded once.  (This is like |expl3|'s argument specifier |o|).

    The operation is repeated $n$ times (default, one) without moving the head between the
    repetition.  For example, |o3| expands the argument three times (and then moves the head right).
\end{indexitemprocessinstruction}
  
\begin{indexitemprocessinstruction}{x}{fully e\protect\emph{x}pand}
  {&\meta{arg}&\meta{result}&}

  \meta{arg} is fully expanded using |\edef|.   (This is like |expl3|'s argument specifier |x|.)
\end{indexitemprocessinstruction}
  
\begin{indexitemprocessinstruction}{O}([$n$]){\protect\emph{o}ption}
  {&\meta{option}&\meta{result}&}

  \meta{option}=\alternative{\meta{option name},\meta{relative node name}\texttt{.}\meta{option name}}

  In the former case, \meta{result} is the value of option at the current node, in the latter, the
  value of option at the node referred to by \meta{relative node name}.

  $n$ means repetition.
  
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{R}([$n$]){\protect\emph{r}egister}
  {&\meta{register}&\meta{result}&}
  
  \meta{result} is the value of register \meta{register}.

  $n$ means repetition.
  
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{p}([$n$]){\protect\emph{p}rocess}
  {&\index{meta>process}&\meta{result}&}

  Execute an embedded call of the argument processor.
  The embedded argument processor may return any number of items.

  $n$ means repetition.

\begin{forestexample}[index={processor>p,processor>O,processor>w,processor>noop,grow',forked edges,content,handler>process}]
  \begin{forest}
    grow'=0, phantom, 
    delay={for children={
      content/.process={_O= ? ~p~}
        {}{content}
        {_{No content was given, so there's nothing to do.}}
        {Ow1{content}{We have content (##1), so we compute:
                      $##1+42=\the\numexpr ##1+42$}}
      }}
    [[][3][][5]]
  \end{forest}
\end{forestexample}
  
  
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{P}([$n$]){\protect\emph{p}gfmath}
  {&\meta{pgfmath}&\meta{result}&}
 
  \meta{result} is the result of evaluating \meta{pgfmath expr} using |\pgfmathparse|.

  $n$ means repetition.

  Combining \index{processor>P} and \index{processor>w}, \index{handler>process} is capable of anything
  \index{wrap $n$ pgfmath args} can do.  Even better, as we can combine pgfmath and non-pgfmath
  methods, computations that use \index{handler>process} can be (much!) faster.  Study the following
  examples to see how less and less pgfmath is used to achieve the same result --- but note that
  such extreme antipgfmathism probably only makes sense for style/package developers in computations
  that get performed many times.

\begin{forestexample}[index={handler>process,processor>w,processor>O,processor>W,processor>P,processor>+}]
  \begin{forest} 
    [,grow'=east, where level=1{}{phantom,ignore,ignore edge}
      [(a),delay={content/.wrap 4 pgfmath args={#1 $#2*#3=#4$}
           {content}{content("!1")}{content("!2")}{int(content("!1")*content("!2"))}}
        [6][7]]
      [(b),delay={content/.process={O OO~P~ w4}
        {content}
        {!1.content}{!2.content}{int(content("!1")*content("!2"))}
        {#1 $#2*#3=#4$}}
        [6][7]]
      [(c),delay={content/.process={O OO ~W2+P~ w4}
        {content}
        {!1.content}{!2.content}{int(#1*#2)}
        {#1 $#2*#3=#4$}}
        [6][7]]
      [(d),delay={content/.process={O OO ~W2+n~ w4}
        {content}
        {!1.content}{!2.content}{#1*#2}
        {#1 $#2*#3=#4$}}
        [6][7]]
    ]
  \end{forest}
\end{forestexample}

  
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{n}([$n$]){\protect\emph{n}umexpr}
  {&\meta{numexpr}&\meta{result}&}

  \meta{result} is the result of evaluating \meta{dimexpr} using e\TeX's |\number\numexpr|.

  $n$ means repetition.
  
\end{indexitemprocessinstruction}
    
\begin{indexitemprocessinstruction}{d}([$n$]){\protect\emph{d}imexpr}
  {&\meta{dimexpr}&\meta{result}&}

  \meta{result} is the result of evaluating \meta{dimexpr} using e\TeX's |\the\dimexpr|.

  $n$ means repetition.
  
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{+}([$n$]){chain instructions}
  {\meta{arg}&&&\meta{arg}}

  This action allows one to ``process the same argument more than once''.  It does not process the
  current argument (in fact, there need not be any current argument), but rather moves the last
  result back in the argument queue.  In other words, our machine's head moves one step left. You
  can also imagine it as an inverse of \index{processor>noop}.

  $n$ means repetition.
  
\end{indexitemprocessinstruction}

\begin{forestexample}[index={handler>process,processor>O,processor>noop}]
  \begin{forest}
    test/.style n args={3}{align=center,
      content={The value of my option \texttt{#1} is \texttt{#2}.\\#3}}
    [~fit~,delay={test/.process={O ~O+O~}{content}~{content}~{Yes it is!}}]
  \end{forest}
\end{forestexample}


\begin{indexitemprocessinstruction}{w}([$n$]){(consuming) \protect\emph{w}rap}
  {\meta{arg$_{1}$}\dots\meta{arg$_{n}$}&\meta{macro body}&\meta{result}&}
\end{indexitemprocessinstruction}
\itemnosep[2pt]
\begin{indexitemprocessinstruction}{W}([$n$]){(non-consuming) \protect\emph{w}rap}
  {\meta{arg$_{1}$}\dots\meta{arg$_{n}$}&\meta{macro body}&
    \meta{arg$_{1}$}\dots\meta{arg$_{n}$}\meta{result}&}

  Defines a temporary macro with $n$ undelimited arguments using the \meta{macro body} given on the
  right and expands it (once).  The arguments given to the temporary macro are taken from the left:
  \meta{arg$_{1}$}\dots\meta{arg$_{n}$}.  The result of the expansion is stored as \meta{result} to
  the right.

  With |w|, \meta{arg$_{1}$}\dots\meta{arg$_{n}$} are ``consumed'', i.e.\ they are removed from the
  result list on the left.  |W| keeps \meta{arg$_{1}$}\dots\meta{arg$_{n}$} in the result list.

  Default $n$ is 1. (Specifying $n>9$ raises an error.)
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}[index key=\&]{and}[\&]([$n$]){boolean ``and''}*{}
\end{indexitemprocessinstruction}  
\itemnosep[2pt]
\begin{indexitemprocessinstruction}[index key=\&or]{or}[\protect\indexpipe]([$n$]){boolean ``or''}
  {\protect\meta{arg$_{1}$}\protect\meta{arg$_{2}$}&&\meta{result}&}
  
  \meta{result} is a boolean conjunction/disjunction of $n$ arguments. The arguments are taken from
  the left.  They should be numbers (positive integers): |0| means false, any other number means
  true.  The \meta{result} is always |0| or |1|.

  Default $n$ is 2.
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}[index key=!]{not}[!]{boolean ``not''}
  {\meta{arg}&&\meta{result}&}

  \meta{result} is a boolean negation of the argument.  The argument is taken from the left.  It
  should be a number (positive integer): |0| means false, any other number means true.  The
  \meta{result} is always |0| or |1|.
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{?}{conditional (if \protect\dots\ then \protect\dots\ else)}
  {\meta{condition}&\meta{true arg}\meta{false arg}&&\meta{result}}

  \meta{result} is \meta{true arg} is \meta{condition} is true (non-zero), otherwise \meta{false
    arg}.

  The condition is taken from the left.  The true and false arguments are expected on the right,
  where the winner is left as well.
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}[index key={=}]{equal}[=]{comparison: $\protect\meta{arg$_{1}$}=\protect\meta{arg$_{2}$}$?}*{}
\end{indexitemprocessinstruction}
\itemnosep[1pt]
\begin{indexitemprocessinstruction}[index key={<}]{lt}[<]{comparison: $\protect\meta{arg$_{1}$}<\protect\meta{arg$_{2}$}$?}*{}
\end{indexitemprocessinstruction}
\itemnosep[1pt]
\begin{indexitemprocessinstruction}[index key={<<}]{gt}[\protect\greaterthan]{comparison: $\protect\meta{arg$_{1}$}\protect\greaterthan\protect\meta{arg$_{2}$}$?}
  {\meta{arg$_{1}$}\meta{arg$_{2}$}&&\meta{result}&}

  Compare \meta{arg$_{1}$} and \meta{arg$_{2}$}, returning |1| (true) if \meta{arg$_{1}$} is equal
  to / less than / greater than \meta{arg$_{2}$}, |0| (false) otherwise.

  The arguments are taken from the left.  They can be either numbers, dimensions, text or token
  lists.  Both arguments are expected to be of the same type.  The type of comparison is determined
  by the type of the result returned by the last instruction.
  \index{processor>O}/\index{processor>R} look up the type of option/register to determine the type
  (booleans are numbers and keylists are toks).  Text type must be marked explicitely using
  \index{processor>t}.

  Comparison is carried out using |\ifnum| for numbers, |\ifdim| for dimensions (this includes
  unitless decimals returned by pgfmath) and |\pdfstrcmp|\footnote{\texttt{\string\pdfstrcmp}
    expands its arguments.} for text --- for these three types, all three comparison operators are
  supported.  For generic token lists, only |=| makes sense and is carried out using |\ifx|.

  In the following example, (a) performs lexicographical comparison because we have marked |21| as
  text; (b) and (c) perform numeric comparison: in (b), the type is automatically determined from
  the type of register \indexex{tempcounta}, in (c) |21| is marked manually using \index{processor>n}.

\begin{forestexample}[index={if,processor>gt,processor>lt}]
  \forestset{
    tempcounta=100,
    TeX/.process={Rw1}{tempcounta}{$#1>21$?\ },
    TeX={(a)\ }, if={>{Rt>}{tempcounta}{21}}{TeX=yes}{TeX=no},TeX={,\ },
    TeX={(b)\ }, if={>{_R<}{21}{tempcounta}}{TeX=yes}{TeX=no},TeX={,\ },
    TeX={(c)\ }, if={>{Rn>}{tempcounta}{21}}{TeX=yes}{TeX=no},
  }
\end{forestexample}

\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{t}{mark as \protect\emph{t}ext}
  {&\meta{arg}&\meta{arg}&}

  The result is not changed, only its type is changed to text.  This is relevant only for
  comparisons --- both argument processor's comparisons \index{processor>equal}, \index{processor>gt}
  and \index{processor>lt} and sort keys (see \index{sort by}).
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{c}{to lowercase}  
  {&\meta{arg}&\meta{result}&}
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{C}{to uppercase}  
  {&\meta{arg}&\meta{result}&}
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{-}{toggle ascending/descending order (negate)}
  {\meta{arg}&&\meta{result}&}

  If the argument is of the text type, its sorting order is changed from ascending to descending or
  vice versa.

  For any numerical argument type (number, dimension, unitless dimension), the argument is actually
  negated, which obviously has the same effect on sorting.

  For generic type arguments, this operation is a no-op.
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{u}{\protect\emph{u}ngroup}
  {&\meta{arg}&&\meta{item$_1$}\dots\meta{item$_n$}}

  As every \TeX\ undelimited macro argument, \meta{arg} is a list of tokens or braced token lists.
  This instruction puts those items back to the right as ``separate arguments''.
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{s}([$n$]){(consuming) \protect\emph{s}ave}
  {\meta{arg$_{1}$}\dots\meta{arg$_{n}$}&&&}
\end{indexitemprocessinstruction}
\itemnosep[2pt]
\begin{indexitemprocessinstruction}{S}([$n$]){(non-consuming) \protect\emph{s}ave}
  {\meta{arg$_{1}$}\dots\meta{arg$_{n}$}&&\meta{arg$_{1}$}\dots\meta{arg$_{n}$}&}

  Saves the last $n$ arguments from the left into a ``special place''.  

  With |s|, \meta{arg$_{1}$}\dots\meta{arg$_{n}$} are ``consumed'', i.e.\ they are removed from the
  result list on the left.  |S| keeps \meta{arg$_{1}$}\dots\meta{arg$_{n}$} in the result list.

  Default $n$ is 1.
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{l}([$n$]){(consuming) \protect\emph{l}oad}
  {&&\meta{arg$_{1}$}\dots\meta{arg$_{n}$}&}
\end{indexitemprocessinstruction}
\itemnosep[2pt]
\begin{indexitemprocessinstruction}{L}([$n$]){(non-consuming) \protect\emph{l}oad}
  {&&\meta{arg$_{1}$}\dots\meta{arg$_{n}$}&}

  Loads last $n$ arguments from the ``special place'' to the left.

  With |l|, \meta{arg$_{1}$}\dots\meta{arg$_{n}$} are ``consumed'', i.e.\ they are removed from the
  special place.  |S| keeps \meta{arg$_{1}$}\dots\meta{arg$_{n}$} in the special place.

  The default $n$ is 0 and indicates that the entire special place should be loaded.
\end{indexitemprocessinstruction}

\begin{indexitemprocessinstruction}{r}{\protect\emph{r}everse (key)list}
  {&\meta{list}&\meta{result}&}

  \meta{list} should be a comma-separated list (\emph{not} a name of a keylist option or register).
  \meta{result} contains the same elements in the reverse order.
\end{indexitemprocessinstruction}

\end{syntax}



  

\subsection{Aggregate functions}
\label{ref:aggregate-functions}

Aggregate functions walk a nodewalk and use the information found in the visited nodes to calculate
something.

All aggregate functions are available both as key handlers and |pgfmath| functions.



\begin{syntax}
  \indexitem{aggregate>count}|=|\meta{nodewalk},
  \indexdef[form={aggregate_count}]{pgfmath>aggregate count}|("|\meta{nodewalk}|")|

  Store the number of nodes visited in the nodewalk into the handled option.
  
\indexitem{aggregate>sum}|=|\index{forestmath}\meta{nodewalk},
\indexdef[form={aggregate_sum}]{pgfmath>aggregate sum}|("|\index{forestmath}|","|\meta{nodewalk}|")|
\itemnosep

\indexitem{aggregate>average}|=|\index{forestmath}\meta{nodewalk},
\indexdef[form={aggregate_average}]{pgfmath>aggregate average}|("|\index{forestmath}|","|\meta{nodewalk}|")|
\itemnosep

\indexitem{aggregate>product}|=|\index{forestmath}\meta{nodewalk},
\indexdef[form={aggregate_product}]{pgfmath>aggregate product}|("|\index{forestmath}|","|\meta{nodewalk}|")|
\itemnosep

\indexitem{aggregate>min}|=|\index{forestmath}\meta{nodewalk},
\indexdef[form={aggregate_min}]{pgfmath>aggregate min}|("|\index{forestmath}|","|\meta{nodewalk}|")|
\itemnosep

\indexitem{aggregate>max}|=|\index{forestmath}\meta{nodewalk},
\indexdef[form={aggregate_max}]{pgfmath>aggregate max}|("|\index{forestmath}|","|\meta{nodewalk}|")|

Calculate the value of the given \index{forestmath} expression at each visited node. Store the sum /
average / product / minimum / maximum of these values into the handled option (handlers) or return
it (pgfmath functions).

\indexitem{aggregate>aggregate}|=|\index{forestmath=start value}\index{forestmath=every
  step}\index{forestmath=after walk}\meta{nodewalk}
\itemnosep
\indexitem{pgfmath>aggregate}|("|\index{forestmath=start value}|","|\index{forestmath=every step}|","|\index{forestmath=after walk}|","|\meta{nodewalk}|")|

The generic aggregate function.  First, register \index{aggregate result} is set to
\index{forestmath=start value}.  Then, the given nodewalk is walked.  After each step of the
\meta{nodewalk}, \index{forestmath=every step} expression is evaluated in the context of the new
current node and stored into \index{aggregate result}.  After the walk, the current node is reset to
the origin.  \index{forestmath=after walk} expression is then evaluated in its context and stored
into \index{aggregate result} as the final result.

Use \index{aggregate result} and \index{aggregate n} in the \index{forestmath} expressions to refer to
the current result value and step number.

\indexitem{register>aggregate n}|=|\meta{count} the current step number

In the every-step expression of an aggregate function, refers to the (real) step number in the
aggregate's \meta{nodewalk}.  In the after-walk expression, refers to the total number of (real)
steps made.

\indexitem{register>aggregate result}|=|\meta{toks} the current value of the result

  This register is where the intermediate results are stored.

\indexitem{register>aggregate value}|=|\meta{toks} the value of the expression at the current node

This only applies to special aggregates like \index{aggregate>sum}, not to the generic
\index{aggregate>aggregate}.
  
\indexitem{node key>aggregate postparse}|=|\alternative{none,int,print,macro}

Roughly speaking, how should the result be formatted? For details, see \citep[\S89]{tikzpgf3.0.0}.
Applies only to |pgfmath| versions of aggregate functions, i.e.\ not to the |'| variants.

  \begin{syntax}
  \item\indexdef{value of=aggregate postparse>none}
    No formatting.
  \item\indexdef{value of=aggregate postparse>int}
    The result is an integer.
  \item\indexdef{value of=aggregate postparse>print}
    Use |pgf|'s number printing extension, see \citep[\S93]{tikzpgf3.0.0}.
  \item\indexdef{value of=aggregate postparse>macro}
    Use a custom macro.  Specify the macro using \indexdef{node key>aggregate postparse macro}|=|\meta{cs}.
  \end{syntax}
  
\end{syntax}

Example 1.  Randomly generate the content of leaves.  The content of a parent is the sum of its
children's content.  Note how we use \indexex{tree children-first} to proceed in a bottom-up
fashion.
  
\begin{forestexample}[index={delay,aggregate postparse,for step,tree children-first,if option,n children,content,pgfmath,sum,step>children}]
  \begin{forest}
    delay={
      aggregate postparse=int,
      for tree children-first={
        if n children=0
          {content/.pgfmath={random(0,100)}}
          {content/~.sum~={content}{children}}
      }
    }
    [[[[][]][]][[][][[][][]]][[][[][]]]]
  \end{forest}
\end{forestexample}

  Example 2: nested aggregate functions.  We are given the black numbers.  The inner aggregate, the
  sum of children, is applied at every blue node. (See how we actually display the blue numbers by
  storing \index{aggregate value} to \index{content}.)  The outer aggregate stores the maximum blue
  number into the red root.

\begin{forestexample}
  \begin{forest}
    delay={
      aggregate postparse=int,
      content/~.max~=%
        {~aggregate_sum~("content","children")}%
        {every step={content/.register=~aggregate value~},children}%
    } [ [[1][2][3]] [[3][4][5]] [[2][3][4]] ]
  \end{forest}
\end{forestexample}

Example 3: calculate root mean square of children using the generic \index{aggregate>aggregate} handler.

\begin{forestexample}
  \begin{forest}
    delay={
      content/~.aggregate~=
        {0}{~aggregate_result~()+content()^2}{sqrt(~aggregate_result~/~aggregate_n~)}
        {children}
    }
    [[0][1][2][3][4]]
  \end{forest}
\end{forestexample}

\subsection{Relative node names}
\label{ref:relative-node-names}

\begin{syntax}
\indexitem{meta>relative node name}|=|[\meta{forest node name}][\indexdef[set={code}]>{!}\meta{nodewalk}]

  \meta{relative node name} refers to the \foRest; node at the end of the \meta{nodewalk}
  starting at node named \meta{forest node name}.  If \meta{forest node name} is omitted, the walk
  starts at the current node.  If \meta{nodewalk} is omitted, the ``walk'' ends at the start
  node.   (Thus, an empty \meta{relative node name} refers to the current node.)

  The \meta{nodewalk} inherits its history from the outer nodewalk (if there is one).  Its every-step
  keylist is empty.
\end{syntax}

Relative node names can be used in the following contexts:
\begin{itemize}
\item \FoRest;'s |pgfmath| option functions (\S\ref{ref:pgfmath}) take a relative node name as
  their argument, e.g.\ |content("!u")| and |content("!parent")| refer to the content of the
  parent node.
\item An option of a non-current node can be set by \meta{relative node name}|.|\meta{option
  name}|=|\meta{value}, see \S\ref{sec:option-setting}.
\item The |forest| coordinate system, both explicit and implicit; see \S\ref{ref:forest-cs}.
\end{itemize}

\subsection{The \texttt{forest} coordinate system}
\label{ref:forest-cs}

Unless package options \index{tikzcshack} is set to |false|, \TikZ;'s implicit node coordinate
system \citep[\S13.2.3]{tikzpgf2.10} is hacked to accept relative node names.\footnote{Actually,
the hack can be switched on and off on the fly, using \cmdname{i}\keyname{foresttikzcshack}.}.

The explicit \texttt{forest} coordinate system is called simply |forest| and used like this:
|(forest_cs:|\meta{forest cs spec}|)|; see \citep[\S13.2.5]{tikzpgf2.10}.  \meta{forest cs spec}
is a keylist; the following keys are accepted.

\begin{syntax}
\indexitem{forest cs>name}|=|\meta{node name}  The node with the given name becomes the current node.  The
resulting point is its (node) anchor.
\indexitem{forest cs>id}|=|\meta{node id}  The node with the given name becomes the current node. The
resulting point is its (node) anchor.
\indexitem{forest cs>go}|=|\meta{nodewalk} Walk the given nodewalk, starting at the current node.  The
  node at the end of the walk becomes the current node.  The resulting point is its (node) anchor.
  The embedded \meta{nodewalk} inherits history from the outer nodewalk.
\indexitem{forest cs>anchor}|=|\meta{anchor}  The resulting point is the given anchor of the current node.
\indexitem{forest cs>l}|=|\meta{dimen} \vspace{-\parskip}
\indexitem{forest cs>s}|=|\meta{dimen}  Specify the \index{option>l} and \index{option>s}
coordinate of the resulting point.

The coordinate system is the node's ls-coordinate system: its origin is at its (node) anchor; the
l-axis points in the direction of the tree growth at the node, which is given by option
\index{grow};  the s-axis is orthogonal to the l-axis; the positive side is in the
counter-clockwise direction from |l| axis.

The resulting point is computed only after both \index{option>l} and \index{option>s} were given. 
\item Any other key is interpreted as a \index{relative node name}[.\meta{anchor}].
\end{syntax}


\subsection{Anchors}
\label{sec:anchors}

\FoRest; defines several anchors which can be used with any \TikZ; node belonging to a \FoRest;
tree (manually added \TikZ; nodes are thus excluded).

\newcommand\indexdefneganchor[1]{\indexdef[index key=#1]{anchor>-#1}}
\begin{syntax}
\indexitem{anchor>parent anchor}\itemnosep
\indexitem{anchor>child anchor}\itemnosep
\indexitem{anchor>anchor}

  These anchors point to coordinates determined by node options \index{option>parent anchor},
  \index{option>child anchor} and \index{option>anchor}.

\indexitem{anchor>parent}, \indexdef{anchor>parent'}, \indexdefneganchor{parent}, \indexdefneganchor{parent'}\itemnosep
\indexitem{anchor>parent first}, \indexdef{anchor>parent first'}, \indexdefneganchor{parent first}, \indexdefneganchor{parent first'}\itemnosep
\indexitem{anchor>first}, \indexdef{anchor>first'}\itemnosep
\indexitem{anchor>children first}, \indexdef{anchor>children first'}, \indexdefneganchor{children first}, \indexdefneganchor{children first'}\itemnosep
\indexitem{anchor>children}, \indexdef{anchor>children'}, \indexdefneganchor{children}, \indexdefneganchor{children'}\itemnosep
\indexitem{anchor>children last}, \indexdef{anchor>children last'}, \indexdefneganchor{children last}, \indexdefneganchor{children last'}\itemnosep
\indexitem{anchor>last}, \indexdef{anchor>last'}\itemnosep
\indexitem{anchor>parent last}, \indexdef{anchor>parent}, \indexdefneganchor{parent last},\indexdefneganchor{parent last'}

Growth direction based anchors.

  \TikZ;'s ``compass anchors'' |east|, |north| etc.\ resolve to coordinates on the border of the
  node facing east, north etc.\ (for the shapes that define these anchors).  The above \FoRest;'s
  anchors are similar in that they also resolve to coordinates on the border of the node.  However,
  the ``cardinal directions'' are determined by the \index{grow}th direction of the tree in the node
  and its parent:
  
  \begin{itemize}
  \item anchor |parent| faces the parent node (or, in case of the root, where the parent would be);
  \item anchor |children| faces the children (or, in case of a node without children, where the children would be);
  \item anchor |first| faces the first child (or \dots\ you get it, right?);
  \item anchor |last| faces the last child (or \dots\ you know!).
  \end{itemize}
  Combinations like |children_first| work like combinations of compass directions, e.g.\
  |north_west|, but note that
  \begin{itemize}
  \item when |first| and |last| are combined with |parent| into |parent_first| and |parent_last|,
    they refer to the first and last child of the parent node, i.e.\ siblings of the current node.
  \end{itemize}

  While |first| and |last| always point in opposite directions, |parent| and |children| do not do so
  if the \index{grow}th direction of the tree changes in the node, i.e.\ if the node's \index{grow}
  differs from it's parent's \index{grow}.  Thus in general, it is useful to have anchors |-parent|
  and |-children|, which point in the opposite directions as |parent| and |children|, respectively,
  and their combinations with |first| and |last|.

  The |'| variants refer precisely to
  the point where the cardinal growth direction intersects the border.  Variants without |'| snap to
  the closest compass anchor of the node.
  
  These anchors work as expected even if the node is \index{rotate}d, or if the
  children are \index{reversed}.
  
  For simple examples, see definitions of \index{sn edges} and \index{roof}; for more involved
  examples, see the \reflibrary{edges} library.
\end{syntax}

\begin{forestexample}[layout=tree on top]
  \def\redorblue#1{\expandafter\redorbluei#1\END}%
  \def\redorbluei#1#2\END{\expandafter\ifx#1-red\else blue\fi}%
  \forestset{
    draw anchors/.style n args=3{% #1=above, #2=below, #3='-variant of anchor?
      tikz={
        \foreach \a in {first,last,parent first,parent last,children,children last,#1}
          {\fill[](.\a#3)circle[radius=1pt] node[above,font=\tiny,color=\redorblue\a]{\a#3};}
        \foreach \a in {-parent first,-parent,-parent last,-children,-children first,#2}
          {\fill[](.\a#3)circle[radius=1pt] node[below,font=\tiny,color=\redorblue\a]{\a#3};}
      }
    },
    draw anchors/.default={parent,children first}{-children last}{},
  }
  \begin{forest}
    for tree={
      minimum width=10em, minimum height=13ex, s sep+=5em,
      draw, draw anchors,
      font=\tt, delay={content/.process=OOw2{grow}{reversed}{grow\ifnum#2=1'\fi=#1}}
    }
    [
      [,rotate=20,draw anchors={parent,children first}{-children last}{'}]
      [,for tree={grow'=0}, l sep+=5em, draw anchors={-children last}{parent,children first}{}
        [,rotate=-60]
        []
      ]
    ]
  \end{forest}
\end{forestexample}

\subsection{Additional \texttt{pgfmath} functions}
\label{ref:pgfmath}

For every option and register, \foRest; defines a |pgfmath| function with the same name, with the
proviso that the name might be mangled in order to conform to |pgfmath|'s naming rules. Specifically, 
all non-alphanumeric characters in the option/register name and the initial number, if
the name starts with one, are replaced by an underscore |__| in the |pgfmath| function name.

Pgfmath functions corresponding to options take one argument, a \index{relative node name}
(see~\S\ref{ref:relative-node-names}) expression, making it possible to refer to option values of
non-current nodes.  The \meta{relative node name} expression must be enclosed in double quotes in
order to 
prevent pgfmath evaluation: for example, to refer to the content of the parent, write
\index{content}|("|\index>{!}|u")|.  To refer to the option of the current node, use empty parentheses:
\index{content}|()|.\footnote{In most cases, the parentheses are optional, so \texttt{content}
is ok.  A known case where this doesn't work is preceding an operator: \texttt{l+1cm} will fail.}

If the \index{relative node name} resolves to the invalid node, these functions will an return empty
token list (for \meta{toks} options), 0pt (for \meta{dimen} options) or 0 (for \meta{count}
options).

Note that the nodewalk in the relative node name inherits its history from the outer nodewalk (if
there is one), so strange but useful constructions like the following are possible.

\begin{forestexample}[index={tikz,wrap pgfmath arg,nodewalk,back,b,ancestors,register>every step}]
  \begin{forest}
    for tree={no edge},
    before typesetting nodes={
      for nodewalk={
        c,
        every step={
          tikz/.wrap pgfmath arg=
            {\draw[<-] ()--(#1);}
            {name("~!b~")}
          },
        21{up1},ancestors
      }{}
    },
    [1[2[3]][4[5]]]
  \end{forest}  
\end{forestexample}

Boolean function \indexdef{pgfmath>valid} returns true if the node's \index{readonly option>id}$\neq0$, i.e.\ if the node is a real, valid node; see \S\ref{ref:spatial-propagators} and \S\ref{ref:nodewalks}.  Boolean function \indexdef{pgfmath>invalid} is a negation of |valid|.

\begin{syntax}
\indexitem{pgfmath>min_l}|=(|\meta{nodewalk: node}|,|\meta{nodewalk: context node}|)| \itemnosep
\indexitem{pgfmath>min_s}|=(|\meta{nodewalk: node}|,|\meta{nodewalk: context node}|)| \itemnosep
\indexitem{pgfmath>max_l}|=(|\meta{nodewalk: node}|,|\meta{nodewalk: context node}|)| \itemnosep
\indexitem{pgfmath>max_s}|=(|\meta{nodewalk: node}|,|\meta{nodewalk: context node}|)|

  These functions return the minimum/maximum value of \index{option>l}/\index{option>s} of node at the end of \meta{nodewalk:
    node} in the context (i.e.\ growth direction) of node at the end of \meta{nodewalk: context
    node}.
\end{syntax}

Three string functions are also added to |pgfmath|: \indexdef{pgfmath>strequal} tests the equality of
its two arguments; \indexdef{pgfmath>instr} tests if the first string is a substring of the second one;
\indexdef{pgfmath>strcat} joins an arbitrary number of strings.

\bigskip

Some random notes on |pgfmath|: \begin{enumerate*}[(i)]
\item |&&|, \verb!||! and |!| are boolean ``and'', ``or'' and ``not'', respectively.
\item The equality operator (for numbers and dimensions) is |==|, \emph{not} |=|.
\end{enumerate*}  And some examples:

\begin{forestexample}[layout=tree on top,index={for step,tree,grow',calign,option>l,l sep,option>child
anchor,option>anchor,fit,tier,readonly option>level,delay,before typesetting nodes,content,wrap $n$ pgfmath args,pgfmath},index>={!}]
  \begin{forest}
    for tree={grow'=0,calign=first,l=0,l sep=2em,child anchor=west,anchor=base
      west,fit=band,tier/.pgfmath=~level~()},
    fullpath/.style={if n=0{}{content/.wrap 2
        pgfmath args={##1/##2}{~content~("!u")}{~content~()}}},
    delay={for tree=fullpath,content=/},
    before typesetting nodes={for tree={content=\strut#1}}
    [
      [home
        [joe
          [\TeX]]
        [saso
          [\TeX]]
        [a user with a long name
          [\TeX]]]
      [usr]]
  \end{forest}
\end{forestexample}

\begin{forestexample}[point=instr,index={delay,for step,tree,conditional>if,content,n children}]
  % mark non-phrasal terminal nodes
  \begin{forest}
    delay={for tree={if=
      {!instr("P",~content~) && ~n_children~==0}
      {fill=yellow}
      {}
    }}
    [CP[DP][C'[C][TP[DP][T'[T][VP[DP][V'[V][DP]]]]]]]
  \end{forest}
\end{forestexample}

{\def\useforestlibrary#1{}%
\begin{forestexample}[point=instr,index={where option,n children,tier,content,no edge,tikz},index>={!}]
  % roof terminal phrases
  \useforestlibrary{linguistics}
  % ...
  \begin{forest}
    delay={where n children=0{tier=word,
      if={~instr~("P",~content~("!u"))}{roof}{}
    }{}},
    [VP[DP[Mary]][V'[V[loves]][DP[her cat]]]]
  \end{forest}
\end{forestexample}}


\subsection{Standard node}
\label{ref:standard-node}

\begin{syntax}
\indexitem{macro>forestStandardNode}\meta{node}\meta{environment fingerprint}\meta{calibration
  procedure}\meta{exported options}

  This macro defines the current \emph{standard node}.  The standard node declares some options as
  \emph{exported}.  When a new node is created, the values of the exported options are initialized
  from the standard node.  At the beginning of every \index{forest} environment, it is checked whether
  the \emph{environment fingerprint} of the standard node has changed.  If it did, the standard
  node is \emph{calibrated}, adjusting the values of exported options.  The \emph{raison d'etre} for
  such a system is given in \S\ref{tut:defaults}.

  In \meta{node}, the standard node's content and possibly other options are specified, using the
  usual bracket representation.  The \meta{node}, however, \emph{must not contain children}.  The
  default: \texttt{[dj]}.

  The \meta{environment fingerprint} must be an expandable macro definition.  It's expansion
  should change whenever the calibration is necessary.

  \meta{calibration procedure} is a keylist (processed in the |/forest| path) which calculates the
  values of exported options.

  \meta{exported options} is a comma-separated list of exported options.

  This is how the default standard node is created:
\begin{lstlisting}
  \forestStandardNode[dj]
    {%
      \forestOve{\csname forest@id@of@standard node\endcsname}{content},%
      \the\ht\strutbox,\the\pgflinewidth,%
      \pgfkeysvalueof{/pgf/inner ysep},\pgfkeysvalueof{/pgf/outer ysep},%
      \pgfkeysvalueof{/pgf/inner xsep},\pgfkeysvalueof{/pgf/outer xsep}%
    }
    {
      l sep={\the\ht\strutbox+\pgfkeysvalueof{/pgf/inner ysep}},
      l={l_sep()+abs(max_y()-min_y())+2*\pgfkeysvalueof{/pgf/outer ysep}},
      s sep={2*\pgfkeysvalueof{/pgf/inner xsep}}
    }
    {l sep,l,s sep}
  \end{lstlisting}
\end{syntax}

\subsection{Externalization}
\label{ref:externalization}

Externalized tree pictures are compiled only once. The result of the compilation is saved into a
separate |.pdf| file and reused on subsequent compilations of the document.  If the code of the
tree (or the context, see below) is changed, the tree is automatically recompiled.

Externalization is enabled by:
\begin{lstlisting}
  \usepackage[~external~]{forest}
  ~\tikzexternalize~
\end{lstlisting}
Both lines are necessary.  \TikZ;'s externalization library is automatically loaded if necessary.

\begin{syntax}
\indexitem{node key>external/optimize} Parallels \keyname{/tikz/external/optimize}: if |true| (the
default), the processing of non-current trees is skipped during the embedded compilation.
\indexitem{node key>external/context} If the expansion of the macro stored in
this option changes, the tree is recompiled.
\indexitem{node key>external/depends on macro}|=|\meta{cs} Adds the definition of macro \meta{cs} to
\keyname{external/context}.  Thus, if the definition of \meta{cs} is changed, the tree will be
recompiled. 
\end{syntax}

\foRest; respects or is compatible with several (not all) keys and commands of \TikZ;'s
externalization library.  In particular, the following keys and commands might be useful; see
\cite[\S32]{tikzpgf2.10}.
\begin{itemize}
\item\keyname{/tikz/external/remake next}
\item\keyname{/tikz/external/prefix}
\item\keyname{/tikz/external/system call}
\item\cmdname{tikzexternalize}
\item\cmdname{tikzexternalenable}
\item\cmdname{tikzexternaldisable}
\end{itemize}
\FoRest; does not disturbe the externalization of non-\foRest; pictures. (At least it
shouldn't \dots)

The main auxiliary file for externalization has suffix |.for|.  The externalized pictures have
suffices |-forest-|$n$ (their prefix can be set by \keyname{/tikz/external/prefix}, e.g.\ to a
subdirectory).  Information on all trees that were ever externalized in the document (even if
they were changed or deleted) is kept.  If you need a ``clean'' |.for| file, delete it and
recompile.  Deleting |-forest-|$n$|.pdf| will result in recompilation of a specific tree.

Using \keyname{draw tree} and \keyname{draw tree'} multiple times \emph{is} compatible with
externalization, as is drawing the tree in the box (see \index{draw tree box}).  If you are
trying to externalize a \index{forest} environment which utilizes \index{TeX} to produce a
visible effect, you will probably need to use \index{TeX'} and/or \index{TeX''}.

\setcounter{CodelineNo}{0}
\DocInput{forest-libs.dtx}

\section{Gallery}
\label{sec:gallery}

\subsection{Decision tree}
\label{sec:example-decision-tree}

The following example was inspired by a question on \TeX\ Stackexchange:
\href{http://tex.stackexchange.com/questions/39103/how-to-change-the-level-distance-in-tikz-qtree-for-one-level-only}{How to change the level distance in tikz-qtree for one level only?}.  The question is about |tikz-qtree|: how to adjust the level distance for the first level only, in order to avoid first-level labels crossing the parent--child edge.  While this example solves the problem (by manually shifting the offending labels; see \texttt{elo} below), it does more: the preamble is setup so that inputing the tree is very easy.

\begin{forestexample}[layout=tree on top,index={if option,readonly option>n,no edge,tikz,strequal,strcat,option>child anchor,option>parent
anchor,option>anchor,anchor>anchor,calign,for step,tree,s sep,option>l,n children,declare toks,delay,content,before typesetting nodes,descendants,keylist+=tikz,wrap pgfmath arg,wrap $n$ pgfmath args,split option},index>={!}]
  \forestset{
    declare toks={elo}{}, % Edge Label Options
    anchors/.style={anchor=#1,child anchor=#1,parent anchor=#1},
    dot/.style={tikz+={\fill (.child anchor) circle[radius=#1];}},
    dot/.default=2pt,
    decision edge label/.style n args=3{
      edge label/.expanded={node[midway,auto=#1,anchor=#2,\forestoption{elo}]{\strut$\unexpanded{#3}$}}
    },
    decision/.style={if n=1
      {decision edge label={left}{east}{#1}}
      {decision edge label={right}{west}{#1}}
    },
    decision tree/.style={
      for tree={
        s sep=0.5em,l=8ex,
        if n children=0{anchors=north}{
          if n=1{anchors=south east}{anchors=south west}},
        math content,
      },
      anchors=south, outer sep=2pt,
      dot=3pt,for descendants=dot,
      delay={for descendants={~split option~={content}{;}{content,decision}}},
    }
  }
  \begin{forest} decision tree
    [N,plain content
      [I;{p_1=0.5},plain content,elo={yshift=4pt}
        [{5,1};a]
        [II;b,plain content
          [{1,2};m]
          [{2,3};n]
        ]
      ]
      [II;{p_2=0.5},plain content,elo={yshift=4pt}
        [;c
          [{1,0};z]
          [{2,2};t]
        ]
        [;d
          [{3,1};z]
          [{0,0};t]
        ]
      ] {\draw[dashed](!1.anchor)--(!2.anchor) node[pos=0.5,above]{I};}
    ]
  \end{forest}
\end{forestexample}

\setcounter{CodelineNo}{0}
\DocInput{forest-index.dtx}

\section{Past, present and future}
\label{sec:changes}

\paragraph{Roadmap}  What's planned for future releases?
\begin{itemize}
\item filling up the libraries
\item faster externalization
\item custom-edge aware packing algorithm and a more flexible (successor of) \index{calign}
\item support for specialized |forest| environments, including:
  \begin{itemize}
  \item selectable input parser,
  \item namespaces (different function, different options),
  \item better support for different output types.
  \end{itemize}
  In short, everything you need to make \foRest; your favourite spreadsheet! ;-)
\item code cleanup and extraction of sub-packages possibly useful to other package writers
\end{itemize}

\subsection{Changelog}
\label{sec:changelog}

First of all, the list of all \index{compat} key values for backward compatibility, and their
groupings. Remember, compat values that reside in styles with suffix |-most| are harmless: they will
not disrupt the new functionality of the package. But take care when using stuff which only resides
in |-all| styles.

\lstinputregion{forest-compat.sty}{compat_keys}

\newcommand\compatitem[2]{\item[,,in \texttt{-#1}]\texttt{compat=}\indexdef{value of=compat>#2}}

\subsubsection{v2.1}

\begin{description}
\item[v2.1.5 (2017/07/14)] \mbox{}
  Minor improvements:
  \begin{itemize}
  \item Smarter \index{baseline} defaults for the \reflibrary{linguistics} library.
  \item Yield warning when the \index{baseline} is set to a node that is not drawn (e.g.\ a
    \index{phantom} node).
  \end{itemize}
  
\item[v2.1.4 (2017/02/02)] \mbox{}
  
  Performance:
  \begin{itemize}
  \item Reimplement some internals of the packing algorithm to avoid consuming the string pool in
    documents with many trees. (We're about 10\% slower now, but (depending on the document) the
    memory usage can drop up to five times!)
  \end{itemize}

  Bugfixes:
  \begin{itemize}
  \item Fix aggregate function \index{aggregate>count}.
  \item Provide a workaround for a PGF bug: for coordinate-shaped nodes, |\positionnodelater|
    provides dimensions with |pt| in a wrong catcode, so \index{max y} and friends did not work for
    such nodes.
  \end{itemize}
  
\item[v2.1.3 (2017/01/27)] \mbox{}
  
  Bugfixes:
  \begin{itemize}
  \item Update \index{nice empty nodes} to use \index{for step=\index{current and siblings}}.
  \end{itemize}

\item[v2.1.2 (2016/12/31)] \mbox{}

  Bugfixes:
  \begin{syntax}
  \compatitem{all}{2.1.1-loops}
    A level of hash doubling was unnecessarily introduced for the \meta{keylist} argument of all
    loops (\S\ref{ref:loops}), and the \meta{nodewalk} argument of \index{process keylist'} and
    \index{process delayed}. Use this key to revert to the old behaviour.
  \end{syntax}

  Minor improvements:
  \begin{itemize}
  \item Implemented key \index{also}.
  \end{itemize}
  
\item[v2.1.1 (2016/12/18)] \mbox{}
  
  Minor improvements:
  \begin{itemize}
  \item Implemented argument processor instruction \index{processor>p}.
  \end{itemize}
  
  Bugfixes:
  \begin{itemize}
  \item Argument processor instruction \index{processor>u} introduced an extra layer of braces
    around each result item.
  \item Argument processor instructions \index{processor>l} and \index{processor>L} did not always
    load the desided number of arguments.
  \item Argument processor instructions \index{processor>and} and \index{processor>or} were taking
    the arguments from the start of the left side instead of its end.
  \end{itemize}

\item[v2.1 (2016/12/05)] \mbox{}

  Backward incompatible changes (with a \index{compat} key):
  \begin{syntax}
  \compatitem{all}{2.0-edges}
  This compat key groups the three changes listed below: the final two depend on the first, so you
  will probably want to revert them all or none.
  \begin{syntax}
    \compatitem{all}{2.0-anchors}
      This is really a bugfix. Growth direction based anchors \index{anchor>parent},
      \index{anchor>parent first} and \index{anchor>parent last} were not facing to the direction of the
      parent if the growth direction of the tree changed at the node.
    \compatitem{all}{2.0-forkededge}
    \compatitem{all}{2.0-folder}
      Update the code of keys \index{forked edge} (and friends) and \index{folder} from the
      \reflibrary{edges} library to reflect the above bugfix.
    \end{syntax}
    \compatitem{all}{2.0-delayn} Fixing yet another bug in \index{delay n}! The number of cycles was
      reevaluated at each cycle. Now it is computed immediately, and fixed. Use this key to revert to
      the old behaviour.
  \end{syntax}
  
  Performance:
  \begin{itemize}
  \item Substantially enhance the argument processor (\S\ref{ref:argument-processor}), including the
    ability to use it as a drop-in replacement for |pgfmath|.
  \item Internally, avoid using |\pgfmathparse| and friends whereever possible.
  \item Implement a fast set of macros to determine if a |pgfmath| expression is just a \meta{count}
    or \meta{dimen} expression.
  \item Optimize \index{split option} and \index{split register}.
  \end{itemize}
  Minor improvements:
  \begin{itemize}
  \item Allow \index{relative node name}s in \index{handler>option}.
  \item Make aggregate functions (\S\ref{ref:aggregate-functions}) nestable and implement their
    |pgfmath| versions.
  \item Implement
    \index{if dimen GT=\meta{dimen option}}, \index{if dimen LT=\meta{dimen option}},
    \index{if count GT=\meta{count option}}, \index{if count LT=\meta{count option}},
    \index{where dimen GT=\meta{dimen option}}, \index{where dimen LT=\meta{dimen option}},
    \index{where count GT=\meta{count option}} and \index{where count LT=\meta{count option}},
  \item Implement \index{if current nodewalk empty}.
  \item Implement nodewalk steps \index{leaves}, \index{-level} and \index{-level'}.
  \item Implement nodewalk operation \index{unique}.
  \item Implement \index{nodewalk key>on invalid} values \index{value of=on invalid>error if real} and \index{value of=on invalid>last valid}, remove value |step| (no \index{compat} key, as it was broken and useless).
  \item Implement `-` anchors (\index{anchor>-parent} etc.).
  \item Implement \index{save and restore register}.
  \item Implement \index{handler>nodewalk style}.
  \item Implement \index{forestloopcount}.
  \item Allow multiple occurrences of package option \index{compat}.
  %\item Implement \index{foresttypeouttrees}.
  %\item Implement \index{show register}.
  \end{itemize}

  Bugfixes:
  \begin{itemize}
  \item Fix a bug in externalization (|\forest@file@copy| set |\endlinechar| to |-1|, which caused
    problems for several packages, e.g. |biblatex|).
  \item Fix a bug in \index{delay n}: the number of cycles was reevaluated at each cycle.
  \item Fix a bug in \index{fixed edge angles}.
  \item Fix \index{compat} key values \index{value of=compat>silent}, \index{value of=compat>1.0-forstep} and \index{value of=compat>1.0-stages}.
  \item Fix invocations of spatial propagators \index{for step=\index{step>nodewalk}} and \index{for step=\index{step>Nodewalk}} and \index{node key>Nodewalk}.
  \item Fix invocations of \index{for step=group}, \index{for step=next on tier} and \index{for step=previous on tier}.
  \item Fix behaviour of \index{for step=next on tier}, \index{for step=previous on tier} and \index{for step=to tier} on arrival to the invalid node.
  \item Fix problems with interaction between \index{folder} and \index{forked edges}.
  \end{itemize}

\end{description}

\subsubsection{v2.0}


\begin{description}
\item[v2.0.3 (2016/04/03)] \mbox{}
  
  Backward incompatible changes (with a \index{compat} key):
  \begin{syntax}
  \compatitem{all}{2.0.2-delayn}
  \compatitem{all}{2.0.2-wrapnpgfmathargs}

  This is really a bugfix: keys \index{delay n} and \index{wrap $n$ pgfmath args} (for $n\geq 2$)
  were introducing two layers of hash doubling.  Now this confusing behaviour is gone, but as
  finding the correct number of hashes is always a tough job, \index{compat} keys are provided.
  \end{syntax}
  
  Improvements:
  
  \begin{itemize}
  \item Rework \index{draw tree edge} so that by default, an edge is drawn only it both its node and
    its node's parent are drawn. And yes, implement \index{if node drawn}.
  \item Implement circularity detection in dynamic node operations.
  \item Implement debug categories and debugging of dynamic node operations.
  \item Declare some further |tempdim...| registers.
  \item Make option \index{readonly option>id} accessible via \index{forestoption}.
  \end{itemize}
  
  Bugfixes:

  \begin{itemize}
  \item Execute \index{tikz} code for all (including phantom) nodes.  (The feature of ignoring
    phantom nodes was introduced in v2.0.2, but turns out it was a bad idea: for example, having a
    phantom root with some tikz code is not uncommon.)
  \item Keys \index{label} and \index{pin} now \emph{append} to option \index{tikz}, as makes sense.
  \item Fix nodewalk steps \index{filter} and \index{branch} so that they can be embedded under
    nodewalk operations. (Uh, and recategorize them as operations themselves.)
  \item Execute \index{before packing node} even when the node has no children.
  \item \index{step>level}|<={0}{...}| now works as expected.
  \item Re-setting the node name to the same value doesn't yield an error anymore.
  \item Don't add the separator when adding the first element to a keylist option or register.
  \item Copy externalization files in TeX (don't rely on |\write18|).
  \item Consistently store dimen options and registers with |pt|s of catcode other.
  \item Properly initialize readonly count options (\index{readonly option>n}, \index{readonly option>n'}, \index{n children} and
    \index{readonly option>level}).
  \item Fix some typos.
  \end{itemize}
  
\item[v2.0.2 (2016/03/04)] \mbox{}

  Backward incompatible changes:
  \begin{itemize}
  \item The semantics of the parenthesized optional argument to \index{forest} environment and
    \index{Forest} macro has changed. The argument was introduced in v2.0.0: if present, it
    redefined \index{style>stages} style for the current environment/macro.  This argument is now
    generalized to allow further (pre-\index{style>stages}) customization in future versions of the
    package. To temporarily redefine \index{style>stages}, write |(|\index{option of=forest>stages}|={...})|. 
  \end{itemize}

  New functionality:
  \begin{itemize}
  \item Key \index{last dynamic node} and named nodewalk \index{dynamic nodes}.
  \item An optional argument to \index{useforestlibrary} to pass package options to libraries.
  \item Handler \index{nodewalk style}.
  \item Keys \index{draw tree node'}, \index{draw tree edge'} and \index{draw tree tikz'}.
  \end{itemize}

  Bugfixes:
  \begin{itemize}
  \item Fixed \index{replace by} when applied to the root node.
  \item Registers are now initialized to an empty string, 0pt, or 0.
  \item Packing doesn't destroy the current pgfpath anymore.
  \item \index{forestStandardNode} now uses \index{name'}.
  \item \index{draw tree edge} now respects \index{phantom}.
  \end{itemize}

\item[v2.0.1 (2016/02/20)] \mbox{}

  New functionality:
  \begin{itemize}
  \item \index{current and siblings}, \index{current and siblings reversed}
  \item Add |*| argument to \index{useforestlibrary}.
  \end{itemize}
  
  Bugfixes:
  \begin{itemize}
  \item Correctly mangle option/register names to pgfmath names (\S\ref{ref:pgfmath}).
  \item Refer to parent (not node) anchor in \index{calign}|=|\index{edge midpoint}.
  \item Accept key \index{history} in \index{step>Nodewalk} config.
  \end{itemize}
\item[v2.0.0 (2016/01/30)] \mbox{}\footnote{The year of the release date in the package was wrong \dots \ 2015.}
  
  Backwards incompatible changes (\emph{without} a \index{compat} key --- sorry!):
  \begin{itemize}
  \item The unintended and undocumented way to specify defaults using |\forestset{.style={...}}|
    (see question
    \href{http://tex.stackexchange.com/questions/167972/making-a-certain-tree-style-the-default-for-forest}{Making
      a certain tree style the default for forest} at \TeX\ SE) does not work anymore. (Actually, it
    has never truly worked, and that's why it has not \index{compat} key.) Use \index{default
      preamble}.
  \item Renamed augmented assignment operator \meta{option}|-| for prepending to \meta{toks} and
    \meta{keylist} options \index{+toks=\meta{option}}\index[not print]{+keylist}.  A new
    \index{keylist-=\meta{option}} is defined for keylist options and means ``delete key from keylist.''
  \item Short nodewalk steps are not simply styles anymore: use \index{define short step} to
    define them.
  \end{itemize}

  Backwards incompatible changes with a \index{compat} key:

  \begin{syntax}
  \compatitem{all}{1.0-stages}
    
    Processing of \index{given options}, which is now exposed, and the new keylists \index{default
      preamble} and \index{preamble} is now included at the start of the default \index{style>stages}
    style.  When changing \index{style>stages}, the instruction to process these keylists must now be
    given explicitely.

  \compatitem{all}{1.0-forstep}

    In v1.0, a spatial propagator \index{for step=\meta{step}} could never fail.  This turned out to
    be difficult to debug.  In this version, when a propagator steps ``out of the tree'', an error
    is raised by default.  Check out \index{option of=Nodewalk>on invalid} to learn how to simulate
    the old behaviour without using this compatibility key.

  \compatitem{all}{1.0-rotate}

    This version of the package introduces
    option \index{rotate} and \index{autoforward}s it to \index{node options}.  This is needed to
    handle the new \foRest; anchors (\S\ref{sec:anchors}). However, in some rare cases (like the
    tree on the title page of this manual) it can lead to a discrepancy between the versions, as the
    time when the value given to \index{rotate} is processed is different. |1.0-rotate| removes
    option \index{rotate}.

  \compatitem{all}{1.0-name}

    Documentation of v1.0 requested that node names be unique, but this was not enforced by the
    package, sometimes leading to errors.  v2.0 enforces node name uniqueness. If this causes
    problems, use this compatibility key.  In most cases using \index{name'} instead of
    \index{option>name} should fix the problem without using compatibility mode.
    
  \item These keys have been renamed:
    
    \begin{tabularx}{\linewidth}{lll}
      old&new&\index{compat} key {\small (all but the last are in \texttt{-most})}\\\hline
      \keyname{node walk}&\index{for step=nodewalk}\footnote{Nodewalks are much improved in v2.0, so some syntax and keys are different than in v1.0!}&\indexdef{value of=compat>1.0-nodewalk}\\
      \keyname{for}&\index{for step=\index{group}}&\indexdef{value of=compat>1.0-for}\\
      \keyname{for all next}&\index{for step=\index{following siblings}}&\indexdef{value of=compat>1.0-forall}\\
      \keyname{for all previous}&\index{for step=\index{preceding siblings}}&\indexdef{value of=compat>1.0-forall}\\
      \keyname{for ancestors'}&\index{for step=\index{current and ancestors}}&\indexdef{value of=compat>1.0-ancestors}\\
      (\keyname{for}) \keyname{linear next}&(\index{for step}) \index{next node}&\indexdef{value of=compat>1.0-linear}\\
      (\keyname{for}) \keyname{linear previous}&(\index{for step}) \index{previous node}&\indexdef{value of=compat>1.0-linear}\\
      \keyname{triangle}&\index{roof} (library \reflibrary{linguistics})&\indexdef{value of=compat>1.0-triangle}\\
      \keyname{/tikz/fit to tree}&\index{fit to}\keyname{=}\index{tree}\footnote{The v1.0 key \keyname{/tikz/fit to tree} also set \keyname{inner sep=0}; the v2.0 key \index{fit to} does not do that.}&\indexdef{value of=compat>1.0-fittotree}\\
      \keyname{begin forest}, \keyname{end forest}&none (use \index{style>stages})&\index{1.0-stages}\\
      \keyname{end forest}, \keyname{end forest}&none (use \index{style>stages})&\index{1.0-stages}\\
    \end{tabularx}
  \end{syntax}

  Good news:
  \begin{itemize}
  \item Added temporal propagators \index{before packing node} and \index{after packing node}.
  \item \emph{Much} improved nodewalks, see \S\ref{ref:nodewalks} and \S\ref{ref:spatial-propagators}.
  \item Implemented looping mechanisms and more conditionals, see \S\ref{ref:conditionals}.
  \item Implemented library support and started filling up the libraries:
    \begin{itemize}
    \item \reflibrary{linguistics}: \index{sn edges}, \index{nice empty nodes}, \index{draw
        brackets}, \index{c-commanded} and \index{c-commanders}
    \item \reflibrary{edges}: \index{forked edges} and \index{folder}
    \end{itemize}
  \item Implemented aggregate functions, see \S\ref{ref:aggregate-functions}.
  \item Added key \index{default preamble}.
  \item Implemented anchors \index{anchor>parent}, \index{anchor>children}, \index{anchor>first},
    \index{anchor>last}, etc.
  \item Added key \index{split} and friends.
  \item Implemented sorting of children, see \S\ref{ref:dynamic}.
  \item Introduced registers, see \S\ref{sec:options-and-registers}.
  \item Implemented handlers \index{handler>option}, \index{handler>register} and \index{process args}.
  \item Implemented several friends to \index{process keylist}, introduced \index{processing order}s
    and \index{draw tree method}.
  \item Added the optional argument |(|\meta{stages}|)| to the \index{forest} environment and
    \index{Forest} macro.
  \item Implemented \index{autoforward}ing.
  \item Implemented flexible handling of unknown keys using \index{unknown to}.
  \item Implemented |pgfmath| functions \index{pgfmath>min_l}, \index{pgfmath>max_l}, \index{pgfmath>min_s}, \index{pgfmath>max_s}.
  \item Implemented augmented assignment operator \index{keylist-=\meta{keylist option}} for removing keys from keylists.
  \item Implemented a generalized \index{fit to} key.
  \item Implemented a very slow \foRest;-based indexing system (used to index this documentation)
    and included it in the gallery (\S\ref{sec:forest-index}).
  \item Added some minor keys: \index{edge path'}, \index{node format'}, \index{create'} and \index{plain content}.
  \item Added some developer keys: \index{copy command key}, \index{typeout}.
  \end{itemize}
  
  Bugfixes:
  \begin{itemize}
  \item In computation of numeric tree-structure info, when called for a non-root node.
  \item \TikZ;'s externalization internals (signature of
    |\tikzexternal@externalizefig@systemcall@uptodatecheck|) have changed: keep up to date,
    though only formally.
  \item \index{delay} was not behaving additively.
  \item \index{option>name}, \index{alias} and \index{baseline} didn't work properly when
    setting them for a non-current node.
  \item Augmented assignments for count options were leaking `.0pt'.
  \item \index{create} didn't work properly in some cases.
  \item \keyname{triangle} (now \index{roof} in \reflibrary{linguistics}) didn't use |cycle| in the edge path
  \end{itemize}

\end{description}

\subsubsection{v1.0}
  
\begin{description}
\item[v1.0.10 (2015/07/22)] \mbox{}
  \begin{compactitem}
  \item Bugfix: a left-over debugging |\typeout| command was interfering with a |forest| within |tabular|, see \href{http://tex.stackexchange.com/questions/256509/odd-incompatibility-between-multi-line-forest-nodes-and-tabular}{this question on TeX.SE}.
  \item A somewhat changed versioning scheme \dots
  \end{compactitem}
\item[v1.09 (2015/07/15)] \mbox{}
  \begin{compactitem}
  \item Bugfix: child alignment was not done in nodes with a single child, see \href{http://tex.stackexchange.com/questions/255309/elementary-forest-question-meaning-of-calign-parent-anchor-and-child-anchor}{this question on TeX.SE}.
  \end{compactitem}
\item[v1.08 (2015/07/10)] \mbox{}
  \begin{compactitem}
  \item Fix externalization (compatibility with new |tikz| features).
  \end{compactitem}
\item[v1.07 (2015/05/29)] \mbox{}
  \begin{compactitem}
  \item Require package |elocalloc| for local boxes, which were previously defined by package |etex|.
  \end{compactitem}
\item[v1.06 (2015/05/04)] \mbox{}
  \begin{compactitem}
  \item Load |etex| package: since v2.1a, |etoolbox| doesn't do it anymore.
  \end{compactitem}
\item[v1.05 (2014/03/07)] \mbox{}
  \begin{compactitem}
  \item Fix the node boundary code for rounded rectangle.  (Patch contributed by Paul Gaborit.)
  \end{compactitem}
\item[v1.04 (2013/10/17)] \mbox{}
  \begin{compactitem}
  \item Fixed an \href{http://tex.stackexchange.com/questions/138986/error-using-tikzexternalize-with-forest/139145}{externalization bug}.
  \end{compactitem}
\item[v1.03 (2013/01/28)] \mbox{}
  \begin{compactitem}
  \item Bugfix: options of dynamically created nodes didn't get processed.
  \item Bugfix: the bracket parser was losing spaces before opening braces.
  \item Bugfix: a family of utility macros dealing with affixing token lists was not expanding
    content correctly.
  \item Added style \index{math content}.
  \item Replace key \keyname{tikz preamble} with more general \index{begin draw} and
    \index{end draw}.
  \item Add keys \keyname{begin forest} and \keyname{end forest}.
  \end{compactitem}
\item[v1.02 (2013/01/20)] \mbox{}
  \begin{compactitem}
  \item Reworked style \index{style>stages}: it's easier to modify the processing flow now.
  \item Individual stages must now be explicitely called in the context of some (usually root)
    node. 
  \item Added \index{delay n} and \index{if have delayed}.
  \item Added (experimental) \index{pack'}.
  \item Added reference to the \href{https://github.com/sasozivanovic/forest-styles}{style
    repository}.
  \end{compactitem}
\item[v1.01 (2012/11/14)] \mbox{}

  \begin{compactitem}
  \item Compatibility with the |standalone| package: temporarily disable the effect of
    |standalone|'s package option |tikz| while typesetting nodes.
  \item Require at least the [2010/08/21] (v2.0) release of package |etoolbox|.
  \item Require version [2010/10/13] (v2.10, rcs-revision 1.76) of \PGF;/\TikZ;.  Future
    compatibility: adjust to the change of the ``not yet positioned'' node name (2.10 |@|
    $\rightarrow$ 2.10-csv |PGFINTERNAL|).
  \item Add this changelog.
  \end{compactitem}
\item[v1.0 (2012/10/31)] First public version
\end{description}



\subsection{Known bugs}
\label{sec:bugs}

If you find a bug (there are bound to be some \dots), please contact
me at \href{mailto:saso.zivanovic@guest.arnes.si}{saso.zivanovic@guest.arnes.si}.

\subsubsection*{System requirements}

This package requires \LaTeX\ and e\TeX.  If you use something
else: sorry.

The requirement for \LaTeX\ might be dropped in the future, when I get some time and energy for a
code-cleanup (read: to remedy the consequences of my bad programming practices and general
disorganization).

The requirement for e\TeX\ will probably stay.  If nothing else, \foRest; is heavy on boxes: every
node requires its own \dots\ and consequently, I have freely used e\TeX\ constructs in the code
\dots

\subsubsection*{\PGF; internals}

\FoRest; relies on some details of \PGF; implementation, like the name
of the ``not yet positioned'' nodes.  Thus, a new bug might appear with the development of \PGF;.
If you notice one, please let me know.

\subsubsection*{Edges cutting through sibling nodes}
\label{sec:cutting-edge}

In the following example, the R--B edge crosses the AAA node, although \index{ignore edge} is
set to the default |false|.
\begin{forestexample}[index={calign,{value of=calign>first},align,{value of=align>center},base,{value of=base>bottom}}]
  \begin{forest}
    calign=first
    [R[AAAAAAAAAA\\AAAAAAAAAA\\AAAAAAAAAA,align=center,base=bottom][B]]
  \end{forest}
\end{forestexample}
This happens because s-distances between the adjacent children are
computed before child alignment  (which is obviously the correct order in the general case), but
child alignment non-linearly influences the edges.  Observe that the with a different value of
\index{calign}, the problem does not arise. 
\begin{forestexample}[index={calign,{value of=calign>last},align,{value of=align>center},base,{value of=base>bottom}}]
  \begin{forest}
    calign=last
    [R[AAAAAAAAAA\\AAAAAAAAAA\\AAAAAAAAAA,align=center,base=bottom][B]]
  \end{forest}
\end{forestexample}
While it would be possible to fix the situation after child alignment (at least for some child
alignment methods), I have decided against that, since the distances between siblings would soon
become too large.  If the AAA node in the example above was large enough, B could easily be pushed
off the paper.  The bottomline is, please use manual adjustment to fix such situations. 

\subsubsection*{Orphans}
\label{sec:orphans}

If the \index{option>l} coordinates of adjacent children are too different (as a result of manual adjustment or
tier alignment), the packing algorithm might have nothing so say about the desired distance
between them: in this sense, node C below is an ``orphan.'' 
\begin{forestexample}[index={for step,tree,s sep,option>l,dimen*}]
  \begin{forest}
    for tree={s sep=0,draw},
    [R[A][B][C,l*=2][D][E]]
  \end{forest}
\end{forestexample}
To prevent orphans from ending up just anywhere, I have decided to vertically align them with
their preceding sibling --- although I'm not certain that's really the best solution.  In other
words, you can rely that the sequence of s-coordinates of siblings is non-decreasing.

The decision also influences a similar situation illustrated below.  The packing algorithm puts
node E immediately next to B (i.e.\ under C): however, the monotonicity-retaining mechanism then
vertically aligns it with its preceding sibling, D.
\begin{forestexample}[index={for step,tree,s sep,tier}]
  \begin{forest}
    for tree={s sep=0,draw},
    [R[A[B,tier=bottom]][C][D][E,tier=bottom]]
  \end{forest}
\end{forestexample}

Obviously, both examples also create the situation of an edge crossing some sibling node(s).
Again, I don't think anything sensible can be done about this, in general.


\subsection{Acknowledgements}

This package has turned out to be much more successful and widespread than I could have ever
imagined and I want to thank all the users for the trust.  Many of you have also contributed to the
package in some way: by providing comments and ideas, sending patches, reporting bugs and so on.  To
you, I'm doubly grateful!  I will not even try to list you all here, as the list is getting too long
for me to maintain, but I do want to mention one person, a member of the friendly community at the
excellent and indispensable \href{http://tex.stackexchange.com}{\TeX\ -- \LaTeX\ Stack Exchange} and
the author of the very first \foRest;-based package,
\href{http://ctan.org/pkg/prooftrees}{Prooftrees}: without |cfr|'s uncountable questions, answers,
bug reports and ideas, \foRest; would be a much poorer package indeed.



\addcontentsline{toc}{section}{References}
\bibliography{tex}
\bibliographystyle{plain}

\newpage
\phantomsection
\addcontentsline{toc}{section}{\indexname}
\addtocontents{toc}{\protect\setbox0=\protect\vbox{\protect\iffalse}\protect\fi}
\PrintIndex
%\addtocontents{toc}{\protect\iffalse{\protect\fi}}
%http://tex.stackexchange.com/questions/10291/addtocontents-at-end-of-document-not-getting-written-to-toc-file
\makeatletter
\immediate\write\@auxout{\noexpand\@writefile{toc}{\noexpand\iffalse{\noexpand\fi}}}
\makeatother



\end{document}

%%% Local Variables:
%%% mode: latex
%%% fill-column: 100
%%% TeX-command-default: "Make PDF"
%%% TeX-master: t
%%% End:
